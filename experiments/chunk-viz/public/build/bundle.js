
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
	'use strict';

	// generated during release, do not modify

	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const NAMESPACE_HTML = 'http://www.w3.org/1999/xhtml';
	const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';

	const ATTACHMENT_KEY = '@attach';

	const node_env = globalThis.process?.env?.NODE_ENV;
	var DEV = node_env && !node_env.toLowerCase().startsWith('prod');

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;
	var is_extensible = Object.isExtensible;

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * TODO replace with Promise.withResolvers once supported widely enough
	 * @template T
	 */
	function deferred() {
		/** @type {(value: T) => void} */
		var resolve;

		/** @type {(reason: any) => void} */
		var reject;

		/** @type {Promise<T>} */
		var promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});

		// @ts-expect-error
		return { promise, resolve, reject };
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const INSPECT_EFFECT = 1 << 17;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_PRESERVED = 1 << 19;
	const USER_EFFECT = 1 << 20;

	// Flags used for async
	const REACTION_IS_UPDATING = 1 << 21;
	const ASYNC = 1 << 22;

	const ERROR_VALUE = 1 << 23;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const LOADING_ATTR_SYMBOL = Symbol('');
	const PROXY_PATH_SYMBOL = Symbol('proxy path');

	/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
	const STALE_REACTION = new (class StaleReactionError extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();

	const ELEMENT_NODE = 1;
	const DOCUMENT_FRAGMENT_NODE = 11;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * A snippet function was passed invalid arguments. Snippets should only be instantiated via `{@render ...}`
	 * @returns {never}
	 */
	function invalid_snippet_arguments() {
		if (DEV) {
			const error = new Error(`invalid_snippet_arguments\nA snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`\nhttps://svelte.dev/e/invalid_snippet_arguments`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
		}
	}

	/**
	 * `%name%(...)` can only be used during component initialisation
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_outside_component(name) {
		if (DEV) {
			const error = new Error(`lifecycle_outside_component\n\`${name}(...)\` can only be used during component initialisation\nhttps://svelte.dev/e/lifecycle_outside_component`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
		}
	}

	/**
	 * Attempted to render a snippet without a `{@render}` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change `{snippet}` to `{@render snippet()}`.
	 * @returns {never}
	 */
	function snippet_without_render_tag() {
		if (DEV) {
			const error = new Error(`snippet_without_render_tag\nAttempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.\nhttps://svelte.dev/e/snippet_without_render_tag`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
		}
	}

	/**
	 * The `this` prop on `<svelte:element>` must be a string, if defined
	 * @returns {never}
	 */
	function svelte_element_invalid_this_value() {
		if (DEV) {
			const error = new Error(`svelte_element_invalid_this_value\nThe \`this\` prop on \`<svelte:element>\` must be a string, if defined\nhttps://svelte.dev/e/svelte_element_invalid_this_value`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	/**
	 * Cannot create a `$derived(...)` with an `await` expression outside of an effect tree
	 * @returns {never}
	 */
	function async_derived_orphan() {
		if (DEV) {
			const error = new Error(`async_derived_orphan\nCannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/async_derived_orphan`);
		}
	}

	/**
	 * Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5
	 * @param {string} method
	 * @param {string} component
	 * @returns {never}
	 */
	function component_api_changed(method, component) {
		if (DEV) {
			const error = new Error(`component_api_changed\nCalling \`${method}\` on a component instance (of ${component}) is no longer valid in Svelte 5\nhttps://svelte.dev/e/component_api_changed`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/component_api_changed`);
		}
	}

	/**
	 * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function component_api_invalid_new(component, name) {
		if (DEV) {
			const error = new Error(`component_api_invalid_new\nAttempted to instantiate ${component} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.\nhttps://svelte.dev/e/component_api_invalid_new`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		if (DEV) {
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/derived_references_self`);
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		if (DEV) {
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		if (DEV) {
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		if (DEV) {
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		if (DEV) {
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`
	 * @returns {never}
	 */
	function invalid_snippet() {
		if (DEV) {
			const error = new Error(`invalid_snippet\nCould not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`\nhttps://svelte.dev/e/invalid_snippet`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/invalid_snippet`);
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		if (DEV) {
			const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/props_invalid_value`);
		}
	}

	/**
	 * Rest element properties of `$props()` such as `%property%` are readonly
	 * @param {string} property
	 * @returns {never}
	 */
	function props_rest_readonly(property) {
		if (DEV) {
			const error = new Error(`props_rest_readonly\nRest element properties of \`$props()\` such as \`${property}\` are readonly\nhttps://svelte.dev/e/props_rest_readonly`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/props_rest_readonly`);
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		if (DEV) {
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		if (DEV) {
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		if (DEV) {
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		if (DEV) {
			const error = new Error(`state_unsafe_mutation\nUpdating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	/**
	 * A `<svelte:boundary>` `reset` function cannot be called while an error is still being handled
	 * @returns {never}
	 */
	function svelte_boundary_reset_onerror() {
		if (DEV) {
			const error = new Error(`svelte_boundary_reset_onerror\nA \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled\nhttps://svelte.dev/e/svelte_boundary_reset_onerror`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold$1 = 'font-weight: bold';
	var normal$1 = 'font-weight: normal';

	/**
	 * Detected reactivity loss when reading `%name%`. This happens when state is read in an async function after an earlier `await`
	 * @param {string} name
	 */
	function await_reactivity_loss(name) {
		if (DEV) {
			console.warn(`%c[svelte] await_reactivity_loss\n%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`\nhttps://svelte.dev/e/await_reactivity_loss`, bold$1, normal$1);
		} else {
			console.warn(`https://svelte.dev/e/await_reactivity_loss`);
		}
	}

	/**
	 * An async derived, `%name%` (%location%) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
	 * @param {string} name
	 * @param {string} location
	 */
	function await_waterfall(name, location) {
		if (DEV) {
			console.warn(`%c[svelte] await_waterfall\n%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app\nhttps://svelte.dev/e/await_waterfall`, bold$1, normal$1);
		} else {
			console.warn(`https://svelte.dev/e/await_waterfall`);
		}
	}

	/**
	 * The `value` property of a `<select multiple>` element should be an array, but it received a non-array value. The selection will be kept as is.
	 */
	function select_multiple_invalid_value() {
		if (DEV) {
			console.warn(`%c[svelte] select_multiple_invalid_value\n%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.\nhttps://svelte.dev/e/select_multiple_invalid_value`, bold$1, normal$1);
		} else {
			console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		if (DEV) {
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold$1, normal$1);
		} else {
			console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
		}
	}

	/**
	 * A `<svelte:boundary>` `reset` function only resets the boundary the first time it is called
	 */
	function svelte_boundary_reset_noop() {
		if (DEV) {
			console.warn(`%c[svelte] svelte_boundary_reset_noop\n%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called\nhttps://svelte.dev/e/svelte_boundary_reset_noop`, bold$1, normal$1);
		} else {
			console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
		}
	}

	/** @import { TemplateNode } from '#client' */


	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @param {TemplateNode} node */
	function reset(node) {
		return;
	}

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals$1(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	let async_mode_flag = false;
	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */


	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * `<svelte:element this="%tag%">` is a void element — it cannot have content
	 * @param {string} tag
	 */
	function dynamic_void_element_content(tag) {
		if (DEV) {
			console.warn(`%c[svelte] dynamic_void_element_content\n%c\`<svelte:element this="${tag}">\` is a void element — it cannot have content\nhttps://svelte.dev/e/dynamic_void_element_content`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
		}
	}

	/** @import { Derived, Reaction, Value } from '#client' */

	/**
	 * @param {string} label
	 * @returns {Error & { stack: string } | null}
	 */
	function get_stack(label) {
		let error = Error();
		const stack = error.stack;

		if (!stack) return null;

		const lines = stack.split('\n');
		const new_lines = ['\n'];

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			if (line === 'Error') {
				continue;
			}
			if (line.includes('validate_each_keys')) {
				return null;
			}
			if (line.includes('svelte/src/internal')) {
				continue;
			}
			new_lines.push(line);
		}

		if (new_lines.length === 1) {
			return null;
		}

		define_property(error, 'stack', {
			value: new_lines.join('\n')
		});

		define_property(error, 'name', {
			// 'Error' suffix is required for stack traces to be rendered properly
			value: `${label}Error`
		});

		return /** @type {Error & { stack: string }} */ (error);
	}

	/**
	 * @param {Value} source
	 * @param {string} label
	 */
	function tag(source, label) {
		source.label = label;
		tag_proxy(source.v, label);

		return source;
	}

	/**
	 * @param {unknown} value
	 * @param {string} label
	 */
	function tag_proxy(value, label) {
		// @ts-expect-error
		value?.[PROXY_PATH_SYMBOL]?.(label);
		return value;
	}

	/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */

	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/** @type {DevStackEntry | null} */
	let dev_stack = null;

	/** @param {DevStackEntry | null} stack */
	function set_dev_stack(stack) {
		dev_stack = stack;
	}

	/**
	 * Execute a callback with a new dev stack entry
	 * @param {() => any} callback - Function to execute
	 * @param {DevStackEntry['type']} type - Type of block/component
	 * @param {any} component - Component function
	 * @param {number} line - Line number
	 * @param {number} column - Column number
	 * @param {Record<string, any>} [additional] - Any additional properties to add to the dev stack entry
	 * @returns {any}
	 */
	function add_svelte_meta(callback, type, component, line, column, additional) {
		const parent = dev_stack;

		dev_stack = {
			type,
			file: component[FILENAME],
			line,
			column,
			parent,
			...additional
		};

		try {
			return callback();
		} finally {
			dev_stack = parent;
		}
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * Retrieves the context that belongs to the closest parent component with the specified `key`.
	 * Must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @returns {T}
	 */
	function getContext(key) {
		const context_map = get_or_init_context_map('getContext');
		const result = /** @type {T} */ (context_map.get(key));
		return result;
	}

	/**
	 * Associates an arbitrary `context` object with the current component and the specified `key`
	 * and returns that object. The context is then available to children of the component
	 * (including slotted content) with `getContext`.
	 *
	 * Like lifecycle functions, this must be called during component initialisation.
	 *
	 * @template T
	 * @param {any} key
	 * @param {T} context
	 * @returns {T}
	 */
	function setContext(key, context) {
		const context_map = get_or_init_context_map('setContext');

		context_map.set(key, context);
		return context;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push$1(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			s: props,
			x: null,
			l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
		};

		if (DEV) {
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		var context = /** @type {ComponentContext} */ (component_context);
		var effects = context.e;

		if (effects !== null) {
			context.e = null;

			for (var fn of effects) {
				create_user_effect(fn);
			}
		}

		if (component !== undefined) {
			context.x = component;
		}

		component_context = context.p;

		if (DEV) {
			dev_current_component_function = component_context?.function ?? null;
		}

		return component ?? /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/**
	 * @param {string} name
	 * @returns {Map<unknown, unknown>}
	 */
	function get_or_init_context_map(name) {
		if (component_context === null) {
			lifecycle_outside_component(name);
		}

		return (component_context.c ??= new Map(get_parent_context(component_context) || undefined));
	}

	/**
	 * @param {ComponentContext} component_context
	 * @returns {Map<unknown, unknown> | null}
	 */
	function get_parent_context(component_context) {
		let parent = component_context.p;
		while (parent !== null) {
			const context_map = parent.c;
			if (context_map !== null) {
				return context_map;
			}
			parent = parent.p;
		}
		return null;
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0 && !is_flushing_sync) {
			var tasks = micro_tasks;
			queueMicrotask(() => {
				// If this is false, a flushSync happened in the meantime. Do _not_ run new scheduled microtasks in that case
				// as the ordering of microtasks would be broken at that point - consider this case:
				// - queue_micro_task schedules microtask A to flush task X
				// - synchronously after, flushSync runs, processing task X
				// - synchronously after, some other microtask B is scheduled, but not through queue_micro_task but for example a Promise.resolve() in user code
				// - synchronously after, queue_micro_task schedules microtask C to flush task Y
				// - one tick later, microtask A now resolves, flushing task Y before microtask B, which is incorrect
				// This if check prevents that race condition (that realistically will only happen in tests)
				if (tasks === micro_tasks) run_micro_tasks();
			});
		}

		micro_tasks.push(fn);
	}

	/** @import { Derived, Effect } from '#client' */
	/** @import { Boundary } from './dom/blocks/boundary.js' */

	const adjustments = new WeakMap();

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = active_effect;

		// for unowned deriveds, don't throw until we read the value
		if (effect === null) {
			/** @type {Derived} */ (active_reaction).f |= ERROR_VALUE;
			return error;
		}

		if (DEV && error instanceof Error && !adjustments.has(error)) {
			adjustments.set(error, get_adjustments(error, effect));
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {
				if (!effect.parent && error instanceof Error) {
					apply_adjustments(error);
				}

				throw error;
			}

			/** @type {Boundary} */ (effect.b).error(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					/** @type {Boundary} */ (effect.b).error(error);
					return;
				} catch (e) {
					error = e;
				}
			}

			effect = effect.parent;
		}

		if (error instanceof Error) {
			apply_adjustments(error);
		}

		throw error;
	}

	/**
	 * Add useful information to the error message/stack in development
	 * @param {Error} error
	 * @param {Effect} effect
	 */
	function get_adjustments(error, effect) {
		const message_descriptor = get_descriptor(error, 'message');

		// if the message was already changed and it's not configurable we can't change it
		// or it will throw a different error swallowing the original error
		if (message_descriptor && !message_descriptor.configurable) return;

		var indent = is_firefox ? '  ' : '\t';
		var component_stack = `\n${indent}in ${effect.fn?.name || '<unknown>'}`;
		var context = effect.ctx;

		while (context !== null) {
			component_stack += `\n${indent}in ${context.function?.[FILENAME].split('/').pop()}`;
			context = context.p;
		}

		return {
			message: error.message + `\n${component_stack}\n`,
			stack: error.stack
				?.split('\n')
				.filter((line) => !line.includes('svelte/src/internal'))
				.join('\n')
		};
	}

	/**
	 * @param {Error} error
	 */
	function apply_adjustments(error) {
		const adjusted = adjustments.get(error);

		if (adjusted) {
			define_property(error, 'message', {
				value: adjusted.message
			});

			define_property(error, 'stack', {
				value: adjusted.stack
			});
		}
	}

	/** @import { Derived, Effect, Source } from '#client' */

	/** @type {Set<Batch>} */
	const batches = new Set();

	/** @type {Batch | null} */
	let current_batch = null;

	/** @type {Set<() => void>} */
	let effect_pending_updates = new Set();

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing = false;
	let is_flushing_sync = false;

	class Batch {
		/**
		 * The current values of any sources that are updated in this batch
		 * They keys of this map are identical to `this.#previous`
		 * @type {Map<Source, any>}
		 */
		current = new Map();

		/**
		 * The values of any sources that are updated in this batch _before_ those updates took place.
		 * They keys of this map are identical to `this.#current`
		 * @type {Map<Source, any>}
		 */
		#previous = new Map();

		/**
		 * When the batch is committed (and the DOM is updated), we need to remove old branches
		 * and append new ones by calling the functions added inside (if/each/key/etc) blocks
		 * @type {Set<() => void>}
		 */
		#callbacks = new Set();

		/**
		 * The number of async effects that are currently in flight
		 */
		#pending = 0;

		/**
		 * A deferred that resolves when the batch is committed, used with `settled()`
		 * TODO replace with Promise.withResolvers once supported widely enough
		 * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
		 */
		#deferred = null;

		/**
		 * True if an async effect inside this batch resolved and
		 * its parent branch was already deleted
		 */
		#neutered = false;

		/**
		 * Async effects (created inside `async_derived`) encountered during processing.
		 * These run after the rest of the batch has updated, since they should
		 * always have the latest values
		 * @type {Effect[]}
		 */
		#async_effects = [];

		/**
		 * The same as `#async_effects`, but for effects inside a newly-created
		 * `<svelte:boundary>` — these do not prevent the batch from committing
		 * @type {Effect[]}
		 */
		#boundary_async_effects = [];

		/**
		 * Template effects and `$effect.pre` effects, which run when
		 * a batch is committed
		 * @type {Effect[]}
		 */
		#render_effects = [];

		/**
		 * The same as `#render_effects`, but for `$effect` (which runs after)
		 * @type {Effect[]}
		 */
		#effects = [];

		/**
		 * Block effects, which may need to re-run on subsequent flushes
		 * in order to update internal sources (e.g. each block items)
		 * @type {Effect[]}
		 */
		#block_effects = [];

		/**
		 * Deferred effects (which run after async work has completed) that are DIRTY
		 * @type {Effect[]}
		 */
		#dirty_effects = [];

		/**
		 * Deferred effects that are MAYBE_DIRTY
		 * @type {Effect[]}
		 */
		#maybe_dirty_effects = [];

		/**
		 * A set of branches that still exist, but will be destroyed when this batch
		 * is committed — we skip over these during `process`
		 * @type {Set<Effect>}
		 */
		skipped_effects = new Set();

		/**
		 *
		 * @param {Effect[]} root_effects
		 */
		process(root_effects) {
			queued_root_effects = [];

			for (const root of root_effects) {
				this.#traverse_effect_tree(root);
			}

			// if we didn't start any new async work, and no async work
			// is outstanding from a previous flush, commit
			if (this.#async_effects.length === 0 && this.#pending === 0) {
				this.#commit();

				var render_effects = this.#render_effects;
				var effects = this.#effects;

				this.#render_effects = [];
				this.#effects = [];
				this.#block_effects = [];
				current_batch = null;

				flush_queued_effects(render_effects);
				flush_queued_effects(effects);

				// Reinstate the current batch if there was no new one created, as `process()` runs in a loop in `flush_effects()`.
				// That method expects `current_batch` to be set, and could run the loop again if effects result in new effects
				// being scheduled but without writes happening in which case no new batch is created.
				if (current_batch === null) {
					current_batch = this;
				} else {
					batches.delete(this);
				}

				this.#deferred?.resolve();
			} else {
				this.#defer_effects(this.#render_effects);
				this.#defer_effects(this.#effects);
				this.#defer_effects(this.#block_effects);
			}

			for (const effect of this.#async_effects) {
				update_effect(effect);
			}

			for (const effect of this.#boundary_async_effects) {
				update_effect(effect);
			}

			this.#async_effects = [];
			this.#boundary_async_effects = [];
		}

		/**
		 * Traverse the effect tree, executing effects or stashing
		 * them for later execution as appropriate
		 * @param {Effect} root
		 */
		#traverse_effect_tree(root) {
			root.f ^= CLEAN;

			var effect = root.first;

			while (effect !== null) {
				var flags = effect.f;
				var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
				var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

				var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);

				if (!skip && effect.fn !== null) {
					if (is_branch) {
						effect.f ^= CLEAN;
					} else if ((flags & EFFECT) !== 0) {
						this.#effects.push(effect);
					} else if ((flags & CLEAN) === 0) {
						if ((flags & ASYNC) !== 0) {
							var effects = effect.b?.is_pending()
								? this.#boundary_async_effects
								: this.#async_effects;

							effects.push(effect);
						} else if (is_dirty(effect)) {
							if ((effect.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect);
							update_effect(effect);
						}
					}

					var child = effect.first;

					if (child !== null) {
						effect = child;
						continue;
					}
				}

				var parent = effect.parent;
				effect = effect.next;

				while (effect === null && parent !== null) {
					effect = parent.next;
					parent = parent.parent;
				}
			}
		}

		/**
		 * @param {Effect[]} effects
		 */
		#defer_effects(effects) {
			for (const e of effects) {
				const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
				target.push(e);

				// mark as clean so they get scheduled if they depend on pending async state
				set_signal_status(e, CLEAN);
			}

			effects.length = 0;
		}

		/**
		 * Associate a change to a given source with the current
		 * batch, noting its previous and current values
		 * @param {Source} source
		 * @param {any} value
		 */
		capture(source, value) {
			if (!this.#previous.has(source)) {
				this.#previous.set(source, value);
			}

			this.current.set(source, source.v);
		}

		activate() {
			current_batch = this;
		}

		deactivate() {
			current_batch = null;

			for (const update of effect_pending_updates) {
				effect_pending_updates.delete(update);
				update();

				if (current_batch !== null) {
					// only do one at a time
					break;
				}
			}
		}

		neuter() {
			this.#neutered = true;
		}

		flush() {
			if (queued_root_effects.length > 0) {
				flush_effects();
			} else {
				this.#commit();
			}

			if (current_batch !== this) {
				// this can happen if a `flushSync` occurred during `flush_effects()`,
				// which is permitted in legacy mode despite being a terrible idea
				return;
			}

			if (this.#pending === 0) {
				batches.delete(this);
			}

			this.deactivate();
		}

		/**
		 * Append and remove branches to/from the DOM
		 */
		#commit() {
			if (!this.#neutered) {
				for (const fn of this.#callbacks) {
					fn();
				}
			}

			this.#callbacks.clear();
		}

		increment() {
			this.#pending += 1;
		}

		decrement() {
			this.#pending -= 1;

			if (this.#pending === 0) {
				for (const e of this.#dirty_effects) {
					set_signal_status(e, DIRTY);
					schedule_effect(e);
				}

				for (const e of this.#maybe_dirty_effects) {
					set_signal_status(e, MAYBE_DIRTY);
					schedule_effect(e);
				}

				this.#render_effects = [];
				this.#effects = [];

				this.flush();
			} else {
				this.deactivate();
			}
		}

		/** @param {() => void} fn */
		add_callback(fn) {
			this.#callbacks.add(fn);
		}

		settled() {
			return (this.#deferred ??= deferred()).promise;
		}

		static ensure() {
			if (current_batch === null) {
				const batch = (current_batch = new Batch());
				batches.add(current_batch);

				{
					Batch.enqueue(() => {
						if (current_batch !== batch) {
							// a flushSync happened in the meantime
							return;
						}

						batch.flush();
					});
				}
			}

			return current_batch;
		}

		/** @param {() => void} task */
		static enqueue(task) {
			queue_micro_task(task);
		}
	}

	function flush_effects() {
		var was_updating_effect = is_updating_effect;
		is_flushing = true;

		try {
			var flush_count = 0;
			set_is_updating_effect(true);

			while (queued_root_effects.length > 0) {
				var batch = Batch.ensure();

				if (flush_count++ > 1000) {
					if (DEV) {
						var updates = new Map();

						for (const source of batch.current.keys()) {
							for (const [stack, update] of source.updated ?? []) {
								var entry = updates.get(stack);

								if (!entry) {
									entry = { error: update.error, count: 0 };
									updates.set(stack, entry);
								}

								entry.count += update.count;
							}
						}

						for (const update of updates.values()) {
							// eslint-disable-next-line no-console
							console.error(update.error);
						}
					}

					infinite_loop_guard();
				}

				batch.process(queued_root_effects);
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			set_is_updating_effect(was_updating_effect);

			last_scheduled_effect = null;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {
			if (DEV) {
				// stack contains no useful information, replace it
				define_property(error, 'stack', { value: '' });
			}

			// Best effort: invoke the boundary nearest the most recent
			// effect and hope that it's relevant to the infinite loop
			invoke_error_boundary(error, last_scheduled_effect);
		}
	}

	/** @type {Effect[] | null} */
	let eager_block_effects = null;

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		var i = 0;

		while (i < length) {
			var effect = effects[i++];

			if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
				eager_block_effects = [];

				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					// if there's no teardown or abort controller we completely unlink
					// the effect from the graph
					if (effect.teardown === null && effect.ac === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}

				// If update_effect() has a flushSync() in it, we may have flushed another flush_queued_effects(),
				// which already handled this logic and did set eager_block_effects to null.
				if (eager_block_effects?.length > 0) {
					// TODO this feels incorrect! it gets the tests passing
					old_values.clear();

					for (const e of eager_block_effects) {
						update_effect(e);
					}

					eager_block_effects = [];
				}
			}
		}

		eager_block_effects = null;
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			// if the effect is being scheduled because a parent (each/await/etc) block
			// updated an internal source, bail out or we'll cause a second flush
			if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0) {
				return;
			}

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/**
	 * Returns a `subscribe` function that integrates external event-based systems with Svelte's reactivity.
	 * It's particularly useful for integrating with web APIs like `MediaQuery`, `IntersectionObserver`, or `WebSocket`.
	 *
	 * If `subscribe` is called inside an effect (including indirectly, for example inside a getter),
	 * the `start` callback will be called with an `update` function. Whenever `update` is called, the effect re-runs.
	 *
	 * If `start` returns a cleanup function, it will be called when the effect is destroyed.
	 *
	 * If `subscribe` is called in multiple effects, `start` will only be called once as long as the effects
	 * are active, and the returned teardown function will only be called when all effects are destroyed.
	 *
	 * It's best understood with an example. Here's an implementation of [`MediaQuery`](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery):
	 *
	 * ```js
	 * import { createSubscriber } from 'svelte/reactivity';
	 * import { on } from 'svelte/events';
	 *
	 * export class MediaQuery {
	 * 	#query;
	 * 	#subscribe;
	 *
	 * 	constructor(query) {
	 * 		this.#query = window.matchMedia(`(${query})`);
	 *
	 * 		this.#subscribe = createSubscriber((update) => {
	 * 			// when the `change` event occurs, re-run any effects that read `this.current`
	 * 			const off = on(this.#query, 'change', update);
	 *
	 * 			// stop listening when all the effects are destroyed
	 * 			return () => off();
	 * 		});
	 * 	}
	 *
	 * 	get current() {
	 * 		// This makes the getter reactive, if read in an effect
	 * 		this.#subscribe();
	 *
	 * 		// Return the current state of the query, whether or not we're in an effect
	 * 		return this.#query.matches;
	 * 	}
	 * }
	 * ```
	 * @param {(update: () => void) => (() => void) | void} start
	 * @since 5.7.0
	 */
	function createSubscriber(start) {
		let subscribers = 0;
		let version = source(0);
		/** @type {(() => void) | void} */
		let stop;

		if (DEV) {
			tag(version, 'createSubscriber version');
		}

		return () => {
			if (effect_tracking()) {
				get(version);

				render_effect(() => {
					if (subscribers === 0) {
						stop = untrack(() => start(() => increment(version)));
					}

					subscribers += 1;

					return () => {
						queue_micro_task(() => {
							// Only count down after a microtask, else we would reach 0 before our own render effect reruns,
							// but reach 1 again when the tick callback of the prior teardown runs. That would mean we
							// re-subcribe unnecessarily and create a memory leak because the old subscription is never cleaned up.
							subscribers -= 1;

							if (subscribers === 0) {
								stop?.();
								stop = undefined;
								// Increment the version to ensure any dependent deriveds are marked dirty when the subscription is picked up again later.
								// If we didn't do this then the comparison of write versions would determine that the derived has a later version than
								// the subscriber, and it would not be re-run.
								increment(version);
							}
						});
					};
				});
			}
		};
	}

	/** @import { Effect, Source, TemplateNode, } from '#client' */

	/**
	 * @typedef {{
	 * 	 onerror?: (error: unknown, reset: () => void) => void;
	 *   failed?: (anchor: Node, error: () => unknown, reset: () => () => void) => void;
	 *   pending?: (anchor: Node) => void;
	 * }} BoundaryProps
	 */

	var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;

	/**
	 * @param {TemplateNode} node
	 * @param {BoundaryProps} props
	 * @param {((anchor: Node) => void)} children
	 * @returns {void}
	 */
	function boundary(node, props, children) {
		new Boundary(node, props, children);
	}

	class Boundary {
		/** @type {Boundary | null} */
		parent;

		#pending = false;

		/** @type {TemplateNode} */
		#anchor;

		/** @type {TemplateNode | null} */
		#hydrate_open = null;

		/** @type {BoundaryProps} */
		#props;

		/** @type {((anchor: Node) => void)} */
		#children;

		/** @type {Effect} */
		#effect;

		/** @type {Effect | null} */
		#main_effect = null;

		/** @type {Effect | null} */
		#pending_effect = null;

		/** @type {Effect | null} */
		#failed_effect = null;

		/** @type {DocumentFragment | null} */
		#offscreen_fragment = null;

		#local_pending_count = 0;
		#pending_count = 0;

		#is_creating_fallback = false;

		/**
		 * A source containing the number of pending async deriveds/expressions.
		 * Only created if `$effect.pending()` is used inside the boundary,
		 * otherwise updating the source results in needless `Batch.ensure()`
		 * calls followed by no-op flushes
		 * @type {Source<number> | null}
		 */
		#effect_pending = null;

		#effect_pending_update = () => {
			if (this.#effect_pending) {
				internal_set(this.#effect_pending, this.#local_pending_count);
			}
		};

		#effect_pending_subscriber = createSubscriber(() => {
			this.#effect_pending = source(this.#local_pending_count);

			if (DEV) {
				tag(this.#effect_pending, '$effect.pending()');
			}

			return () => {
				this.#effect_pending = null;
			};
		});

		/**
		 * @param {TemplateNode} node
		 * @param {BoundaryProps} props
		 * @param {((anchor: Node) => void)} children
		 */
		constructor(node, props, children) {
			this.#anchor = node;
			this.#props = props;
			this.#children = children;

			this.parent = /** @type {Effect} */ (active_effect).b;

			this.#pending = !!this.#props.pending;

			this.#effect = block(() => {
				/** @type {Effect} */ (active_effect).b = this;

				{
					try {
						this.#main_effect = branch(() => children(this.#anchor));
					} catch (error) {
						this.error(error);
					}

					if (this.#pending_count > 0) {
						this.#show_pending_snippet();
					} else {
						this.#pending = false;
					}
				}
			}, flags);
		}

		#hydrate_resolved_content() {
			try {
				this.#main_effect = branch(() => this.#children(this.#anchor));
			} catch (error) {
				this.error(error);
			}

			// Since server rendered resolved content, we never show pending state
			// Even if client-side async operations are still running, the content is already displayed
			this.#pending = false;
		}

		#hydrate_pending_content() {
			const pending = this.#props.pending;
			if (!pending) {
				return;
			}
			this.#pending_effect = branch(() => pending(this.#anchor));

			Batch.enqueue(() => {
				this.#main_effect = this.#run(() => {
					Batch.ensure();
					return branch(() => this.#children(this.#anchor));
				});

				if (this.#pending_count > 0) {
					this.#show_pending_snippet();
				} else {
					pause_effect(/** @type {Effect} */ (this.#pending_effect), () => {
						this.#pending_effect = null;
					});

					this.#pending = false;
				}
			});
		}

		/**
		 * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
		 * @returns {boolean}
		 */
		is_pending() {
			return this.#pending || (!!this.parent && this.parent.is_pending());
		}

		has_pending_snippet() {
			return !!this.#props.pending;
		}

		/**
		 * @param {() => Effect | null} fn
		 */
		#run(fn) {
			var previous_effect = active_effect;
			var previous_reaction = active_reaction;
			var previous_ctx = component_context;

			set_active_effect(this.#effect);
			set_active_reaction(this.#effect);
			set_component_context(this.#effect.ctx);

			try {
				return fn();
			} catch (e) {
				handle_error(e);
				return null;
			} finally {
				set_active_effect(previous_effect);
				set_active_reaction(previous_reaction);
				set_component_context(previous_ctx);
			}
		}

		#show_pending_snippet() {
			const pending = /** @type {(anchor: Node) => void} */ (this.#props.pending);

			if (this.#main_effect !== null) {
				this.#offscreen_fragment = document.createDocumentFragment();
				move_effect(this.#main_effect, this.#offscreen_fragment);
			}

			if (this.#pending_effect === null) {
				this.#pending_effect = branch(() => pending(this.#anchor));
			}
		}

		/**
		 * Updates the pending count associated with the currently visible pending snippet,
		 * if any, such that we can replace the snippet with content once work is done
		 * @param {1 | -1} d
		 */
		#update_pending_count(d) {
			if (!this.has_pending_snippet()) {
				if (this.parent) {
					this.parent.#update_pending_count(d);
				}

				// if there's no parent, we're in a scope with no pending snippet
				return;
			}

			this.#pending_count += d;

			if (this.#pending_count === 0) {
				this.#pending = false;

				if (this.#pending_effect) {
					pause_effect(this.#pending_effect, () => {
						this.#pending_effect = null;
					});
				}

				if (this.#offscreen_fragment) {
					this.#anchor.before(this.#offscreen_fragment);
					this.#offscreen_fragment = null;
				}
			}
		}

		/**
		 * Update the source that powers `$effect.pending()` inside this boundary,
		 * and controls when the current `pending` snippet (if any) is removed.
		 * Do not call from inside the class
		 * @param {1 | -1} d
		 */
		update_pending_count(d) {
			this.#update_pending_count(d);

			this.#local_pending_count += d;
			effect_pending_updates.add(this.#effect_pending_update);
		}

		get_effect_pending() {
			this.#effect_pending_subscriber();
			return get(/** @type {Source<number>} */ (this.#effect_pending));
		}

		/** @param {unknown} error */
		error(error) {
			var onerror = this.#props.onerror;
			let failed = this.#props.failed;

			// If we have nothing to capture the error, or if we hit an error while
			// rendering the fallback, re-throw for another boundary to handle
			if (this.#is_creating_fallback || (!onerror && !failed)) {
				throw error;
			}

			if (this.#main_effect) {
				destroy_effect(this.#main_effect);
				this.#main_effect = null;
			}

			if (this.#pending_effect) {
				destroy_effect(this.#pending_effect);
				this.#pending_effect = null;
			}

			if (this.#failed_effect) {
				destroy_effect(this.#failed_effect);
				this.#failed_effect = null;
			}

			var did_reset = false;
			var calling_on_error = false;

			const reset = () => {
				if (did_reset) {
					svelte_boundary_reset_noop();
					return;
				}

				did_reset = true;

				if (calling_on_error) {
					svelte_boundary_reset_onerror();
				}

				// If the failure happened while flushing effects, current_batch can be null
				Batch.ensure();

				this.#local_pending_count = 0;

				if (this.#failed_effect !== null) {
					pause_effect(this.#failed_effect, () => {
						this.#failed_effect = null;
					});
				}

				// we intentionally do not try to find the nearest pending boundary. If this boundary has one, we'll render it on reset
				// but it would be really weird to show the parent's boundary on a child reset.
				this.#pending = this.has_pending_snippet();

				this.#main_effect = this.#run(() => {
					this.#is_creating_fallback = false;
					return branch(() => this.#children(this.#anchor));
				});

				if (this.#pending_count > 0) {
					this.#show_pending_snippet();
				} else {
					this.#pending = false;
				}
			};

			var previous_reaction = active_reaction;

			try {
				set_active_reaction(null);
				calling_on_error = true;
				onerror?.(error, reset);
				calling_on_error = false;
			} catch (error) {
				invoke_error_boundary(error, this.#effect && this.#effect.parent);
			} finally {
				set_active_reaction(previous_reaction);
			}

			if (failed) {
				queue_micro_task(() => {
					this.#failed_effect = this.#run(() => {
						this.#is_creating_fallback = true;

						try {
							return branch(() => {
								failed(
									this.#anchor,
									() => error,
									() => reset
								);
							});
						} catch (error) {
							invoke_error_boundary(error, /** @type {Effect} */ (this.#effect.parent));
							return null;
						} finally {
							this.#is_creating_fallback = false;
						}
					});
				});
			}
		}
	}

	/**
	 *
	 * @param {Effect} effect
	 * @param {DocumentFragment} fragment
	 */
	function move_effect(effect, fragment) {
		var node = effect.nodes_start;
		var end = effect.nodes_end;

		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			fragment.append(node);
			node = next;
		}
	}

	/** @import { Effect, Value } from '#client' */


	/**
	 *
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {(values: Value[]) => any} fn
	 */
	function flatten(sync, async, fn) {
		const d = is_runes() ? derived : derived_safe_equal;

		if (async.length === 0) {
			fn(sync.map(d));
			return;
		}

		var batch = current_batch;
		var parent = /** @type {Effect} */ (active_effect);

		var restore = capture();

		Promise.all(async.map((expression) => async_derived(expression)))
			.then((result) => {
				batch?.activate();

				restore();

				try {
					fn([...sync.map(d), ...result]);
				} catch (error) {
					// ignore errors in blocks that have already been destroyed
					if ((parent.f & DESTROYED) === 0) {
						invoke_error_boundary(error, parent);
					}
				}

				batch?.deactivate();
				unset_context();
			})
			.catch((error) => {
				invoke_error_boundary(error, parent);
			});
	}

	/**
	 * Captures the current effect context so that we can restore it after
	 * some asynchronous work has happened (so that e.g. `await a + b`
	 * causes `b` to be registered as a dependency).
	 */
	function capture() {
		var previous_effect = active_effect;
		var previous_reaction = active_reaction;
		var previous_component_context = component_context;
		var previous_batch = current_batch;

		return function restore() {
			set_active_effect(previous_effect);
			set_active_reaction(previous_reaction);
			set_component_context(previous_component_context);
			previous_batch?.activate();

			if (DEV) {
				set_from_async_derived(null);
			}
		};
	}

	/**
	 * Reset `current_async_effect` after the `promise` resolves, so
	 * that we can emit `await_reactivity_loss` warnings
	 * @template T
	 * @param {Promise<T>} promise
	 * @returns {Promise<() => T>}
	 */
	async function track_reactivity_loss(promise) {
		var previous_async_effect = current_async_effect;
		var value = await promise;

		return () => {
			set_from_async_derived(previous_async_effect);
			return value;
		};
	}

	function unset_context() {
		set_active_effect(null);
		set_active_reaction(null);
		set_component_context(null);
		if (DEV) set_from_async_derived(null);
	}

	/** @import { Derived, Effect, Source } from '#client' */
	/** @import { Batch } from './batch.js'; */

	/** @type {Effect | null} */
	let current_async_effect = null;

	/** @param {Effect | null} v */
	function set_from_async_derived(v) {
		current_async_effect = v;
	}

	const recent_async_deriveds = new Set();

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_PRESERVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals: equals$1,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (UNINITIALIZED),
			wv: 0,
			parent: parent_derived ?? active_effect,
			ac: null
		};

		if (DEV && tracing_mode_flag) {
			signal.created = get_stack('CreatedAt');
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V | Promise<V>} fn
	 * @param {string} [location] If provided, print a warning if the value is not read immediately after update
	 * @returns {Promise<Source<V>>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function async_derived(fn, location) {
		let parent = /** @type {Effect | null} */ (active_effect);

		if (parent === null) {
			async_derived_orphan();
		}

		var boundary = /** @type {Boundary} */ (parent.b);

		var promise = /** @type {Promise<V>} */ (/** @type {unknown} */ (undefined));
		var signal = source(/** @type {V} */ (UNINITIALIZED));

		/** @type {Promise<V> | null} */
		var prev = null;

		// only suspend in async deriveds created on initialisation
		var should_suspend = !active_reaction;

		async_effect(() => {
			if (DEV) current_async_effect = active_effect;

			try {
				var p = fn();
				// Make sure to always access the then property to read any signals
				// it might access, so that we track them as dependencies.
				if (prev) Promise.resolve(p).catch(() => {}); // avoid unhandled rejection
			} catch (error) {
				p = Promise.reject(error);
			}

			if (DEV) current_async_effect = null;

			var r = () => p;
			promise = prev?.then(r, r) ?? Promise.resolve(p);

			prev = promise;

			var batch = /** @type {Batch} */ (current_batch);
			var pending = boundary.is_pending();

			if (should_suspend) {
				boundary.update_pending_count(1);
				if (!pending) batch.increment();
			}

			/**
			 * @param {any} value
			 * @param {unknown} error
			 */
			const handler = (value, error = undefined) => {
				prev = null;

				current_async_effect = null;

				if (!pending) batch.activate();

				if (error) {
					if (error !== STALE_REACTION) {
						signal.f |= ERROR_VALUE;

						// @ts-expect-error the error is the wrong type, but we don't care
						internal_set(signal, error);
					}
				} else {
					if ((signal.f & ERROR_VALUE) !== 0) {
						signal.f ^= ERROR_VALUE;
					}

					internal_set(signal, value);

					if (DEV && location !== undefined) {
						recent_async_deriveds.add(signal);

						setTimeout(() => {
							if (recent_async_deriveds.has(signal)) {
								await_waterfall(/** @type {string} */ (signal.label), location);
								recent_async_deriveds.delete(signal);
							}
						});
					}
				}

				if (should_suspend) {
					boundary.update_pending_count(-1);
					if (!pending) batch.decrement();
				}

				unset_context();
			};

			promise.then(handler, (e) => handler(null, e || 'unknown'));

			if (batch) {
				return () => {
					queueMicrotask(() => batch.neuter());
				};
			}
		});

		if (DEV) {
			// add a flag that lets this be printed as a derived
			// when using `$inspect.trace()`
			signal.f |= ASYNC;
		}

		return new Promise((fulfil) => {
			/** @param {Promise<V>} p */
			function next(p) {
				function go() {
					if (p === promise) {
						fulfil(signal);
					} else {
						// if the effect re-runs before the initial promise
						// resolves, delay resolution until we have a value
						next(promise);
					}
				}

				p.then(go, go);
			}

			next(promise);
		});
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function user_derived(fn) {
		const d = derived(fn);

		push_reaction_value(d);

		return d;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		if (DEV) {
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		} else {
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) {
			return;
		}

		{
			var status =
				(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

			set_signal_status(derived, status);
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Set<any>} */
	let inspect_effects = new Set();

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	let inspect_effects_deferred = false;

	function set_inspect_effects_deferred() {
		inspect_effects_deferred = true;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals: equals$1,
			rv: 0,
			wv: 0
		};

		if (DEV && tracing_mode_flag) {
			signal.created = stack ?? get_stack('CreatedAt');
			signal.updated = null;
			signal.set_during_effect = false;
			signal.trace = null;
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v, stack);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			// since we are untracking the function inside `$inspect.with` we need to add this check
			// to ensure we error if state is set inside an inspect effect
			(!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 &&
			!current_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		if (DEV) {
			tag_proxy(new_value, /** @type {string} */ (source.label));
		}

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			var batch = Batch.ensure();
			batch.capture(source, old_value);

			if (DEV) {
				if (active_effect !== null) {
					const error = get_stack('UpdatedAt');

					if (error !== null) {
						source.updated ??= new Map();
						let entry = source.updated.get(error.stack);

						if (!entry) {
							entry = { error, count: 0 };
							source.updated.set(error.stack, entry);
						}

						entry.count++;
					}
				}

				if (active_effect !== null) {
					source.set_during_effect = true;
				}
			}

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (DEV && inspect_effects.size > 0 && !inspect_effects_deferred) {
				flush_inspect_effects();
			}
		}

		return value;
	}

	function flush_inspect_effects() {
		inspect_effects_deferred = false;

		const inspects = Array.from(inspect_effects);

		for (const effect of inspects) {
			// Mark clean inspect-effects as maybe dirty and then check their dirtiness
			// instead of just updating the effects - this way we avoid overfiring.
			if ((effect.f & CLEAN) !== 0) {
				set_signal_status(effect, MAYBE_DIRTY);
			}

			if (is_dirty(effect)) {
				update_effect(effect);
			}
		}

		inspect_effects.clear();
	}

	/**
	 * Silently (without using `get`) increment a source
	 * @param {Source<number>} source
	 */
	function increment(source) {
		set(source, source.v + 1);
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if (DEV && (flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			var not_dirty = (flags & DIRTY) === 0;

			// don't set a DIRTY reaction to MAYBE_DIRTY
			if (not_dirty) {
				set_signal_status(reaction, status);
			}

			if ((flags & DERIVED) !== 0) {
				mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
			} else if (not_dirty) {
				if ((flags & BLOCK_EFFECT) !== 0) {
					if (eager_block_effects !== null) {
						eager_block_effects.push(/** @type {Effect} */ (reaction));
					}
				}

				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @import { Source } from '#client' */

	// TODO move all regexes into shared module?
	const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);

		var stack = DEV && tracing_mode_flag ? get_stack('CreatedAt') : null;
		var parent_version = update_version;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			if (update_version === parent_version) {
				return fn();
			}

			// child source is being created after the initial proxy —
			// prevent it from being associated with the current reaction
			var reaction = active_reaction;
			var version = update_version;

			set_active_reaction(null);
			set_update_version(parent_version);

			var result = fn();

			set_active_reaction(reaction);
			set_update_version(version);

			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length, stack));
			if (DEV) {
				value = /** @type {any} */ (inspectable_array(/** @type {any[]} */ (value)));
			}
		}

		/** Used in dev for $inspect.trace() */
		var path = '';
		let updating = false;
		/** @param {string} new_path */
		function update_path(new_path) {
			if (updating) return;
			updating = true;
			path = new_path;

			tag(version, `${path} version`);

			// rename all child sources and child proxies
			for (const [prop, source] of sources) {
				tag(source, get_label(path, prop));
			}
			updating = false;
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value, stack);
						sources.set(prop, s);
						if (DEV && typeof prop === 'string') {
							tag(s, get_label(path, prop));
						}
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED, stack));
						sources.set(prop, s);
						increment(version);

						if (DEV) {
							tag(s, get_label(path, prop));
						}
					}
				} else {
					set(s, UNINITIALIZED);
					increment(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				if (DEV && prop === PROXY_PATH_SYMBOL) {
					return update_path;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p, stack);

						if (DEV) {
							tag(s, get_label(path, prop));
						}

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p, stack);

							if (DEV) {
								tag(s, get_label(path, prop));
							}

							return s;
						});

						sources.set(prop, s);
					}

					var value = get(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED, stack));
							sources.set(i + '', other_s);

							if (DEV) {
								tag(other_s, get_label(path, i));
							}
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined, stack));

						if (DEV) {
							tag(s, get_label(path, prop));
						}
						set(s, proxy(value));

						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					increment(version);
				}

				return true;
			},

			ownKeys(target) {
				get(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {string} path
	 * @param {string | symbol} prop
	 */
	function get_label(path, prop) {
		if (typeof prop === 'symbol') return `${path}[Symbol(${prop.description ?? ''})]`;
		if (regex_is_valid_identifier.test(prop)) return `${path}.${prop}`;
		return /^\d+$/.test(prop) ? `${path}[${prop}]` : `${path}['${prop}']`;
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 */
	function is(a, b) {
		return Object.is(get_proxied_value(a), get_proxied_value(b));
	}

	const ARRAY_MUTATING_METHODS = new Set([
		'copyWithin',
		'fill',
		'pop',
		'push',
		'reverse',
		'shift',
		'sort',
		'splice',
		'unshift'
	]);

	/**
	 * Wrap array mutating methods so $inspect is triggered only once and
	 * to prevent logging an array in intermediate state (e.g. with an empty slot)
	 * @param {any[]} array
	 */
	function inspectable_array(array) {
		return new Proxy(array, {
			get(target, prop, receiver) {
				var value = Reflect.get(target, prop, receiver);
				if (!ARRAY_MUTATING_METHODS.has(/** @type {string} */ (prop))) {
					return value;
				}

				/**
				 * @this {any[]}
				 * @param {any[]} args
				 */
				return function (...args) {
					set_inspect_effects_deferred();
					var result = value.apply(this, args);
					flush_inspect_effects();
					return result;
				};
			}
		});
	}

	function init_array_prototype_warnings() {
		const array_prototype = Array.prototype;
		// The REPL ends up here over and over, and this prevents it from adding more and more patches
		// of the same kind to the prototype, which would slow down everything over time.
		// @ts-expect-error
		const cleanup = Array.__svelte_cleanup;
		if (cleanup) {
			cleanup();
		}

		const { indexOf, lastIndexOf, includes } = array_prototype;

		array_prototype.indexOf = function (item, from_index) {
			const index = indexOf.call(this, item, from_index);

			if (index === -1) {
				for (let i = from_index ?? 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.indexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.lastIndexOf = function (item, from_index) {
			// we need to specify this.length - 1 because it's probably using something like
			// `arguments` inside so passing undefined is different from not passing anything
			const index = lastIndexOf.call(this, item, from_index ?? this.length - 1);

			if (index === -1) {
				for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.lastIndexOf(...)');
						break;
					}
				}
			}

			return index;
		};

		array_prototype.includes = function (item, from_index) {
			const has = includes.call(this, item, from_index);

			if (!has) {
				for (let i = 0; i < this.length; i += 1) {
					if (get_proxied_value(this[i]) === item) {
						state_proxy_equality_mismatch('array.includes(...)');
						break;
					}
				}
			}

			return has;
		};

		// @ts-expect-error
		Array.__svelte_cleanup = () => {
			array_prototype.indexOf = indexOf;
			array_prototype.lastIndexOf = lastIndexOf;
			array_prototype.includes = includes;
		};
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function strict_equals(a, b, equal = true) {
		// try-catch needed because this tries to read properties of `a` and `b`,
		// which could be disallowed for example in a secure context
		try {
			if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {
				state_proxy_equality_mismatch(equal ? '===' : '!==');
			}
		} catch {}

		return (a === b) === equal;
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function equals(a, b, equal = true) {
		if ((a == b) !== (get_proxied_value(a) == get_proxied_value(b))) {
			state_proxy_equality_mismatch(equal ? '==' : '!=');
		}

		return (a == b) === equal;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	// export these for reference in the compiled code, making global name deduplication unnecessary
	/** @type {Window} */
	var $window;

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * Initialize these lazily to avoid issues when using the runtime in a server context
	 * where these globals are not available while avoiding a separate server entry point
	 */
	function init_operations() {
		if ($window !== undefined) {
			return;
		}

		$window = window;
		is_firefox = /Firefox/.test(navigator.userAgent);

		var element_prototype = Element.prototype;
		var node_prototype = Node.prototype;
		var text_prototype = Text.prototype;

		// @ts-ignore
		first_child_getter = get_descriptor(node_prototype, 'firstChild').get;
		// @ts-ignore
		next_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;

		if (is_extensible(element_prototype)) {
			// the following assignments improve perf of lookups on DOM nodes
			// @ts-expect-error
			element_prototype.__click = undefined;
			// @ts-expect-error
			element_prototype.__className = undefined;
			// @ts-expect-error
			element_prototype.__attributes = null;
			// @ts-expect-error
			element_prototype.__style = undefined;
			// @ts-expect-error
			element_prototype.__e = undefined;
		}

		if (is_extensible(text_prototype)) {
			// @ts-expect-error
			text_prototype.__t = undefined;
		}

		if (DEV) {
			// @ts-expect-error
			element_prototype.__svelte_meta = null;

			init_array_prototype_warnings();
		}
	}

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode | TemplateNode[]} fragment
	 * @param {boolean} [is_text]
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text = false) {
		{
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/**
	 * Returns `true` if we're updating the current block, for example `condition` in
	 * an `{#if condition}` block just changed. In this case, the branch should be
	 * appended (or removed) at the same time as other updates within the
	 * current `<svelte:boundary>`
	 */
	function should_defer_append() {
		return false;
	}

	/**
	 * @param {HTMLElement} dom
	 * @param {boolean} value
	 * @returns {void}
	 */
	function autofocus(dom, value) {
		if (value) {
			const body = document.body;
			dom.autofocus = true;

			queue_micro_task(() => {
				if (document.activeElement === body) {
					dom.focus();
				}
			});
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		if (DEV) {
			// Ensure the parent is never an inspect effect
			while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
				parent = parent.parent;
			}
		}

		if (parent !== null && (parent.f & INERT) !== 0) {
			type |= INERT;
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			b: parent && parent.b,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0,
			ac: null
		};

		if (DEV) {
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		if (push) {
			/** @type {Effect | null} */
			var e = effect;

			// if an effect has already ran and doesn't need to be kept in the tree
			// (because it won't re-run, has no DOM, and has no teardown etc)
			// then we skip it and go to its child (if any)
			if (
				sync &&
				e.deps === null &&
				e.teardown === null &&
				e.nodes_start === null &&
				e.first === e.last && // either `null`, or a singular child
				(e.f & EFFECT_PRESERVED) === 0
			) {
				e = e.first;
			}

			if (e !== null) {
				e.parent = parent;

				if (parent !== null) {
					push_effect(e, parent);
				}

				// if we're in a derived, add the effect there too
				if (
					active_reaction !== null &&
					(active_reaction.f & DERIVED) !== 0 &&
					(type & ROOT_EFFECT) === 0
				) {
					var derived = /** @type {Derived} */ (active_reaction);
					(derived.effects ??= []).push(e);
				}
			}
		}

		return effect;
	}

	/**
	 * Internal representation of `$effect.tracking()`
	 * @returns {boolean}
	 */
	function effect_tracking() {
		return active_reaction !== null && !untracking;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		if (DEV) {
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var flags = /** @type {Effect} */ (active_effect).f;
		var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;

		if (defer) {
			// Top-level `$effect(...)` in an unmounted component — defer until mount
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push(fn);
		} else {
			// Everything else — create immediately
			return create_user_effect(fn);
		}
	}

	/**
	 * @param {() => void | (() => void)} fn
	 */
	function create_user_effect(fn) {
		return create_effect(EFFECT | USER_EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		if (DEV) {
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
	}

	/**
	 * An effect root whose children can transition out
	 * @param {() => void} fn
	 * @returns {(options?: { outro?: boolean }) => Promise<void>}
	 */
	function component_root(fn) {
		Batch.ensure();
		const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);

		return (options = {}) => {
			return new Promise((fulfil) => {
				if (options.outro) {
					pause_effect(effect, () => {
						destroy_effect(effect);
						fulfil(undefined);
					});
				} else {
					destroy_effect(effect);
					fulfil(undefined);
				}
			});
		};
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function effect(fn) {
		return create_effect(EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean, deps: () => any }} */
		var token = { effect: null, ran: false, deps };

		context.l.$.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			// Run dirty `$:` statements
			for (var token of context.l.$) {
				token.deps();

				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (is_dirty(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function async_effect(fn) {
		return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 */
	function template_effect(fn, sync = [], async = []) {
		flatten(sync, async, (values) => {
			create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
		});
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		var effect = create_effect(BLOCK_EFFECT | flags, fn, true);
		if (DEV) {
			effect.dev_stack = dev_stack;
		}
		return effect;
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			const controller = effect.ac;

			if (controller !== null) {
				without_reactive_context(() => {
					controller.abort(STALE_REACTION);
				});
			}

			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes_start !== null &&
			effect.nodes_end !== null
		) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		if (DEV) {
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
			effect.ac =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update. we don't use `is_dirty`
		// here because we don't want to eagerly recompute a derived like
		// `{#if foo}{foo.bar()}{/if}` if `foo` is now `undefined
		if ((effect.f & CLEAN) === 0) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_updating_effect = false;

	/** @param {boolean} value */
	function set_is_updating_effect(value) {
		is_updating_effect = value;
	}

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | Source[]}
	 */
	let current_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && (!async_mode_flag )) {
			if (current_sources === null) {
				current_sources = [value];
			} else {
				current_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	let update_version = read_version;

	/** @param {number} value */
	function set_update_version(value) {
		update_version = value;
	}

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function is_dirty(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency, unless the effect has already been destroyed
				// (which can happen if the derived is read by an async derived)
				if (
					(is_disconnected || is_unowned_connected) &&
					(active_effect === null || (active_effect.f & DESTROYED) === 0)
				) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (is_dirty(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		if (current_sources?.includes(signal)) {
			return;
		}

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_sources = current_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var previous_update_version = update_version;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		current_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		update_version = ++read_version;

		if (reaction.ac !== null) {
			without_reactive_context(() => {
				/** @type {AbortController} */ (reaction.ac).abort(STALE_REACTION);
			});

			reaction.ac = null;
		}

		try {
			reaction.f |= REACTION_IS_UPDATING;
			var fn = /** @type {Function} */ (reaction.fn);
			var result = fn();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (
					!skip_reaction ||
					// Deriveds that already have reactions can cleanup, so we still add them as reactions
					((flags & DERIVED) !== 0 &&
						/** @type {import('#client').Derived} */ (reaction).reactions !== null)
				) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			if ((reaction.f & ERROR_VALUE) !== 0) {
				reaction.f ^= ERROR_VALUE;
			}

			return result;
		} catch (error) {
			return handle_error(error);
		} finally {
			reaction.f ^= REACTION_IS_UPDATING;
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			current_sources = previous_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
			update_version = previous_update_version;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}

		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		if (DEV) {
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
			var previous_stack = /** @type {any} */ (dev_stack);
			// only block effects have a dev stack, keep the current one otherwise
			set_dev_stack(effect.dev_stack ?? dev_stack);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) {
				for (var dep of effect.deps) {
					if (dep.set_during_effect) {
						dep.wv = increment_write_version();
						dep.set_during_effect = false;
					}
				}
			}
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;

			if (DEV) {
				set_dev_current_component_function(previous_component_fn);
				set_dev_stack(previous_stack);
			}
		}
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			// if we're in a derived that is being read inside an _async_ derived,
			// it's possible that the effect was already destroyed. In this case,
			// we don't add the dependency, because that would create a memory leak
			var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;

			if (!destroyed && !current_sources?.includes(signal)) {
				var deps = active_reaction.deps;

				if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
					// we're in the effect init/update cycle
					if (signal.rv < read_version) {
						signal.rv = read_version;

						// If the signal is accessing the same dependencies in the same
						// order as it did last time, increment `skipped_deps`
						// rather than updating `new_deps`, which creates GC cost
						if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
							skipped_deps++;
						} else if (new_deps === null) {
							new_deps = [signal];
						} else if (!skip_reaction || !new_deps.includes(signal)) {
							// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
							// an unowned derived because skip_reaction is true, then we need to ensure that
							// we don't have duplicates
							new_deps.push(signal);
						}
					}
				} else {
					// we're adding a dependency outside the init/update cycle
					// (i.e. after an `await`)
					(active_reaction.deps ??= []).push(signal);

					var reactions = signal.reactions;

					if (reactions === null) {
						signal.reactions = [active_reaction];
					} else if (!reactions.includes(active_reaction)) {
						reactions.push(active_reaction);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (DEV) {
			if (current_async_effect) {
				var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0;
				var was_read = current_async_effect.deps?.includes(signal);

				if (!tracking && !untracking && !was_read) {
					await_reactivity_loss(/** @type {string} */ (signal.label));

					var trace = get_stack('TracedAt');
					// eslint-disable-next-line no-console
					if (trace) console.warn(trace);
				}
			}

			recent_async_deriveds.delete(signal);
		}

		if (is_destroying_effect) {
			if (old_values.has(signal)) {
				return old_values.get(signal);
			}

			if (is_derived) {
				derived = /** @type {Derived} */ (signal);

				var value = derived.v;

				// if the derived is dirty and has reactions, or depends on the values that just changed, re-execute
				// (a derived can be maybe_dirty due to the effect destroy removing its last reaction)
				if (
					((derived.f & CLEAN) === 0 && derived.reactions !== null) ||
					depends_on_old_values(derived)
				) {
					value = execute_derived(derived);
				}

				old_values.set(derived, value);

				return value;
			}
		} else if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (is_dirty(derived)) {
				update_derived(derived);
			}
		}

		if ((signal.f & ERROR_VALUE) !== 0) {
			throw signal.v;
		}

		return signal.v;
	}

	/** @param {Derived} derived */
	function depends_on_old_values(derived) {
		if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst
		if (derived.deps === null) return false;

		for (const dep of derived.deps) {
			if (old_values.has(dep)) {
				return true;
			}

			if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/** @type {Set<string>} */
	const all_registered_events = new Set();

	/** @type {Set<(events: Array<string>) => void>} */
	const root_event_handles = new Set();

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		if (
			dom === document.body ||
			// @ts-ignore
			dom === window ||
			// @ts-ignore
			dom === document ||
			// Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
			dom instanceof HTMLMediaElement
		) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	/**
	 * @param {Array<string>} events
	 * @returns {void}
	 */
	function delegate(events) {
		for (var i = 0; i < events.length; i++) {
			all_registered_events.add(events[i]);
		}

		for (var fn of root_event_handles) {
			fn(events);
		}
	}

	// used to store the reference to the currently propagated event
	// to prevent garbage collection between microtasks in Firefox
	// If the event object is GCed too early, the expando __root property
	// set on the event object is lost, causing the event delegation
	// to process the event twice
	let last_propagated_event = null;

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		last_propagated_event = event;

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// the `last_propagated_event === event` check is redundant, but
		// without it the variable will be DCE'd and things will
		// fail mysteriously in Firefox
		// @ts-expect-error is added below
		var handled_at = last_propagated_event === event && event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { TemplateStructure } from './types' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {any} value
	 */
	function text$1(value = '') {
		{
			var t = create_text(value + '');
			assign_nodes(t, t);
			return t;
		}
	}

	/**
	 * @returns {TemplateNode | DocumentFragment}
	 */
	function comment() {

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	const VOID_ELEMENT_NAMES = [
		'area',
		'base',
		'br',
		'col',
		'command',
		'embed',
		'hr',
		'img',
		'input',
		'keygen',
		'link',
		'meta',
		'param',
		'source',
		'track',
		'wbr'
	];

	/**
	 * Returns `true` if `name` is of a void element
	 * @param {string} name
	 */
	function is_void(name) {
		return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';
	}

	/**
	 * @param {string} name
	 */
	function is_capture_event(name) {
		return name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';
	}

	/** List of Element events that will be delegated */
	const DELEGATED_EVENTS = [
		'beforeinput',
		'click',
		'change',
		'dblclick',
		'contextmenu',
		'focusin',
		'focusout',
		'input',
		'keydown',
		'keyup',
		'mousedown',
		'mousemove',
		'mouseout',
		'mouseover',
		'mouseup',
		'pointerdown',
		'pointermove',
		'pointerout',
		'pointerover',
		'pointerup',
		'touchend',
		'touchmove',
		'touchstart'
	];

	/**
	 * Returns `true` if `event_name` is a delegated event
	 * @param {string} event_name
	 */
	function is_delegated(event_name) {
		return DELEGATED_EVENTS.includes(event_name);
	}

	/**
	 * @type {Record<string, string>}
	 * List of attribute names that should be aliased to their property names
	 * because they behave differently between setting them as an attribute and
	 * setting them as a property.
	 */
	const ATTRIBUTE_ALIASES = {
		// no `class: 'className'` because we handle that separately
		formnovalidate: 'formNoValidate',
		ismap: 'isMap',
		nomodule: 'noModule',
		playsinline: 'playsInline',
		readonly: 'readOnly',
		defaultvalue: 'defaultValue',
		defaultchecked: 'defaultChecked',
		srcobject: 'srcObject',
		novalidate: 'noValidate',
		allowfullscreen: 'allowFullscreen',
		disablepictureinpicture: 'disablePictureInPicture',
		disableremoteplayback: 'disableRemotePlayback'
	};

	/**
	 * @param {string} name
	 */
	function normalize_attribute(name) {
		name = name.toLowerCase();
		return ATTRIBUTE_ALIASES[name] ?? name;
	}

	/**
	 * Subset of delegated events which should be passive by default.
	 * These two are already passive via browser defaults on window, document and body.
	 * But since
	 * - we're delegating them
	 * - they happen often
	 * - they apply to mobile which is generally less performant
	 * we're marking them as passive by default for other elements, too.
	 */
	const PASSIVE_EVENTS = ['touchstart', 'touchmove'];

	/**
	 * Returns `true` if `name` is a passive event
	 * @param {string} name
	 */
	function is_passive_event(name) {
		return PASSIVE_EVENTS.includes(name);
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */
	/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.
	 * Transitions will play during the initial render unless the `intro` option is set to `false`.
	 *
	 * @template {Record<string, any>} Props
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component
	 * @param {MountOptions<Props>} options
	 * @returns {Exports}
	 */
	function mount(component, options) {
		return _mount(component, options);
	}

	/** @type {Map<string, number>} */
	const document_listeners = new Map();

	/**
	 * @template {Record<string, any>} Exports
	 * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component
	 * @param {MountOptions} options
	 * @returns {Exports}
	 */
	function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
		init_operations();

		/** @type {Set<string>} */
		var registered_events = new Set();

		/** @param {Array<string>} events */
		var event_handle = (events) => {
			for (var i = 0; i < events.length; i++) {
				var event_name = events[i];

				if (registered_events.has(event_name)) continue;
				registered_events.add(event_name);

				var passive = is_passive_event(event_name);

				// Add the event listener to both the container and the document.
				// The container listener ensures we catch events from within in case
				// the outer content stops propagation of the event.
				target.addEventListener(event_name, handle_event_propagation, { passive });

				var n = document_listeners.get(event_name);

				if (n === undefined) {
					// The document listener ensures we catch events that originate from elements that were
					// manually moved outside of the container (e.g. via manual portals).
					document.addEventListener(event_name, handle_event_propagation, { passive });
					document_listeners.set(event_name, 1);
				} else {
					document_listeners.set(event_name, n + 1);
				}
			}
		};

		event_handle(array_from(all_registered_events));
		root_event_handles.add(event_handle);

		/** @type {Exports} */
		// @ts-expect-error will be defined because the render effect runs synchronously
		var component = undefined;

		var unmount = component_root(() => {
			var anchor_node = anchor ?? target.appendChild(create_text());

			boundary(
				/** @type {TemplateNode} */ (anchor_node),
				{
					pending: () => {}
				},
				(anchor_node) => {
					if (context) {
						push$1({});
						var ctx = /** @type {ComponentContext} */ (component_context);
						ctx.c = context;
					}

					if (events) {
						// We can't spread the object or else we'd lose the state proxy stuff, if it is one
						/** @type {any} */ (props).$$events = events;
					}
					// @ts-expect-error the public typings are not what the actual function looks like
					component = Component(anchor_node, props) || {};

					if (context) {
						pop();
					}
				}
			);

			return () => {
				for (var event_name of registered_events) {
					target.removeEventListener(event_name, handle_event_propagation);

					var n = /** @type {number} */ (document_listeners.get(event_name));

					if (--n === 0) {
						document.removeEventListener(event_name, handle_event_propagation);
						document_listeners.delete(event_name);
					} else {
						document_listeners.set(event_name, n);
					}
				}

				root_event_handles.delete(event_handle);

				if (anchor_node !== anchor) {
					anchor_node.parentNode?.removeChild(anchor_node);
				}
			};
		});

		mounted_components.set(component, unmount);
		return component;
	}

	/**
	 * References of the components that were mounted or hydrated.
	 * Uses a `WeakMap` to avoid memory leaks.
	 */
	let mounted_components = new WeakMap();

	/**
	 * @param {() => string} tag_fn
	 * @returns {void}
	 */
	function validate_void_dynamic_element(tag_fn) {
		const tag = tag_fn();
		if (tag && is_void(tag)) {
			dynamic_void_element_content(tag);
		}
	}

	/** @param {() => unknown} tag_fn */
	function validate_dynamic_element_tag(tag_fn) {
		const tag = tag_fn();
		const is_string = typeof tag === 'string';
		if (tag && !is_string) {
			svelte_element_invalid_this_value();
		}
	}

	/**
	 * @template {(...args: any[]) => unknown} T
	 * @param {T} fn
	 */
	function prevent_snippet_stringification(fn) {
		fn.toString = () => {
			snippet_without_render_tag();
			return '';
		};
		return fn;
	}

	/** @import { Snippet } from 'svelte' */
	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Getters } from '#shared' */

	/**
	 * @template {(node: TemplateNode, ...args: any[]) => void} SnippetFn
	 * @param {TemplateNode} node
	 * @param {() => SnippetFn | null | undefined} get_snippet
	 * @param {(() => any)[]} args
	 * @returns {void}
	 */
	function snippet(node, get_snippet, ...args) {
		var anchor = node;

		/** @type {SnippetFn | null | undefined} */
		// @ts-ignore
		var snippet = noop;

		/** @type {Effect | null} */
		var snippet_effect;

		block(() => {
			if (snippet === (snippet = get_snippet())) return;

			if (snippet_effect) {
				destroy_effect(snippet_effect);
				snippet_effect = null;
			}

			if (DEV && snippet == null) {
				invalid_snippet();
			}

			snippet_effect = branch(() => /** @type {SnippetFn} */ (snippet)(anchor, ...args));
		}, EFFECT_TRANSPARENT);
	}

	/**
	 * In development, wrap the snippet function so that it passes validation, and so that the
	 * correct component context is set for ownership checks
	 * @param {any} component
	 * @param {(node: TemplateNode, ...args: any[]) => void} fn
	 */
	function wrap_snippet(component, fn) {
		const snippet = (/** @type {TemplateNode} */ node, /** @type {any[]} */ ...args) => {
			var previous_component_function = dev_current_component_function;
			set_dev_current_component_function(component);

			try {
				return fn(node, ...args);
			} finally {
				set_dev_current_component_function(previous_component_function);
			}
		};

		prevent_snippet_stringification(snippet);

		return snippet;
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */
	/** @import { EventDispatcher } from './index.js' */
	/** @import { NotFunction } from './internal/types.js' */

	if (DEV) {
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	/**
	 * `onMount`, like [`$effect`](https://svelte.dev/docs/svelte/$effect), schedules a function to run as soon as the component has been mounted to the DOM.
	 * Unlike `$effect`, the provided function only runs once.
	 *
	 * It must be called during the component's initialisation (but doesn't need to live _inside_ the component;
	 * it can be called from an external module). If a function is returned _synchronously_ from `onMount`,
	 * it will be called when the component is unmounted.
	 *
	 * `onMount` functions do not run during [server-side rendering](https://svelte.dev/docs/svelte/svelte-server#render).
	 *
	 * @template T
	 * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		if (component_context === null) {
			lifecycle_outside_component('onMount');
		}

		if (legacy_mode_flag && component_context.l !== null) {
			init_update_callbacks(component_context).m.push(fn);
		} else {
			user_effect(() => {
				const cleanup = untrack(fn);
				if (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);
			});
		}
	}

	/**
	 * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate
	 * @param {ComponentContext} context
	 */
	function init_update_callbacks(context) {
		var l = /** @type {ComponentContextLegacy} */ (context).l;
		return (l.u ??= { a: [], b: [], m: [] });
	}

	/** @import { SourceLocation } from '#client' */

	/**
	 * @param {any} fn
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 * @returns {any}
	 */
	function add_locations(fn, filename, locations) {
		return (/** @type {any[]} */ ...args) => {
			const dom = fn(...args);

			var node = dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
			assign_locations(node, filename, locations);

			return dom;
		};
	}

	/**
	 * @param {Element} element
	 * @param {string} filename
	 * @param {SourceLocation} location
	 */
	function assign_location(element, filename, location) {
		// @ts-expect-error
		element.__svelte_meta = {
			parent: dev_stack,
			loc: { file: filename, line: location[0], column: location[1] }
		};

		if (location[2]) {
			assign_locations(element.firstChild, filename, location[2]);
		}
	}

	/**
	 * @param {Node | null} node
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 */
	function assign_locations(node, filename, locations) {
		var i = 0;

		while (node && i < locations.length) {

			if (node.nodeType === ELEMENT_NODE) {
				assign_location(/** @type {Element} */ (node), filename, locations[i++]);
			}

			node = node.nextSibling;
		}
	}

	/** @param {Function & { [FILENAME]: string }} target */
	function check_target(target) {
		if (target) {
			component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);
		}
	}

	function legacy_api() {
		const component = component_context?.function;

		/** @param {string} method */
		function error(method) {
			component_api_changed(method, component[FILENAME]);
		}

		return {
			$destroy: () => error('$destroy()'),
			$on: () => error('$on(...)'),
			$set: () => error('$set(...)')
		};
	}

	/**
	 * @param {Node} anchor
	 * @param {...(()=>any)[]} args
	 */
	function validate_snippet_args(anchor, ...args) {
		if (typeof anchor !== 'object' || !(anchor instanceof Node)) {
			invalid_snippet_arguments();
		}

		for (let arg of args) {
			if (typeof arg !== 'function') {
				invalid_snippet_arguments();
			}
		}
	}

	/** @import { Effect, TemplateNode } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	// TODO reinstate https://github.com/sveltejs/svelte/pull/15250

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {typeof UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		/** @type {DocumentFragment | null} */
		var offscreen_fragment = null;

		function commit() {
			if (offscreen_fragment !== null) {
				// remove the anchor
				/** @type {Text} */ (offscreen_fragment.lastChild).remove();

				anchor.before(offscreen_fragment);
				offscreen_fragment = null;
			}

			var active = condition ? consequent_effect : alternate_effect;
			var inactive = condition ? alternate_effect : consequent_effect;

			if (active) {
				resume_effect(active);
			}

			if (inactive) {
				pause_effect(inactive, () => {
					if (condition) {
						alternate_effect = null;
					} else {
						consequent_effect = null;
					}
				});
			}
		}

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			var defer = should_defer_append();
			var target = anchor;

			if (defer) {
				offscreen_fragment = document.createDocumentFragment();
				offscreen_fragment.append((target = create_text()));
			}

			if (condition) {
				consequent_effect ??= fn && branch(() => fn(target));
			} else {
				alternate_effect ??= fn && branch(() => fn(target));
			}

			if (defer) {
				var batch = /** @type {Batch} */ (current_batch);

				var active = condition ? consequent_effect : alternate_effect;
				var inactive = condition ? alternate_effect : consequent_effect;

				if (active) batch.skipped_effects.delete(active);
				if (inactive) batch.skipped_effects.add(inactive);

				batch.add_callback(commit);
			} else {
				commit();
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index$1(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 */
	function pause_effects(state, items, controlled_anchor) {
		var items_map = state.items;

		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link$1(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link$1(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = parent_node.appendChild(create_text());
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		/** @type {Map<any, EachItem>} */
		var offscreen_items = new Map();

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		/** @type {V[]} */
		var array;

		/** @type {Effect} */
		var each_effect;

		function commit() {
			reconcile(
				each_effect,
				array,
				state,
				offscreen_items,
				anchor,
				render_fn,
				flags,
				get_key,
				get_collection
			);

			if (fallback_fn !== null) {
				if (array.length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}
		}

		block(() => {
			// store a reference to the effect so that we can update the start/end nodes in reconciliation
			each_effect ??= /** @type {Effect} */ (active_effect);

			array = /** @type {V[]} */ (get(each_array));
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			// this is separate to the previous block because `hydrating` might change
			var item, i, value, key; 

			{
				if (should_defer_append()) {
					var keys = new Set();
					var batch = /** @type {Batch} */ (current_batch);

					for (i = 0; i < length; i += 1) {
						value = array[i];
						key = get_key(value, i);

						var existing = state.items.get(key) ?? offscreen_items.get(key);

						if (existing) {
							// update before reconciliation, to trigger any async updates
							if ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
								update_item(existing, value, i, flags);
							}
						} else {
							item = create_item(
								null,
								state,
								null,
								null,
								value,
								key,
								i,
								render_fn,
								flags,
								get_collection,
								true
							);

							offscreen_items.set(key, item);
						}

						keys.add(key);
					}

					for (const [key, item] of state.items) {
						if (!keys.has(key)) {
							batch.skipped_effects.add(item.e);
						}
					}

					batch.add_callback(commit);
				} else {
					commit();
				}
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get(each_array);
		});
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Effect} each_effect
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Map<any, EachItem>} offscreen_items
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(
		each_effect,
		array,
		state,
		offscreen_items,
		anchor,
		render_fn,
		flags,
		get_key,
		get_collection
	) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);

			item = items.get(key);

			if (item === undefined) {
				var pending = offscreen_items.get(key);

				if (pending !== undefined) {
					offscreen_items.delete(key);
					items.set(key, pending);

					var next = prev ? prev.next : current;

					link$1(state, prev, pending);
					link$1(state, pending, next);

					move(pending, next, anchor);
					prev = pending;
				} else {
					var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

					prev = create_item(
						child_anchor,
						state,
						prev,
						prev === null ? state.first : prev.next,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
				}

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link$1(state, a.prev, b.next);
						link$1(state, prev, a);
						link$1(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link$1(state, item.prev, item.next);
						link$1(state, item, prev === null ? state.first : prev.next);
						link$1(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		each_effect.first = state.first && state.first.e;
		each_effect.last = prev && prev.e;

		for (var unused of offscreen_items.values()) {
			destroy_effect(unused.e);
		}

		offscreen_items.clear();
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node | null} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {boolean} [deferred]
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection,
		deferred
	) {
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (DEV && reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).trace = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		try {
			if (anchor === null) {
				var fragment = document.createDocumentFragment();
				fragment.append((anchor = create_text()));
			}

			item.e = branch(() => render_fn(/** @type {Node} */ (anchor), v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				if (!deferred) {
					state.first = item;
				}
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== null && node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link$1(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	/** @import { TemplateNode, Dom, Effect } from '#client' */
	/** @import { Batch } from '../../reactivity/batch.js'; */

	/**
	 * @template P
	 * @template {(props: P) => void} C
	 * @param {TemplateNode} node
	 * @param {() => C} get_component
	 * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn
	 * @returns {void}
	 */
	function component(node, get_component, render_fn) {

		var anchor = node;

		/** @type {C} */
		var component;

		/** @type {Effect | null} */
		var effect;

		/** @type {DocumentFragment | null} */
		var offscreen_fragment = null;

		/** @type {Effect | null} */
		var pending_effect = null;

		function commit() {
			if (effect) {
				pause_effect(effect);
				effect = null;
			}

			if (offscreen_fragment) {
				// remove the anchor
				/** @type {Text} */ (offscreen_fragment.lastChild).remove();

				anchor.before(offscreen_fragment);
				offscreen_fragment = null;
			}

			effect = pending_effect;
			pending_effect = null;
		}

		block(() => {
			if (component === (component = get_component())) return;

			var defer = should_defer_append();

			if (component) {
				var target = anchor;

				if (defer) {
					offscreen_fragment = document.createDocumentFragment();
					offscreen_fragment.append((target = create_text()));
					if (effect) {
						/** @type {Batch} */ (current_batch).skipped_effects.add(effect);
					}
				}
				pending_effect = branch(() => render_fn(target, component));
			}

			if (defer) {
				/** @type {Batch} */ (current_batch).add_callback(commit);
			} else {
				commit();
			}
		}, EFFECT_TRANSPARENT);
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {Comment | Element} node
	 * @param {() => string} get_tag
	 * @param {boolean} is_svg
	 * @param {undefined | ((element: Element, anchor: Node | null) => void)} render_fn,
	 * @param {undefined | (() => string)} get_namespace
	 * @param {undefined | [number, number]} location
	 * @returns {void}
	 */
	function element(node, get_tag, is_svg, render_fn, get_namespace, location) {

		var filename = DEV && location && component_context?.function[FILENAME];

		/** @type {string | null} */
		var tag;

		/** @type {string | null} */
		var current_tag;

		/** @type {null | Element} */
		var element = null;

		var anchor = /** @type {TemplateNode} */ (node);

		/** @type {Effect | null} */
		var effect;

		block(() => {
			const next_tag = get_tag() || null;
			var ns = get_namespace ? get_namespace() : is_svg || next_tag === 'svg' ? NAMESPACE_SVG : null;

			// Assumption: Noone changes the namespace but not the tag (what would that even mean?)
			if (next_tag === tag) return;

			if (effect) {
				if (next_tag === null) {
					// start outro
					pause_effect(effect, () => {
						effect = null;
						current_tag = null;
					});
				} else if (next_tag === current_tag) {
					// same tag as is currently rendered — abort outro
					resume_effect(effect);
				} else {
					// tag is changing — destroy immediately, render contents without intro transitions
					destroy_effect(effect);
				}
			}

			if (next_tag && next_tag !== current_tag) {
				effect = branch(() => {
					element = ns
							? document.createElementNS(ns, next_tag)
							: document.createElement(next_tag);

					if (DEV && location) {
						// @ts-expect-error
						element.__svelte_meta = {
							parent: dev_stack,
							loc: {
								file: filename,
								line: location[0],
								column: location[1]
							}
						};
					}

					assign_nodes(element, element);

					if (render_fn) {

						// If hydrating, use the existing ssr comment as the anchor so that the
						// inner open and close methods can pick up the existing nodes correctly
						var child_anchor = /** @type {TemplateNode} */ (
							element.appendChild(create_text())
						);

						// `child_anchor` is undefined if this is a void element, but we still
						// need to call `render_fn` in order to run actions etc. If the element
						// contains children, it's a user error (which is warned on elsewhere)
						// and the DOM will be silently discarded
						render_fn(element, child_anchor);
					}

					// we do this after calling `render_fn` so that child effects don't override `nodes.end`
					/** @type {Effect} */ (active_effect).nodes_end = element;

					anchor.before(element);
				});
			}

			tag = next_tag;
			if (tag) current_tag = tag;
		}, EFFECT_TRANSPARENT);
	}

	/** @import { Effect } from '#client' */

	// TODO in 6.0 or 7.0, when we remove legacy mode, we can simplify this by
	// getting rid of the block/branch stuff and just letting the effect rip.
	// see https://github.com/sveltejs/svelte/pull/15962

	/**
	 * @param {Element} node
	 * @param {() => (node: Element) => void} get_fn
	 */
	function attach(node, get_fn) {
		/** @type {false | undefined | ((node: Element) => void)} */
		var fn = undefined;

		/** @type {Effect | null} */
		var e;

		block(() => {
			if (fn !== (fn = get_fn())) {
				if (e) {
					destroy_effect(e);
					e = null;
				}

				if (fn) {
					e = branch(() => {
						effect(() => /** @type {(node: Element) => void} */ (fn)(node));
					});
				}
			}
		});
	}

	function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx$1(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

	/**
	 * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.
	 * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)
	 * @param  {any} value
	 */
	function clsx(value) {
		if (typeof value === 'object') {
			return clsx$1(value);
		} else {
			return value ?? '';
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 *
	 * @param {Record<string,any>} styles
	 * @param {boolean} important
	 */
	function append_styles(styles, important = false) {
		var separator = important ? ' !important;' : ';';
		var css = '';

		for (var key in styles) {
			var value = styles[key];
			if (value != null && value !== '') {
				css += ' ' + key + ': ' + value + separator;
			}
		}

		return css;
	}

	/**
	 * @param {string} name
	 * @returns {string}
	 */
	function to_css_name(name) {
		if (name[0] !== '-' || name[1] !== '-') {
			return name.toLowerCase();
		}
		return name;
	}

	/**
	 * @param {any} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]
	 * @returns {string | null}
	 */
	function to_style(value, styles) {
		if (styles) {
			var new_style = '';

			/** @type {Record<string,any> | undefined} */
			var normal_styles;

			/** @type {Record<string,any> | undefined} */
			var important_styles;

			if (Array.isArray(styles)) {
				normal_styles = styles[0];
				important_styles = styles[1];
			} else {
				normal_styles = styles;
			}

			if (value) {
				value = String(value)
					.replaceAll(/\s*\/\*.*?\*\/\s*/g, '')
					.trim();

				/** @type {boolean | '"' | "'"} */
				var in_str = false;
				var in_apo = 0;
				var in_comment = false;

				var reserved_names = [];

				if (normal_styles) {
					reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
				}
				if (important_styles) {
					reserved_names.push(...Object.keys(important_styles).map(to_css_name));
				}

				var start_index = 0;
				var name_index = -1;

				const len = value.length;
				for (var i = 0; i < len; i++) {
					var c = value[i];

					if (in_comment) {
						if (c === '/' && value[i - 1] === '*') {
							in_comment = false;
						}
					} else if (in_str) {
						if (in_str === c) {
							in_str = false;
						}
					} else if (c === '/' && value[i + 1] === '*') {
						in_comment = true;
					} else if (c === '"' || c === "'") {
						in_str = c;
					} else if (c === '(') {
						in_apo++;
					} else if (c === ')') {
						in_apo--;
					}

					if (!in_comment && in_str === false && in_apo === 0) {
						if (c === ':' && name_index === -1) {
							name_index = i;
						} else if (c === ';' || i === len - 1) {
							if (name_index !== -1) {
								var name = to_css_name(value.substring(start_index, name_index).trim());

								if (!reserved_names.includes(name)) {
									if (c !== ';') {
										i++;
									}

									var property = value.substring(start_index, i).trim();
									new_style += ' ' + property + ';';
								}
							}

							start_index = i + 1;
							name_index = -1;
						}
					}
				}
			}

			if (normal_styles) {
				new_style += append_styles(normal_styles);
			}

			if (important_styles) {
				new_style += append_styles(important_styles, true);
			}

			new_style = new_style.trim();
			return new_style === '' ? null : new_style;
		}

		return value == null ? null : String(value);
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			{
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {Record<string, any>} prev
	 * @param {Record<string, any>} next
	 * @param {string} [priority]
	 */
	function update_styles(dom, prev = {}, next, priority) {
		for (var key in next) {
			var value = next[key];

			if (prev[key] !== value) {
				if (next[key] == null) {
					dom.style.removeProperty(key);
				} else {
					dom.style.setProperty(key, value, priority);
				}
			}
		}
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} dom
	 * @param {string | null} value
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]
	 * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]
	 */
	function set_style(dom, value, prev_styles, next_styles) {
		// @ts-expect-error
		var prev = dom.__style;

		if (prev !== value) {
			var next_style_attr = to_style(value, next_styles);

			{
				if (next_style_attr == null) {
					dom.removeAttribute('style');
				} else {
					dom.style.cssText = next_style_attr;
				}
			}

			// @ts-expect-error
			dom.__style = value;
		} else if (next_styles) {
			if (Array.isArray(next_styles)) {
				update_styles(dom, prev_styles?.[0], next_styles[0]);
				update_styles(dom, prev_styles?.[1], next_styles[1], 'important');
			} else {
				update_styles(dom, prev_styles, next_styles);
			}
		}

		return next_styles;
	}

	/**
	 * Selects the correct option(s) (depending on whether this is a multiple select)
	 * @template V
	 * @param {HTMLSelectElement} select
	 * @param {V} value
	 * @param {boolean} mounting
	 */
	function select_option(select, value, mounting = false) {
		if (select.multiple) {
			// If value is null or undefined, keep the selection as is
			if (value == undefined) {
				return;
			}

			// If not an array, warn and keep the selection as is
			if (!is_array(value)) {
				return select_multiple_invalid_value();
			}

			// Otherwise, update the selection
			for (var option of select.options) {
				option.selected = value.includes(get_option_value(option));
			}

			return;
		}

		for (option of select.options) {
			var option_value = get_option_value(option);
			if (is(option_value, value)) {
				option.selected = true;
				return;
			}
		}

		if (!mounting || value !== undefined) {
			select.selectedIndex = -1; // no option should be selected
		}
	}

	/**
	 * Selects the correct option(s) if `value` is given,
	 * and then sets up a mutation observer to sync the
	 * current selection to the dom when it changes. Such
	 * changes could for example occur when options are
	 * inside an `#each` block.
	 * @param {HTMLSelectElement} select
	 */
	function init_select(select) {
		var observer = new MutationObserver(() => {
			// @ts-ignore
			select_option(select, select.__value);
			// Deliberately don't update the potential binding value,
			// the model should be preserved unless explicitly changed
		});

		observer.observe(select, {
			// Listen to option element changes
			childList: true,
			subtree: true, // because of <optgroup>
			// Listen to option element value attribute changes
			// (doesn't get notified of select value changes,
			// because that property is not reflected as an attribute)
			attributes: true,
			attributeFilter: ['value']
		});

		teardown(() => {
			observer.disconnect();
		});
	}

	/** @param {HTMLOptionElement} option */
	function get_option_value(option) {
		// __value only exists if the <option> has a value attribute
		if ('__value' in option) {
			return option.__value;
		} else {
			return option.value;
		}
	}

	/** @import { Effect } from '#client' */

	const CLASS = Symbol('class');
	const STYLE = Symbol('style');

	const IS_CUSTOM_ELEMENT = Symbol('is custom element');
	const IS_HTML = Symbol('is html');

	/**
	 * Sets the `selected` attribute on an `option` element.
	 * Not set through the property because that doesn't reflect to the DOM,
	 * which means it wouldn't be taken into account when a form is reset.
	 * @param {HTMLOptionElement} element
	 * @param {boolean} selected
	 */
	function set_selected(element, selected) {
		if (selected) {
			// The selected option could've changed via user selection, and
			// setting the value without this check would set it back.
			if (!element.hasAttribute('selected')) {
				element.setAttribute('selected', '');
			}
		} else {
			element.removeAttribute('selected');
		}
	}

	/**
	 * @param {Element} element
	 * @param {string} attribute
	 * @param {string | null} value
	 * @param {boolean} [skip_warning]
	 */
	function set_attribute(element, attribute, value, skip_warning) {
		var attributes = get_attributes(element);

		if (attributes[attribute] === (attributes[attribute] = value)) return;

		if (attribute === 'loading') {
			// @ts-expect-error
			element[LOADING_ATTR_SYMBOL] = value;
		}

		if (value == null) {
			element.removeAttribute(attribute);
		} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {
			// @ts-ignore
			element[attribute] = value;
		} else {
			element.setAttribute(attribute, value);
		}
	}

	/**
	 * Spreads attributes onto a DOM element, taking into account the currently set attributes
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {Record<string | symbol, any> | undefined} prev
	 * @param {Record<string | symbol, any>} next New attributes - this function mutates this object
	 * @param {string} [css_hash]
	 * @param {boolean} [should_remove_defaults]
	 * @param {boolean} [skip_warning]
	 * @returns {Record<string, any>}
	 */
	function set_attributes(
		element,
		prev,
		next,
		css_hash,
		should_remove_defaults = false,
		skip_warning = false
	) {

		var attributes = get_attributes(element);

		var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
		var preserve_attribute_case = !attributes[IS_HTML];

		var current = prev || {};
		var is_option_element = element.tagName === 'OPTION';

		for (var key in prev) {
			if (!(key in next)) {
				next[key] = null;
			}
		}

		if (next.class) {
			next.class = clsx(next.class);
		} else if (css_hash || next[CLASS]) {
			next.class = null; /* force call to set_class() */
		}

		if (next[STYLE]) {
			next.style ??= null; /* force call to set_style() */
		}

		var setters = get_setters(element);

		// since key is captured we use const
		for (const key in next) {
			// let instead of var because referenced in a closure
			let value = next[key];

			// Up here because we want to do this for the initial value, too, even if it's undefined,
			// and this wouldn't be reached in case of undefined because of the equality check below
			if (is_option_element && key === 'value' && value == null) {
				// The <option> element is a special case because removing the value attribute means
				// the value is set to the text content of the option element, and setting the value
				// to null or undefined means the value is set to the string "null" or "undefined".
				// To align with how we handle this case in non-spread-scenarios, this logic is needed.
				// There's a super-edge-case bug here that is left in in favor of smaller code size:
				// Because of the "set missing props to null" logic above, we can't differentiate
				// between a missing value and an explicitly set value of null or undefined. That means
				// that once set, the value attribute of an <option> element can't be removed. This is
				// a very rare edge case, and removing the attribute altogether isn't possible either
				// for the <option value={undefined}> case, so we're not losing any functionality here.
				// @ts-ignore
				element.value = element.__value = '';
				current[key] = value;
				continue;
			}

			if (key === 'class') {
				var is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';
				set_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);
				current[key] = value;
				current[CLASS] = next[CLASS];
				continue;
			}

			if (key === 'style') {
				set_style(element, value, prev?.[STYLE], next[STYLE]);
				current[key] = value;
				current[STYLE] = next[STYLE];
				continue;
			}

			var prev_value = current[key];

			// Skip if value is unchanged, unless it's `undefined` and the element still has the attribute
			if (value === prev_value && !(value === undefined && element.hasAttribute(key))) {
				continue;
			}

			current[key] = value;

			var prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)
			if (prefix === '$$') continue;

			if (prefix === 'on') {
				/** @type {{ capture?: true }} */
				const opts = {};
				const event_handle_key = '$$' + key;
				let event_name = key.slice(2);
				var delegated = is_delegated(event_name);

				if (is_capture_event(event_name)) {
					event_name = event_name.slice(0, -7);
					opts.capture = true;
				}

				if (!delegated && prev_value) {
					// Listening to same event but different handler -> our handle function below takes care of this
					// If we were to remove and add listeners in this case, it could happen that the event is "swallowed"
					// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler
					// https://github.com/sveltejs/svelte/issues/11903
					if (value != null) continue;

					element.removeEventListener(event_name, current[event_handle_key], opts);
					current[event_handle_key] = null;
				}

				if (value != null) {
					if (!delegated) {
						/**
						 * @this {any}
						 * @param {Event} evt
						 */
						function handle(evt) {
							current[key].call(this, evt);
						}

						current[event_handle_key] = create_event(event_name, element, handle, opts);
					} else {
						// @ts-ignore
						element[`__${event_name}`] = value;
						delegate([event_name]);
					}
				} else if (delegated) {
					// @ts-ignore
					element[`__${event_name}`] = undefined;
				}
			} else if (key === 'style') {
				// avoid using the setter
				set_attribute(element, key, value);
			} else if (key === 'autofocus') {
				autofocus(/** @type {HTMLElement} */ (element), Boolean(value));
			} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {
				// @ts-ignore We're not running this for custom elements because __value is actually
				// how Lit stores the current value on the element, and messing with that would break things.
				element.value = element.__value = value;
			} else if (key === 'selected' && is_option_element) {
				set_selected(/** @type {HTMLOptionElement} */ (element), value);
			} else {
				var name = key;
				if (!preserve_attribute_case) {
					name = normalize_attribute(name);
				}

				var is_default = name === 'defaultValue' || name === 'defaultChecked';

				if (value == null && !is_custom_element && !is_default) {
					attributes[key] = null;

					if (name === 'value' || name === 'checked') {
						// removing value/checked also removes defaultValue/defaultChecked — preserve
						let input = /** @type {HTMLInputElement} */ (element);
						const use_default = prev === undefined;
						if (name === 'value') {
							let previous = input.defaultValue;
							input.removeAttribute(name);
							input.defaultValue = previous;
							// @ts-ignore
							input.value = input.__value = use_default ? previous : null;
						} else {
							let previous = input.defaultChecked;
							input.removeAttribute(name);
							input.defaultChecked = previous;
							input.checked = use_default ? previous : false;
						}
					} else {
						element.removeAttribute(key);
					}
				} else if (
					is_default ||
					(setters.includes(name) && (is_custom_element || typeof value !== 'string'))
				) {
					// @ts-ignore
					element[name] = value;
					// remove it from attributes's cache
					if (name in attributes) attributes[name] = UNINITIALIZED;
				} else if (typeof value !== 'function') {
					set_attribute(element, name, value);
				}
			}
		}

		return current;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} element
	 * @param {(...expressions: any) => Record<string | symbol, any>} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {string} [css_hash]
	 * @param {boolean} [should_remove_defaults]
	 * @param {boolean} [skip_warning]
	 */
	function attribute_effect(
		element,
		fn,
		sync = [],
		async = [],
		css_hash,
		should_remove_defaults = false,
		skip_warning = false
	) {
		flatten(sync, async, (values) => {
			/** @type {Record<string | symbol, any> | undefined} */
			var prev = undefined;

			/** @type {Record<symbol, Effect>} */
			var effects = {};

			var is_select = element.nodeName === 'SELECT';
			var inited = false;

			block(() => {
				var next = fn(...values.map(get));
				/** @type {Record<string | symbol, any>} */
				var current = set_attributes(
					element,
					prev,
					next,
					css_hash,
					should_remove_defaults,
					skip_warning
				);

				if (inited && is_select && 'value' in next) {
					select_option(/** @type {HTMLSelectElement} */ (element), next.value);
				}

				for (let symbol of Object.getOwnPropertySymbols(effects)) {
					if (!next[symbol]) destroy_effect(effects[symbol]);
				}

				for (let symbol of Object.getOwnPropertySymbols(next)) {
					var n = next[symbol];

					if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
						if (effects[symbol]) destroy_effect(effects[symbol]);
						effects[symbol] = branch(() => attach(element, () => n));
					}

					current[symbol] = n;
				}

				prev = current;
			});

			if (is_select) {
				var select = /** @type {HTMLSelectElement} */ (element);

				effect(() => {
					select_option(select, /** @type {Record<string | symbol, any>} */ (prev).value, true);
					init_select(select);
				});
			}

			inited = true;
		});
	}

	/**
	 *
	 * @param {Element} element
	 */
	function get_attributes(element) {
		return /** @type {Record<string | symbol, unknown>} **/ (
			// @ts-expect-error
			element.__attributes ??= {
				[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),
				[IS_HTML]: element.namespaceURI === NAMESPACE_HTML
			}
		);
	}

	/** @type {Map<string, string[]>} */
	var setters_cache = new Map();

	/** @param {Element} element */
	function get_setters(element) {
		var cache_key = element.getAttribute('is') || element.nodeName;
		var setters = setters_cache.get(cache_key);
		if (setters) return setters;
		setters_cache.set(cache_key, (setters = []));

		var descriptors;
		var proto = element; // In the case of custom elements there might be setters on the instance
		var element_proto = Element.prototype;

		// Stop at Element, from there on there's only unnecessary setters we're not interested in
		// Do not use contructor.name here as that's unreliable in some browser environments
		while (element_proto !== proto) {
			descriptors = get_descriptors(proto);

			for (var key in descriptors) {
				if (descriptors[key].set) {
					setters.push(key);
				}
			}

			proto = get_prototype_of(proto);
		}

		return setters;
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get(signal);
		}

		props();
	}

	/** @import { StoreReferencesContainer } from '#client' */
	/** @import { Store } from '#shared' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Effect, Source } from './types.js' */

	/**
	 * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).
	 * Is passed the full `$$props` object and excludes the named props.
	 * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}
	 */
	const rest_props_handler = {
		get(target, key) {
			if (target.exclude.includes(key)) return;
			return target.props[key];
		},
		set(target, key) {
			if (DEV) {
				// TODO should this happen in prod too?
				props_rest_readonly(`${target.name}.${String(key)}`);
			}

			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			if (target.exclude.includes(key)) return;
			if (key in target.props) {
				return {
					enumerable: true,
					configurable: true,
					value: target.props[key]
				};
			}
		},
		has(target, key) {
			if (target.exclude.includes(key)) return false;
			return key in target.props;
		},
		ownKeys(target) {
			return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
		}
	};

	/**
	 * @param {Record<string, unknown>} props
	 * @param {string[]} exclude
	 * @param {string} [name]
	 * @returns {Record<string, unknown>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function rest_props(props, exclude, name) {
		return new Proxy(
			DEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
			rest_props_handler
		);
	}

	/**
	 * The proxy handler for spread props. Handles the incoming array of props
	 * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps
	 * them so that the whole thing is passed to the component as the `$$props` argument.
	 * @type {ProxyHandler<{ props: Array<Record<string | symbol, unknown> | (() => Record<string | symbol, unknown>)> }>}}
	 */
	const spread_props_handler = {
		get(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) return p[key];
			}
		},
		set(target, key, value) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				const desc = get_descriptor(p, key);
				if (desc && desc.set) {
					desc.set(value);
					return true;
				}
			}
			return false;
		},
		getOwnPropertyDescriptor(target, key) {
			let i = target.props.length;
			while (i--) {
				let p = target.props[i];
				if (is_function(p)) p = p();
				if (typeof p === 'object' && p !== null && key in p) {
					const descriptor = get_descriptor(p, key);
					if (descriptor && !descriptor.configurable) {
						// Prevent a "Non-configurability Report Error": The target is an array, it does
						// not actually contain this property. If it is now described as non-configurable,
						// the proxy throws a validation error. Setting it to true avoids that.
						descriptor.configurable = true;
					}
					return descriptor;
				}
			}
		},
		has(target, key) {
			// To prevent a false positive `is_entry_props` in the `prop` function
			if (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (p != null && key in p) return true;
			}

			return false;
		},
		ownKeys(target) {
			/** @type {Array<string | symbol>} */
			const keys = [];

			for (let p of target.props) {
				if (is_function(p)) p = p();
				if (!p) continue;

				for (const key in p) {
					if (!keys.includes(key)) keys.push(key);
				}

				for (const key of Object.getOwnPropertySymbols(p)) {
					if (!keys.includes(key)) keys.push(key);
				}
			}

			return keys;
		}
	};

	/**
	 * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props
	 * @returns {any}
	 */
	function spread_props(...props) {
		return new Proxy({ props }, spread_props_handler);
	}

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;

		var get_fallback = () => {
			if (fallback_dirty) {
				fallback_dirty = false;

				fallback_value = lazy
					? untrack(/** @type {() => V} */ (fallback))
					: /** @type {V} */ (fallback);
			}

			return fallback_value;
		};

		/** @type {((v: V) => void) | undefined} */
		var setter;

		if (bindable) {
			// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
			// or `createClassComponent(Component, props)`
			var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

			setter =
				get_descriptor(props, key)?.set ??
				(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);
		}

		var initial_value;
		var is_store_sub = false;

		if (bindable) {
			[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			initial_value = /** @type {V} */ (props[key]);
		}

		if (initial_value === undefined && fallback !== undefined) {
			initial_value = get_fallback();

			if (setter) {
				if (runes) props_invalid_value(key);
				setter(initial_value);
			}
		}

		/** @type {() => V} */
		var getter;

		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				return value;
			};
		} else {
			getter = () => {
				var value = /** @type {V} */ (props[key]);

				if (value !== undefined) {
					// in legacy mode, we don't revert to the fallback value
					// if the prop goes from defined to undefined. The easiest
					// way to model this is to make the fallback undefined
					// as soon as the prop has a value
					fallback_value = /** @type {V} */ (undefined);
				}

				return value === undefined ? fallback_value : value;
			};
		}

		// prop is never written to — we only need a getter
		if (runes && (flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// prop is written to, but the parent component had `bind:foo` which
		// means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return /** @type {() => V} */ (
				function (/** @type {V} */ value, /** @type {boolean} */ mutation) {
					if (arguments.length > 0) {
						// We don't want to notify if the value was mutated and the parent is in runes mode.
						// In that case the state proxy (if it exists) should take care of the notification.
						// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
						// has changed because the parent will not be able to detect the change otherwise.
						if (!runes || !mutation || legacy_parent || is_store_sub) {
							/** @type {Function} */ (setter)(mutation ? getter() : value);
						}

						return value;
					}

					return getter();
				}
			);
		}

		// Either prop is written to, but there's no binding, which means we
		// create a derived that we can write to locally.
		// Or we are in legacy mode where we always create a derived to replicate that
		// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
		var overridden = false;

		var d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
			overridden = false;
			return getter();
		});

		if (DEV) {
			d.label = key;
		}

		// Capture the initial value if it's bindable
		if (bindable) get(d);

		var parent_effect = /** @type {Effect} */ (active_effect);

		return /** @type {() => V} */ (
			function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;

					set(d, new_value);
					overridden = true;

					if (fallback_value !== undefined) {
						fallback_value = new_value;
					}

					return value;
				}

				// special case — avoid recalculating the derived if we're in a
				// teardown function and the prop was overridden locally, or the
				// component was already destroyed (this latter part is necessary
				// because `bind:this` can read props after the component has
				// been destroyed. TODO simplify `bind:this`
				if ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {
					return d.v;
				}

				return get(d);
			}
		);
	}

	enable_legacy_mode_flag();

	PageSidebar[FILENAME] = 'src/components/PageSidebar.svelte';

	var root_1$3 = add_locations(from_html(`<button><span class="page-title svelte-1uuse31"> </span> <span class="page-info svelte-1uuse31"> </span></button>`), PageSidebar[FILENAME], [[9, 4, [[14, 6], [15, 6]]]]);
	var root$4 = add_locations(from_html(`<div class="page-list svelte-1uuse31"><h3 class="svelte-1uuse31">Pages</h3> <!></div>`), PageSidebar[FILENAME], [[6, 0, [[7, 2]]]]);

	function PageSidebar($$anchor, $$props) {
		check_target(new.target);
		push$1($$props, false, PageSidebar);

		let pages = prop($$props, 'pages', 24, () => []);
		let selectedIndex = prop($$props, 'selectedIndex', 12, 0);
		var $$exports = { ...legacy_api() };
		var div = root$4();
		var node = sibling(child(div), 2);

		add_svelte_meta(
			() => each(node, 1, pages, index$1, ($$anchor, page, i) => {
				var button = root_1$3();
				let classes;
				var span = child(button);
				var text = child(span, true);

				reset(span);

				var span_1 = sibling(span, 2);
				var text_1 = child(span_1);

				reset(span_1);
				reset(button);

				template_effect(
					($0) => {
						classes = set_class(button, 1, 'page-item svelte-1uuse31', null, classes, $0);
						set_text(text, (get(page), untrack(() => get(page).title)));
						set_text(text_1, `${(get(page), untrack(() => get(page).text_length)) ?? ''} chars`);
					},
					[() => ({ selected: strict_equals(selectedIndex(), i) })]
				);

				event('click', button, () => selectedIndex(i));
				append($$anchor, button);
			}),
			'each',
			PageSidebar,
			8,
			2
		);
		append($$anchor, div);

		return pop($$exports);
	}

	/**
	 * Generate a color for a chunk based on its index
	 * Uses a categorical color palette that cycles every 12 colors
	 */

	const CHUNK_COLORS = [
	  '#e91e63', // Pink
	  '#9c27b0', // Purple
	  '#673ab7', // Deep Purple
	  '#3f51b5', // Indigo
	  '#2196f3', // Blue
	  '#03a9f4', // Light Blue
	  '#00bcd4', // Cyan
	  '#009688', // Teal
	  '#4caf50', // Green
	  '#8bc34a', // Light Green
	  '#ff9800', // Orange
	  '#ff5722', // Deep Orange
	];

	function getChunkColor(index) {
	  return CHUNK_COLORS[index % CHUNK_COLORS.length];
	}

	/* contexts.svelte.js generated by Svelte v5.39.3 */

	const ref = (value) => {
		let inner = tag(state(proxy(value)), 'inner');

		return {
			get current() {
				return get(inner);
			},

			set current(newVal) {
				set(inner, newVal, true);
			}
		};
	};

	const componentsContextKey = 'components';

	const getComponentsMap = () => getContext(componentsContextKey);
	const setComponentsContext = (value) => setContext(componentsContextKey, value);

	const astContextKey = 'ast';
	const setAstContext = (value) => setContext(astContextKey, value);

	var __create = Object.create;
	var __defProp = Object.defineProperty;
	var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
	var __getOwnPropNames = Object.getOwnPropertyNames;
	var __getProtoOf = Object.getPrototypeOf;
	var __hasOwnProp = Object.prototype.hasOwnProperty;
	var __commonJS = (cb, mod) => function __require() {
	  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
	};
	var __export = (target, all2) => {
	  for (var name in all2)
	    __defProp(target, name, { get: all2[name], enumerable: true });
	};
	var __copyProps = (to, from, except, desc) => {
	  if (from && typeof from === "object" || typeof from === "function") {
	    for (let key of __getOwnPropNames(from))
	      if (!__hasOwnProp.call(to, key) && key !== except)
	        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
	  }
	  return to;
	};
	var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
	  // If the importer is in node compatibility mode or this is not an ESM
	  // file that has been converted to a CommonJS file using a Babel-
	  // compatible transform (i.e. "__esModule" has not been set), then set
	  // "default" to the CommonJS "module.exports" for node compatibility.
	  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
	  mod
	));

	// node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js
	var require_extend = __commonJS({
	  "node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js"(exports, module) {
	    var hasOwn = Object.prototype.hasOwnProperty;
	    var toStr = Object.prototype.toString;
	    var defineProperty = Object.defineProperty;
	    var gOPD = Object.getOwnPropertyDescriptor;
	    var isArray = function isArray2(arr) {
	      if (typeof Array.isArray === "function") {
	        return Array.isArray(arr);
	      }
	      return toStr.call(arr) === "[object Array]";
	    };
	    var isPlainObject2 = function isPlainObject3(obj) {
	      if (!obj || toStr.call(obj) !== "[object Object]") {
	        return false;
	      }
	      var hasOwnConstructor = hasOwn.call(obj, "constructor");
	      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
	      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
	        return false;
	      }
	      var key;
	      for (key in obj) {
	      }
	      return typeof key === "undefined" || hasOwn.call(obj, key);
	    };
	    var setProperty = function setProperty2(target, options) {
	      if (defineProperty && options.name === "__proto__") {
	        defineProperty(target, options.name, {
	          enumerable: true,
	          configurable: true,
	          value: options.newValue,
	          writable: true
	        });
	      } else {
	        target[options.name] = options.newValue;
	      }
	    };
	    var getProperty = function getProperty2(obj, name) {
	      if (name === "__proto__") {
	        if (!hasOwn.call(obj, name)) {
	          return void 0;
	        } else if (gOPD) {
	          return gOPD(obj, name).value;
	        }
	      }
	      return obj[name];
	    };
	    module.exports = function extend2() {
	      var options, name, src, copy, copyIsArray, clone;
	      var target = arguments[0];
	      var i = 1;
	      var length = arguments.length;
	      var deep = false;
	      if (typeof target === "boolean") {
	        deep = target;
	        target = arguments[1] || {};
	        i = 2;
	      }
	      if (target == null || typeof target !== "object" && typeof target !== "function") {
	        target = {};
	      }
	      for (; i < length; ++i) {
	        options = arguments[i];
	        if (options != null) {
	          for (name in options) {
	            src = getProperty(target, name);
	            copy = getProperty(options, name);
	            if (target !== copy) {
	              if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
	                if (copyIsArray) {
	                  copyIsArray = false;
	                  clone = src && isArray(src) ? src : [];
	                } else {
	                  clone = src && isPlainObject2(src) ? src : {};
	                }
	                setProperty(target, { name, newValue: extend2(deep, clone, copy) });
	              } else if (typeof copy !== "undefined") {
	                setProperty(target, { name, newValue: copy });
	              }
	            }
	          }
	        }
	      }
	      return target;
	    };
	  }
	});

	// node_modules/.pnpm/mdast-util-to-string@4.0.0/node_modules/mdast-util-to-string/lib/index.js
	var emptyOptions = {};
	function toString(value, options) {
	  const settings = options || emptyOptions;
	  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
	  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
	  return one(value, includeImageAlt, includeHtml);
	}
	function one(value, includeImageAlt, includeHtml) {
	  if (node(value)) {
	    if ("value" in value) {
	      return value.type === "html" && !includeHtml ? "" : value.value;
	    }
	    if (includeImageAlt && "alt" in value && value.alt) {
	      return value.alt;
	    }
	    if ("children" in value) {
	      return all(value.children, includeImageAlt, includeHtml);
	    }
	  }
	  if (Array.isArray(value)) {
	    return all(value, includeImageAlt, includeHtml);
	  }
	  return "";
	}
	function all(values, includeImageAlt, includeHtml) {
	  const result = [];
	  let index2 = -1;
	  while (++index2 < values.length) {
	    result[index2] = one(values[index2], includeImageAlt, includeHtml);
	  }
	  return result.join("");
	}
	function node(value) {
	  return Boolean(value && typeof value === "object");
	}

	// node_modules/.pnpm/character-entities@2.0.2/node_modules/character-entities/index.js
	var characterEntities = {
	  AElig: "\xC6",
	  AMP: "&",
	  Aacute: "\xC1",
	  Abreve: "\u0102",
	  Acirc: "\xC2",
	  Acy: "\u0410",
	  Afr: "\u{1D504}",
	  Agrave: "\xC0",
	  Alpha: "\u0391",
	  Amacr: "\u0100",
	  And: "\u2A53",
	  Aogon: "\u0104",
	  Aopf: "\u{1D538}",
	  ApplyFunction: "\u2061",
	  Aring: "\xC5",
	  Ascr: "\u{1D49C}",
	  Assign: "\u2254",
	  Atilde: "\xC3",
	  Auml: "\xC4",
	  Backslash: "\u2216",
	  Barv: "\u2AE7",
	  Barwed: "\u2306",
	  Bcy: "\u0411",
	  Because: "\u2235",
	  Bernoullis: "\u212C",
	  Beta: "\u0392",
	  Bfr: "\u{1D505}",
	  Bopf: "\u{1D539}",
	  Breve: "\u02D8",
	  Bscr: "\u212C",
	  Bumpeq: "\u224E",
	  CHcy: "\u0427",
	  COPY: "\xA9",
	  Cacute: "\u0106",
	  Cap: "\u22D2",
	  CapitalDifferentialD: "\u2145",
	  Cayleys: "\u212D",
	  Ccaron: "\u010C",
	  Ccedil: "\xC7",
	  Ccirc: "\u0108",
	  Cconint: "\u2230",
	  Cdot: "\u010A",
	  Cedilla: "\xB8",
	  CenterDot: "\xB7",
	  Cfr: "\u212D",
	  Chi: "\u03A7",
	  CircleDot: "\u2299",
	  CircleMinus: "\u2296",
	  CirclePlus: "\u2295",
	  CircleTimes: "\u2297",
	  ClockwiseContourIntegral: "\u2232",
	  CloseCurlyDoubleQuote: "\u201D",
	  CloseCurlyQuote: "\u2019",
	  Colon: "\u2237",
	  Colone: "\u2A74",
	  Congruent: "\u2261",
	  Conint: "\u222F",
	  ContourIntegral: "\u222E",
	  Copf: "\u2102",
	  Coproduct: "\u2210",
	  CounterClockwiseContourIntegral: "\u2233",
	  Cross: "\u2A2F",
	  Cscr: "\u{1D49E}",
	  Cup: "\u22D3",
	  CupCap: "\u224D",
	  DD: "\u2145",
	  DDotrahd: "\u2911",
	  DJcy: "\u0402",
	  DScy: "\u0405",
	  DZcy: "\u040F",
	  Dagger: "\u2021",
	  Darr: "\u21A1",
	  Dashv: "\u2AE4",
	  Dcaron: "\u010E",
	  Dcy: "\u0414",
	  Del: "\u2207",
	  Delta: "\u0394",
	  Dfr: "\u{1D507}",
	  DiacriticalAcute: "\xB4",
	  DiacriticalDot: "\u02D9",
	  DiacriticalDoubleAcute: "\u02DD",
	  DiacriticalGrave: "`",
	  DiacriticalTilde: "\u02DC",
	  Diamond: "\u22C4",
	  DifferentialD: "\u2146",
	  Dopf: "\u{1D53B}",
	  Dot: "\xA8",
	  DotDot: "\u20DC",
	  DotEqual: "\u2250",
	  DoubleContourIntegral: "\u222F",
	  DoubleDot: "\xA8",
	  DoubleDownArrow: "\u21D3",
	  DoubleLeftArrow: "\u21D0",
	  DoubleLeftRightArrow: "\u21D4",
	  DoubleLeftTee: "\u2AE4",
	  DoubleLongLeftArrow: "\u27F8",
	  DoubleLongLeftRightArrow: "\u27FA",
	  DoubleLongRightArrow: "\u27F9",
	  DoubleRightArrow: "\u21D2",
	  DoubleRightTee: "\u22A8",
	  DoubleUpArrow: "\u21D1",
	  DoubleUpDownArrow: "\u21D5",
	  DoubleVerticalBar: "\u2225",
	  DownArrow: "\u2193",
	  DownArrowBar: "\u2913",
	  DownArrowUpArrow: "\u21F5",
	  DownBreve: "\u0311",
	  DownLeftRightVector: "\u2950",
	  DownLeftTeeVector: "\u295E",
	  DownLeftVector: "\u21BD",
	  DownLeftVectorBar: "\u2956",
	  DownRightTeeVector: "\u295F",
	  DownRightVector: "\u21C1",
	  DownRightVectorBar: "\u2957",
	  DownTee: "\u22A4",
	  DownTeeArrow: "\u21A7",
	  Downarrow: "\u21D3",
	  Dscr: "\u{1D49F}",
	  Dstrok: "\u0110",
	  ENG: "\u014A",
	  ETH: "\xD0",
	  Eacute: "\xC9",
	  Ecaron: "\u011A",
	  Ecirc: "\xCA",
	  Ecy: "\u042D",
	  Edot: "\u0116",
	  Efr: "\u{1D508}",
	  Egrave: "\xC8",
	  Element: "\u2208",
	  Emacr: "\u0112",
	  EmptySmallSquare: "\u25FB",
	  EmptyVerySmallSquare: "\u25AB",
	  Eogon: "\u0118",
	  Eopf: "\u{1D53C}",
	  Epsilon: "\u0395",
	  Equal: "\u2A75",
	  EqualTilde: "\u2242",
	  Equilibrium: "\u21CC",
	  Escr: "\u2130",
	  Esim: "\u2A73",
	  Eta: "\u0397",
	  Euml: "\xCB",
	  Exists: "\u2203",
	  ExponentialE: "\u2147",
	  Fcy: "\u0424",
	  Ffr: "\u{1D509}",
	  FilledSmallSquare: "\u25FC",
	  FilledVerySmallSquare: "\u25AA",
	  Fopf: "\u{1D53D}",
	  ForAll: "\u2200",
	  Fouriertrf: "\u2131",
	  Fscr: "\u2131",
	  GJcy: "\u0403",
	  GT: ">",
	  Gamma: "\u0393",
	  Gammad: "\u03DC",
	  Gbreve: "\u011E",
	  Gcedil: "\u0122",
	  Gcirc: "\u011C",
	  Gcy: "\u0413",
	  Gdot: "\u0120",
	  Gfr: "\u{1D50A}",
	  Gg: "\u22D9",
	  Gopf: "\u{1D53E}",
	  GreaterEqual: "\u2265",
	  GreaterEqualLess: "\u22DB",
	  GreaterFullEqual: "\u2267",
	  GreaterGreater: "\u2AA2",
	  GreaterLess: "\u2277",
	  GreaterSlantEqual: "\u2A7E",
	  GreaterTilde: "\u2273",
	  Gscr: "\u{1D4A2}",
	  Gt: "\u226B",
	  HARDcy: "\u042A",
	  Hacek: "\u02C7",
	  Hat: "^",
	  Hcirc: "\u0124",
	  Hfr: "\u210C",
	  HilbertSpace: "\u210B",
	  Hopf: "\u210D",
	  HorizontalLine: "\u2500",
	  Hscr: "\u210B",
	  Hstrok: "\u0126",
	  HumpDownHump: "\u224E",
	  HumpEqual: "\u224F",
	  IEcy: "\u0415",
	  IJlig: "\u0132",
	  IOcy: "\u0401",
	  Iacute: "\xCD",
	  Icirc: "\xCE",
	  Icy: "\u0418",
	  Idot: "\u0130",
	  Ifr: "\u2111",
	  Igrave: "\xCC",
	  Im: "\u2111",
	  Imacr: "\u012A",
	  ImaginaryI: "\u2148",
	  Implies: "\u21D2",
	  Int: "\u222C",
	  Integral: "\u222B",
	  Intersection: "\u22C2",
	  InvisibleComma: "\u2063",
	  InvisibleTimes: "\u2062",
	  Iogon: "\u012E",
	  Iopf: "\u{1D540}",
	  Iota: "\u0399",
	  Iscr: "\u2110",
	  Itilde: "\u0128",
	  Iukcy: "\u0406",
	  Iuml: "\xCF",
	  Jcirc: "\u0134",
	  Jcy: "\u0419",
	  Jfr: "\u{1D50D}",
	  Jopf: "\u{1D541}",
	  Jscr: "\u{1D4A5}",
	  Jsercy: "\u0408",
	  Jukcy: "\u0404",
	  KHcy: "\u0425",
	  KJcy: "\u040C",
	  Kappa: "\u039A",
	  Kcedil: "\u0136",
	  Kcy: "\u041A",
	  Kfr: "\u{1D50E}",
	  Kopf: "\u{1D542}",
	  Kscr: "\u{1D4A6}",
	  LJcy: "\u0409",
	  LT: "<",
	  Lacute: "\u0139",
	  Lambda: "\u039B",
	  Lang: "\u27EA",
	  Laplacetrf: "\u2112",
	  Larr: "\u219E",
	  Lcaron: "\u013D",
	  Lcedil: "\u013B",
	  Lcy: "\u041B",
	  LeftAngleBracket: "\u27E8",
	  LeftArrow: "\u2190",
	  LeftArrowBar: "\u21E4",
	  LeftArrowRightArrow: "\u21C6",
	  LeftCeiling: "\u2308",
	  LeftDoubleBracket: "\u27E6",
	  LeftDownTeeVector: "\u2961",
	  LeftDownVector: "\u21C3",
	  LeftDownVectorBar: "\u2959",
	  LeftFloor: "\u230A",
	  LeftRightArrow: "\u2194",
	  LeftRightVector: "\u294E",
	  LeftTee: "\u22A3",
	  LeftTeeArrow: "\u21A4",
	  LeftTeeVector: "\u295A",
	  LeftTriangle: "\u22B2",
	  LeftTriangleBar: "\u29CF",
	  LeftTriangleEqual: "\u22B4",
	  LeftUpDownVector: "\u2951",
	  LeftUpTeeVector: "\u2960",
	  LeftUpVector: "\u21BF",
	  LeftUpVectorBar: "\u2958",
	  LeftVector: "\u21BC",
	  LeftVectorBar: "\u2952",
	  Leftarrow: "\u21D0",
	  Leftrightarrow: "\u21D4",
	  LessEqualGreater: "\u22DA",
	  LessFullEqual: "\u2266",
	  LessGreater: "\u2276",
	  LessLess: "\u2AA1",
	  LessSlantEqual: "\u2A7D",
	  LessTilde: "\u2272",
	  Lfr: "\u{1D50F}",
	  Ll: "\u22D8",
	  Lleftarrow: "\u21DA",
	  Lmidot: "\u013F",
	  LongLeftArrow: "\u27F5",
	  LongLeftRightArrow: "\u27F7",
	  LongRightArrow: "\u27F6",
	  Longleftarrow: "\u27F8",
	  Longleftrightarrow: "\u27FA",
	  Longrightarrow: "\u27F9",
	  Lopf: "\u{1D543}",
	  LowerLeftArrow: "\u2199",
	  LowerRightArrow: "\u2198",
	  Lscr: "\u2112",
	  Lsh: "\u21B0",
	  Lstrok: "\u0141",
	  Lt: "\u226A",
	  Map: "\u2905",
	  Mcy: "\u041C",
	  MediumSpace: "\u205F",
	  Mellintrf: "\u2133",
	  Mfr: "\u{1D510}",
	  MinusPlus: "\u2213",
	  Mopf: "\u{1D544}",
	  Mscr: "\u2133",
	  Mu: "\u039C",
	  NJcy: "\u040A",
	  Nacute: "\u0143",
	  Ncaron: "\u0147",
	  Ncedil: "\u0145",
	  Ncy: "\u041D",
	  NegativeMediumSpace: "\u200B",
	  NegativeThickSpace: "\u200B",
	  NegativeThinSpace: "\u200B",
	  NegativeVeryThinSpace: "\u200B",
	  NestedGreaterGreater: "\u226B",
	  NestedLessLess: "\u226A",
	  NewLine: "\n",
	  Nfr: "\u{1D511}",
	  NoBreak: "\u2060",
	  NonBreakingSpace: "\xA0",
	  Nopf: "\u2115",
	  Not: "\u2AEC",
	  NotCongruent: "\u2262",
	  NotCupCap: "\u226D",
	  NotDoubleVerticalBar: "\u2226",
	  NotElement: "\u2209",
	  NotEqual: "\u2260",
	  NotEqualTilde: "\u2242\u0338",
	  NotExists: "\u2204",
	  NotGreater: "\u226F",
	  NotGreaterEqual: "\u2271",
	  NotGreaterFullEqual: "\u2267\u0338",
	  NotGreaterGreater: "\u226B\u0338",
	  NotGreaterLess: "\u2279",
	  NotGreaterSlantEqual: "\u2A7E\u0338",
	  NotGreaterTilde: "\u2275",
	  NotHumpDownHump: "\u224E\u0338",
	  NotHumpEqual: "\u224F\u0338",
	  NotLeftTriangle: "\u22EA",
	  NotLeftTriangleBar: "\u29CF\u0338",
	  NotLeftTriangleEqual: "\u22EC",
	  NotLess: "\u226E",
	  NotLessEqual: "\u2270",
	  NotLessGreater: "\u2278",
	  NotLessLess: "\u226A\u0338",
	  NotLessSlantEqual: "\u2A7D\u0338",
	  NotLessTilde: "\u2274",
	  NotNestedGreaterGreater: "\u2AA2\u0338",
	  NotNestedLessLess: "\u2AA1\u0338",
	  NotPrecedes: "\u2280",
	  NotPrecedesEqual: "\u2AAF\u0338",
	  NotPrecedesSlantEqual: "\u22E0",
	  NotReverseElement: "\u220C",
	  NotRightTriangle: "\u22EB",
	  NotRightTriangleBar: "\u29D0\u0338",
	  NotRightTriangleEqual: "\u22ED",
	  NotSquareSubset: "\u228F\u0338",
	  NotSquareSubsetEqual: "\u22E2",
	  NotSquareSuperset: "\u2290\u0338",
	  NotSquareSupersetEqual: "\u22E3",
	  NotSubset: "\u2282\u20D2",
	  NotSubsetEqual: "\u2288",
	  NotSucceeds: "\u2281",
	  NotSucceedsEqual: "\u2AB0\u0338",
	  NotSucceedsSlantEqual: "\u22E1",
	  NotSucceedsTilde: "\u227F\u0338",
	  NotSuperset: "\u2283\u20D2",
	  NotSupersetEqual: "\u2289",
	  NotTilde: "\u2241",
	  NotTildeEqual: "\u2244",
	  NotTildeFullEqual: "\u2247",
	  NotTildeTilde: "\u2249",
	  NotVerticalBar: "\u2224",
	  Nscr: "\u{1D4A9}",
	  Ntilde: "\xD1",
	  Nu: "\u039D",
	  OElig: "\u0152",
	  Oacute: "\xD3",
	  Ocirc: "\xD4",
	  Ocy: "\u041E",
	  Odblac: "\u0150",
	  Ofr: "\u{1D512}",
	  Ograve: "\xD2",
	  Omacr: "\u014C",
	  Omega: "\u03A9",
	  Omicron: "\u039F",
	  Oopf: "\u{1D546}",
	  OpenCurlyDoubleQuote: "\u201C",
	  OpenCurlyQuote: "\u2018",
	  Or: "\u2A54",
	  Oscr: "\u{1D4AA}",
	  Oslash: "\xD8",
	  Otilde: "\xD5",
	  Otimes: "\u2A37",
	  Ouml: "\xD6",
	  OverBar: "\u203E",
	  OverBrace: "\u23DE",
	  OverBracket: "\u23B4",
	  OverParenthesis: "\u23DC",
	  PartialD: "\u2202",
	  Pcy: "\u041F",
	  Pfr: "\u{1D513}",
	  Phi: "\u03A6",
	  Pi: "\u03A0",
	  PlusMinus: "\xB1",
	  Poincareplane: "\u210C",
	  Popf: "\u2119",
	  Pr: "\u2ABB",
	  Precedes: "\u227A",
	  PrecedesEqual: "\u2AAF",
	  PrecedesSlantEqual: "\u227C",
	  PrecedesTilde: "\u227E",
	  Prime: "\u2033",
	  Product: "\u220F",
	  Proportion: "\u2237",
	  Proportional: "\u221D",
	  Pscr: "\u{1D4AB}",
	  Psi: "\u03A8",
	  QUOT: '"',
	  Qfr: "\u{1D514}",
	  Qopf: "\u211A",
	  Qscr: "\u{1D4AC}",
	  RBarr: "\u2910",
	  REG: "\xAE",
	  Racute: "\u0154",
	  Rang: "\u27EB",
	  Rarr: "\u21A0",
	  Rarrtl: "\u2916",
	  Rcaron: "\u0158",
	  Rcedil: "\u0156",
	  Rcy: "\u0420",
	  Re: "\u211C",
	  ReverseElement: "\u220B",
	  ReverseEquilibrium: "\u21CB",
	  ReverseUpEquilibrium: "\u296F",
	  Rfr: "\u211C",
	  Rho: "\u03A1",
	  RightAngleBracket: "\u27E9",
	  RightArrow: "\u2192",
	  RightArrowBar: "\u21E5",
	  RightArrowLeftArrow: "\u21C4",
	  RightCeiling: "\u2309",
	  RightDoubleBracket: "\u27E7",
	  RightDownTeeVector: "\u295D",
	  RightDownVector: "\u21C2",
	  RightDownVectorBar: "\u2955",
	  RightFloor: "\u230B",
	  RightTee: "\u22A2",
	  RightTeeArrow: "\u21A6",
	  RightTeeVector: "\u295B",
	  RightTriangle: "\u22B3",
	  RightTriangleBar: "\u29D0",
	  RightTriangleEqual: "\u22B5",
	  RightUpDownVector: "\u294F",
	  RightUpTeeVector: "\u295C",
	  RightUpVector: "\u21BE",
	  RightUpVectorBar: "\u2954",
	  RightVector: "\u21C0",
	  RightVectorBar: "\u2953",
	  Rightarrow: "\u21D2",
	  Ropf: "\u211D",
	  RoundImplies: "\u2970",
	  Rrightarrow: "\u21DB",
	  Rscr: "\u211B",
	  Rsh: "\u21B1",
	  RuleDelayed: "\u29F4",
	  SHCHcy: "\u0429",
	  SHcy: "\u0428",
	  SOFTcy: "\u042C",
	  Sacute: "\u015A",
	  Sc: "\u2ABC",
	  Scaron: "\u0160",
	  Scedil: "\u015E",
	  Scirc: "\u015C",
	  Scy: "\u0421",
	  Sfr: "\u{1D516}",
	  ShortDownArrow: "\u2193",
	  ShortLeftArrow: "\u2190",
	  ShortRightArrow: "\u2192",
	  ShortUpArrow: "\u2191",
	  Sigma: "\u03A3",
	  SmallCircle: "\u2218",
	  Sopf: "\u{1D54A}",
	  Sqrt: "\u221A",
	  Square: "\u25A1",
	  SquareIntersection: "\u2293",
	  SquareSubset: "\u228F",
	  SquareSubsetEqual: "\u2291",
	  SquareSuperset: "\u2290",
	  SquareSupersetEqual: "\u2292",
	  SquareUnion: "\u2294",
	  Sscr: "\u{1D4AE}",
	  Star: "\u22C6",
	  Sub: "\u22D0",
	  Subset: "\u22D0",
	  SubsetEqual: "\u2286",
	  Succeeds: "\u227B",
	  SucceedsEqual: "\u2AB0",
	  SucceedsSlantEqual: "\u227D",
	  SucceedsTilde: "\u227F",
	  SuchThat: "\u220B",
	  Sum: "\u2211",
	  Sup: "\u22D1",
	  Superset: "\u2283",
	  SupersetEqual: "\u2287",
	  Supset: "\u22D1",
	  THORN: "\xDE",
	  TRADE: "\u2122",
	  TSHcy: "\u040B",
	  TScy: "\u0426",
	  Tab: "	",
	  Tau: "\u03A4",
	  Tcaron: "\u0164",
	  Tcedil: "\u0162",
	  Tcy: "\u0422",
	  Tfr: "\u{1D517}",
	  Therefore: "\u2234",
	  Theta: "\u0398",
	  ThickSpace: "\u205F\u200A",
	  ThinSpace: "\u2009",
	  Tilde: "\u223C",
	  TildeEqual: "\u2243",
	  TildeFullEqual: "\u2245",
	  TildeTilde: "\u2248",
	  Topf: "\u{1D54B}",
	  TripleDot: "\u20DB",
	  Tscr: "\u{1D4AF}",
	  Tstrok: "\u0166",
	  Uacute: "\xDA",
	  Uarr: "\u219F",
	  Uarrocir: "\u2949",
	  Ubrcy: "\u040E",
	  Ubreve: "\u016C",
	  Ucirc: "\xDB",
	  Ucy: "\u0423",
	  Udblac: "\u0170",
	  Ufr: "\u{1D518}",
	  Ugrave: "\xD9",
	  Umacr: "\u016A",
	  UnderBar: "_",
	  UnderBrace: "\u23DF",
	  UnderBracket: "\u23B5",
	  UnderParenthesis: "\u23DD",
	  Union: "\u22C3",
	  UnionPlus: "\u228E",
	  Uogon: "\u0172",
	  Uopf: "\u{1D54C}",
	  UpArrow: "\u2191",
	  UpArrowBar: "\u2912",
	  UpArrowDownArrow: "\u21C5",
	  UpDownArrow: "\u2195",
	  UpEquilibrium: "\u296E",
	  UpTee: "\u22A5",
	  UpTeeArrow: "\u21A5",
	  Uparrow: "\u21D1",
	  Updownarrow: "\u21D5",
	  UpperLeftArrow: "\u2196",
	  UpperRightArrow: "\u2197",
	  Upsi: "\u03D2",
	  Upsilon: "\u03A5",
	  Uring: "\u016E",
	  Uscr: "\u{1D4B0}",
	  Utilde: "\u0168",
	  Uuml: "\xDC",
	  VDash: "\u22AB",
	  Vbar: "\u2AEB",
	  Vcy: "\u0412",
	  Vdash: "\u22A9",
	  Vdashl: "\u2AE6",
	  Vee: "\u22C1",
	  Verbar: "\u2016",
	  Vert: "\u2016",
	  VerticalBar: "\u2223",
	  VerticalLine: "|",
	  VerticalSeparator: "\u2758",
	  VerticalTilde: "\u2240",
	  VeryThinSpace: "\u200A",
	  Vfr: "\u{1D519}",
	  Vopf: "\u{1D54D}",
	  Vscr: "\u{1D4B1}",
	  Vvdash: "\u22AA",
	  Wcirc: "\u0174",
	  Wedge: "\u22C0",
	  Wfr: "\u{1D51A}",
	  Wopf: "\u{1D54E}",
	  Wscr: "\u{1D4B2}",
	  Xfr: "\u{1D51B}",
	  Xi: "\u039E",
	  Xopf: "\u{1D54F}",
	  Xscr: "\u{1D4B3}",
	  YAcy: "\u042F",
	  YIcy: "\u0407",
	  YUcy: "\u042E",
	  Yacute: "\xDD",
	  Ycirc: "\u0176",
	  Ycy: "\u042B",
	  Yfr: "\u{1D51C}",
	  Yopf: "\u{1D550}",
	  Yscr: "\u{1D4B4}",
	  Yuml: "\u0178",
	  ZHcy: "\u0416",
	  Zacute: "\u0179",
	  Zcaron: "\u017D",
	  Zcy: "\u0417",
	  Zdot: "\u017B",
	  ZeroWidthSpace: "\u200B",
	  Zeta: "\u0396",
	  Zfr: "\u2128",
	  Zopf: "\u2124",
	  Zscr: "\u{1D4B5}",
	  aacute: "\xE1",
	  abreve: "\u0103",
	  ac: "\u223E",
	  acE: "\u223E\u0333",
	  acd: "\u223F",
	  acirc: "\xE2",
	  acute: "\xB4",
	  acy: "\u0430",
	  aelig: "\xE6",
	  af: "\u2061",
	  afr: "\u{1D51E}",
	  agrave: "\xE0",
	  alefsym: "\u2135",
	  aleph: "\u2135",
	  alpha: "\u03B1",
	  amacr: "\u0101",
	  amalg: "\u2A3F",
	  amp: "&",
	  and: "\u2227",
	  andand: "\u2A55",
	  andd: "\u2A5C",
	  andslope: "\u2A58",
	  andv: "\u2A5A",
	  ang: "\u2220",
	  ange: "\u29A4",
	  angle: "\u2220",
	  angmsd: "\u2221",
	  angmsdaa: "\u29A8",
	  angmsdab: "\u29A9",
	  angmsdac: "\u29AA",
	  angmsdad: "\u29AB",
	  angmsdae: "\u29AC",
	  angmsdaf: "\u29AD",
	  angmsdag: "\u29AE",
	  angmsdah: "\u29AF",
	  angrt: "\u221F",
	  angrtvb: "\u22BE",
	  angrtvbd: "\u299D",
	  angsph: "\u2222",
	  angst: "\xC5",
	  angzarr: "\u237C",
	  aogon: "\u0105",
	  aopf: "\u{1D552}",
	  ap: "\u2248",
	  apE: "\u2A70",
	  apacir: "\u2A6F",
	  ape: "\u224A",
	  apid: "\u224B",
	  apos: "'",
	  approx: "\u2248",
	  approxeq: "\u224A",
	  aring: "\xE5",
	  ascr: "\u{1D4B6}",
	  ast: "*",
	  asymp: "\u2248",
	  asympeq: "\u224D",
	  atilde: "\xE3",
	  auml: "\xE4",
	  awconint: "\u2233",
	  awint: "\u2A11",
	  bNot: "\u2AED",
	  backcong: "\u224C",
	  backepsilon: "\u03F6",
	  backprime: "\u2035",
	  backsim: "\u223D",
	  backsimeq: "\u22CD",
	  barvee: "\u22BD",
	  barwed: "\u2305",
	  barwedge: "\u2305",
	  bbrk: "\u23B5",
	  bbrktbrk: "\u23B6",
	  bcong: "\u224C",
	  bcy: "\u0431",
	  bdquo: "\u201E",
	  becaus: "\u2235",
	  because: "\u2235",
	  bemptyv: "\u29B0",
	  bepsi: "\u03F6",
	  bernou: "\u212C",
	  beta: "\u03B2",
	  beth: "\u2136",
	  between: "\u226C",
	  bfr: "\u{1D51F}",
	  bigcap: "\u22C2",
	  bigcirc: "\u25EF",
	  bigcup: "\u22C3",
	  bigodot: "\u2A00",
	  bigoplus: "\u2A01",
	  bigotimes: "\u2A02",
	  bigsqcup: "\u2A06",
	  bigstar: "\u2605",
	  bigtriangledown: "\u25BD",
	  bigtriangleup: "\u25B3",
	  biguplus: "\u2A04",
	  bigvee: "\u22C1",
	  bigwedge: "\u22C0",
	  bkarow: "\u290D",
	  blacklozenge: "\u29EB",
	  blacksquare: "\u25AA",
	  blacktriangle: "\u25B4",
	  blacktriangledown: "\u25BE",
	  blacktriangleleft: "\u25C2",
	  blacktriangleright: "\u25B8",
	  blank: "\u2423",
	  blk12: "\u2592",
	  blk14: "\u2591",
	  blk34: "\u2593",
	  block: "\u2588",
	  bne: "=\u20E5",
	  bnequiv: "\u2261\u20E5",
	  bnot: "\u2310",
	  bopf: "\u{1D553}",
	  bot: "\u22A5",
	  bottom: "\u22A5",
	  bowtie: "\u22C8",
	  boxDL: "\u2557",
	  boxDR: "\u2554",
	  boxDl: "\u2556",
	  boxDr: "\u2553",
	  boxH: "\u2550",
	  boxHD: "\u2566",
	  boxHU: "\u2569",
	  boxHd: "\u2564",
	  boxHu: "\u2567",
	  boxUL: "\u255D",
	  boxUR: "\u255A",
	  boxUl: "\u255C",
	  boxUr: "\u2559",
	  boxV: "\u2551",
	  boxVH: "\u256C",
	  boxVL: "\u2563",
	  boxVR: "\u2560",
	  boxVh: "\u256B",
	  boxVl: "\u2562",
	  boxVr: "\u255F",
	  boxbox: "\u29C9",
	  boxdL: "\u2555",
	  boxdR: "\u2552",
	  boxdl: "\u2510",
	  boxdr: "\u250C",
	  boxh: "\u2500",
	  boxhD: "\u2565",
	  boxhU: "\u2568",
	  boxhd: "\u252C",
	  boxhu: "\u2534",
	  boxminus: "\u229F",
	  boxplus: "\u229E",
	  boxtimes: "\u22A0",
	  boxuL: "\u255B",
	  boxuR: "\u2558",
	  boxul: "\u2518",
	  boxur: "\u2514",
	  boxv: "\u2502",
	  boxvH: "\u256A",
	  boxvL: "\u2561",
	  boxvR: "\u255E",
	  boxvh: "\u253C",
	  boxvl: "\u2524",
	  boxvr: "\u251C",
	  bprime: "\u2035",
	  breve: "\u02D8",
	  brvbar: "\xA6",
	  bscr: "\u{1D4B7}",
	  bsemi: "\u204F",
	  bsim: "\u223D",
	  bsime: "\u22CD",
	  bsol: "\\",
	  bsolb: "\u29C5",
	  bsolhsub: "\u27C8",
	  bull: "\u2022",
	  bullet: "\u2022",
	  bump: "\u224E",
	  bumpE: "\u2AAE",
	  bumpe: "\u224F",
	  bumpeq: "\u224F",
	  cacute: "\u0107",
	  cap: "\u2229",
	  capand: "\u2A44",
	  capbrcup: "\u2A49",
	  capcap: "\u2A4B",
	  capcup: "\u2A47",
	  capdot: "\u2A40",
	  caps: "\u2229\uFE00",
	  caret: "\u2041",
	  caron: "\u02C7",
	  ccaps: "\u2A4D",
	  ccaron: "\u010D",
	  ccedil: "\xE7",
	  ccirc: "\u0109",
	  ccups: "\u2A4C",
	  ccupssm: "\u2A50",
	  cdot: "\u010B",
	  cedil: "\xB8",
	  cemptyv: "\u29B2",
	  cent: "\xA2",
	  centerdot: "\xB7",
	  cfr: "\u{1D520}",
	  chcy: "\u0447",
	  check: "\u2713",
	  checkmark: "\u2713",
	  chi: "\u03C7",
	  cir: "\u25CB",
	  cirE: "\u29C3",
	  circ: "\u02C6",
	  circeq: "\u2257",
	  circlearrowleft: "\u21BA",
	  circlearrowright: "\u21BB",
	  circledR: "\xAE",
	  circledS: "\u24C8",
	  circledast: "\u229B",
	  circledcirc: "\u229A",
	  circleddash: "\u229D",
	  cire: "\u2257",
	  cirfnint: "\u2A10",
	  cirmid: "\u2AEF",
	  cirscir: "\u29C2",
	  clubs: "\u2663",
	  clubsuit: "\u2663",
	  colon: ":",
	  colone: "\u2254",
	  coloneq: "\u2254",
	  comma: ",",
	  commat: "@",
	  comp: "\u2201",
	  compfn: "\u2218",
	  complement: "\u2201",
	  complexes: "\u2102",
	  cong: "\u2245",
	  congdot: "\u2A6D",
	  conint: "\u222E",
	  copf: "\u{1D554}",
	  coprod: "\u2210",
	  copy: "\xA9",
	  copysr: "\u2117",
	  crarr: "\u21B5",
	  cross: "\u2717",
	  cscr: "\u{1D4B8}",
	  csub: "\u2ACF",
	  csube: "\u2AD1",
	  csup: "\u2AD0",
	  csupe: "\u2AD2",
	  ctdot: "\u22EF",
	  cudarrl: "\u2938",
	  cudarrr: "\u2935",
	  cuepr: "\u22DE",
	  cuesc: "\u22DF",
	  cularr: "\u21B6",
	  cularrp: "\u293D",
	  cup: "\u222A",
	  cupbrcap: "\u2A48",
	  cupcap: "\u2A46",
	  cupcup: "\u2A4A",
	  cupdot: "\u228D",
	  cupor: "\u2A45",
	  cups: "\u222A\uFE00",
	  curarr: "\u21B7",
	  curarrm: "\u293C",
	  curlyeqprec: "\u22DE",
	  curlyeqsucc: "\u22DF",
	  curlyvee: "\u22CE",
	  curlywedge: "\u22CF",
	  curren: "\xA4",
	  curvearrowleft: "\u21B6",
	  curvearrowright: "\u21B7",
	  cuvee: "\u22CE",
	  cuwed: "\u22CF",
	  cwconint: "\u2232",
	  cwint: "\u2231",
	  cylcty: "\u232D",
	  dArr: "\u21D3",
	  dHar: "\u2965",
	  dagger: "\u2020",
	  daleth: "\u2138",
	  darr: "\u2193",
	  dash: "\u2010",
	  dashv: "\u22A3",
	  dbkarow: "\u290F",
	  dblac: "\u02DD",
	  dcaron: "\u010F",
	  dcy: "\u0434",
	  dd: "\u2146",
	  ddagger: "\u2021",
	  ddarr: "\u21CA",
	  ddotseq: "\u2A77",
	  deg: "\xB0",
	  delta: "\u03B4",
	  demptyv: "\u29B1",
	  dfisht: "\u297F",
	  dfr: "\u{1D521}",
	  dharl: "\u21C3",
	  dharr: "\u21C2",
	  diam: "\u22C4",
	  diamond: "\u22C4",
	  diamondsuit: "\u2666",
	  diams: "\u2666",
	  die: "\xA8",
	  digamma: "\u03DD",
	  disin: "\u22F2",
	  div: "\xF7",
	  divide: "\xF7",
	  divideontimes: "\u22C7",
	  divonx: "\u22C7",
	  djcy: "\u0452",
	  dlcorn: "\u231E",
	  dlcrop: "\u230D",
	  dollar: "$",
	  dopf: "\u{1D555}",
	  dot: "\u02D9",
	  doteq: "\u2250",
	  doteqdot: "\u2251",
	  dotminus: "\u2238",
	  dotplus: "\u2214",
	  dotsquare: "\u22A1",
	  doublebarwedge: "\u2306",
	  downarrow: "\u2193",
	  downdownarrows: "\u21CA",
	  downharpoonleft: "\u21C3",
	  downharpoonright: "\u21C2",
	  drbkarow: "\u2910",
	  drcorn: "\u231F",
	  drcrop: "\u230C",
	  dscr: "\u{1D4B9}",
	  dscy: "\u0455",
	  dsol: "\u29F6",
	  dstrok: "\u0111",
	  dtdot: "\u22F1",
	  dtri: "\u25BF",
	  dtrif: "\u25BE",
	  duarr: "\u21F5",
	  duhar: "\u296F",
	  dwangle: "\u29A6",
	  dzcy: "\u045F",
	  dzigrarr: "\u27FF",
	  eDDot: "\u2A77",
	  eDot: "\u2251",
	  eacute: "\xE9",
	  easter: "\u2A6E",
	  ecaron: "\u011B",
	  ecir: "\u2256",
	  ecirc: "\xEA",
	  ecolon: "\u2255",
	  ecy: "\u044D",
	  edot: "\u0117",
	  ee: "\u2147",
	  efDot: "\u2252",
	  efr: "\u{1D522}",
	  eg: "\u2A9A",
	  egrave: "\xE8",
	  egs: "\u2A96",
	  egsdot: "\u2A98",
	  el: "\u2A99",
	  elinters: "\u23E7",
	  ell: "\u2113",
	  els: "\u2A95",
	  elsdot: "\u2A97",
	  emacr: "\u0113",
	  empty: "\u2205",
	  emptyset: "\u2205",
	  emptyv: "\u2205",
	  emsp13: "\u2004",
	  emsp14: "\u2005",
	  emsp: "\u2003",
	  eng: "\u014B",
	  ensp: "\u2002",
	  eogon: "\u0119",
	  eopf: "\u{1D556}",
	  epar: "\u22D5",
	  eparsl: "\u29E3",
	  eplus: "\u2A71",
	  epsi: "\u03B5",
	  epsilon: "\u03B5",
	  epsiv: "\u03F5",
	  eqcirc: "\u2256",
	  eqcolon: "\u2255",
	  eqsim: "\u2242",
	  eqslantgtr: "\u2A96",
	  eqslantless: "\u2A95",
	  equals: "=",
	  equest: "\u225F",
	  equiv: "\u2261",
	  equivDD: "\u2A78",
	  eqvparsl: "\u29E5",
	  erDot: "\u2253",
	  erarr: "\u2971",
	  escr: "\u212F",
	  esdot: "\u2250",
	  esim: "\u2242",
	  eta: "\u03B7",
	  eth: "\xF0",
	  euml: "\xEB",
	  euro: "\u20AC",
	  excl: "!",
	  exist: "\u2203",
	  expectation: "\u2130",
	  exponentiale: "\u2147",
	  fallingdotseq: "\u2252",
	  fcy: "\u0444",
	  female: "\u2640",
	  ffilig: "\uFB03",
	  fflig: "\uFB00",
	  ffllig: "\uFB04",
	  ffr: "\u{1D523}",
	  filig: "\uFB01",
	  fjlig: "fj",
	  flat: "\u266D",
	  fllig: "\uFB02",
	  fltns: "\u25B1",
	  fnof: "\u0192",
	  fopf: "\u{1D557}",
	  forall: "\u2200",
	  fork: "\u22D4",
	  forkv: "\u2AD9",
	  fpartint: "\u2A0D",
	  frac12: "\xBD",
	  frac13: "\u2153",
	  frac14: "\xBC",
	  frac15: "\u2155",
	  frac16: "\u2159",
	  frac18: "\u215B",
	  frac23: "\u2154",
	  frac25: "\u2156",
	  frac34: "\xBE",
	  frac35: "\u2157",
	  frac38: "\u215C",
	  frac45: "\u2158",
	  frac56: "\u215A",
	  frac58: "\u215D",
	  frac78: "\u215E",
	  frasl: "\u2044",
	  frown: "\u2322",
	  fscr: "\u{1D4BB}",
	  gE: "\u2267",
	  gEl: "\u2A8C",
	  gacute: "\u01F5",
	  gamma: "\u03B3",
	  gammad: "\u03DD",
	  gap: "\u2A86",
	  gbreve: "\u011F",
	  gcirc: "\u011D",
	  gcy: "\u0433",
	  gdot: "\u0121",
	  ge: "\u2265",
	  gel: "\u22DB",
	  geq: "\u2265",
	  geqq: "\u2267",
	  geqslant: "\u2A7E",
	  ges: "\u2A7E",
	  gescc: "\u2AA9",
	  gesdot: "\u2A80",
	  gesdoto: "\u2A82",
	  gesdotol: "\u2A84",
	  gesl: "\u22DB\uFE00",
	  gesles: "\u2A94",
	  gfr: "\u{1D524}",
	  gg: "\u226B",
	  ggg: "\u22D9",
	  gimel: "\u2137",
	  gjcy: "\u0453",
	  gl: "\u2277",
	  glE: "\u2A92",
	  gla: "\u2AA5",
	  glj: "\u2AA4",
	  gnE: "\u2269",
	  gnap: "\u2A8A",
	  gnapprox: "\u2A8A",
	  gne: "\u2A88",
	  gneq: "\u2A88",
	  gneqq: "\u2269",
	  gnsim: "\u22E7",
	  gopf: "\u{1D558}",
	  grave: "`",
	  gscr: "\u210A",
	  gsim: "\u2273",
	  gsime: "\u2A8E",
	  gsiml: "\u2A90",
	  gt: ">",
	  gtcc: "\u2AA7",
	  gtcir: "\u2A7A",
	  gtdot: "\u22D7",
	  gtlPar: "\u2995",
	  gtquest: "\u2A7C",
	  gtrapprox: "\u2A86",
	  gtrarr: "\u2978",
	  gtrdot: "\u22D7",
	  gtreqless: "\u22DB",
	  gtreqqless: "\u2A8C",
	  gtrless: "\u2277",
	  gtrsim: "\u2273",
	  gvertneqq: "\u2269\uFE00",
	  gvnE: "\u2269\uFE00",
	  hArr: "\u21D4",
	  hairsp: "\u200A",
	  half: "\xBD",
	  hamilt: "\u210B",
	  hardcy: "\u044A",
	  harr: "\u2194",
	  harrcir: "\u2948",
	  harrw: "\u21AD",
	  hbar: "\u210F",
	  hcirc: "\u0125",
	  hearts: "\u2665",
	  heartsuit: "\u2665",
	  hellip: "\u2026",
	  hercon: "\u22B9",
	  hfr: "\u{1D525}",
	  hksearow: "\u2925",
	  hkswarow: "\u2926",
	  hoarr: "\u21FF",
	  homtht: "\u223B",
	  hookleftarrow: "\u21A9",
	  hookrightarrow: "\u21AA",
	  hopf: "\u{1D559}",
	  horbar: "\u2015",
	  hscr: "\u{1D4BD}",
	  hslash: "\u210F",
	  hstrok: "\u0127",
	  hybull: "\u2043",
	  hyphen: "\u2010",
	  iacute: "\xED",
	  ic: "\u2063",
	  icirc: "\xEE",
	  icy: "\u0438",
	  iecy: "\u0435",
	  iexcl: "\xA1",
	  iff: "\u21D4",
	  ifr: "\u{1D526}",
	  igrave: "\xEC",
	  ii: "\u2148",
	  iiiint: "\u2A0C",
	  iiint: "\u222D",
	  iinfin: "\u29DC",
	  iiota: "\u2129",
	  ijlig: "\u0133",
	  imacr: "\u012B",
	  image: "\u2111",
	  imagline: "\u2110",
	  imagpart: "\u2111",
	  imath: "\u0131",
	  imof: "\u22B7",
	  imped: "\u01B5",
	  in: "\u2208",
	  incare: "\u2105",
	  infin: "\u221E",
	  infintie: "\u29DD",
	  inodot: "\u0131",
	  int: "\u222B",
	  intcal: "\u22BA",
	  integers: "\u2124",
	  intercal: "\u22BA",
	  intlarhk: "\u2A17",
	  intprod: "\u2A3C",
	  iocy: "\u0451",
	  iogon: "\u012F",
	  iopf: "\u{1D55A}",
	  iota: "\u03B9",
	  iprod: "\u2A3C",
	  iquest: "\xBF",
	  iscr: "\u{1D4BE}",
	  isin: "\u2208",
	  isinE: "\u22F9",
	  isindot: "\u22F5",
	  isins: "\u22F4",
	  isinsv: "\u22F3",
	  isinv: "\u2208",
	  it: "\u2062",
	  itilde: "\u0129",
	  iukcy: "\u0456",
	  iuml: "\xEF",
	  jcirc: "\u0135",
	  jcy: "\u0439",
	  jfr: "\u{1D527}",
	  jmath: "\u0237",
	  jopf: "\u{1D55B}",
	  jscr: "\u{1D4BF}",
	  jsercy: "\u0458",
	  jukcy: "\u0454",
	  kappa: "\u03BA",
	  kappav: "\u03F0",
	  kcedil: "\u0137",
	  kcy: "\u043A",
	  kfr: "\u{1D528}",
	  kgreen: "\u0138",
	  khcy: "\u0445",
	  kjcy: "\u045C",
	  kopf: "\u{1D55C}",
	  kscr: "\u{1D4C0}",
	  lAarr: "\u21DA",
	  lArr: "\u21D0",
	  lAtail: "\u291B",
	  lBarr: "\u290E",
	  lE: "\u2266",
	  lEg: "\u2A8B",
	  lHar: "\u2962",
	  lacute: "\u013A",
	  laemptyv: "\u29B4",
	  lagran: "\u2112",
	  lambda: "\u03BB",
	  lang: "\u27E8",
	  langd: "\u2991",
	  langle: "\u27E8",
	  lap: "\u2A85",
	  laquo: "\xAB",
	  larr: "\u2190",
	  larrb: "\u21E4",
	  larrbfs: "\u291F",
	  larrfs: "\u291D",
	  larrhk: "\u21A9",
	  larrlp: "\u21AB",
	  larrpl: "\u2939",
	  larrsim: "\u2973",
	  larrtl: "\u21A2",
	  lat: "\u2AAB",
	  latail: "\u2919",
	  late: "\u2AAD",
	  lates: "\u2AAD\uFE00",
	  lbarr: "\u290C",
	  lbbrk: "\u2772",
	  lbrace: "{",
	  lbrack: "[",
	  lbrke: "\u298B",
	  lbrksld: "\u298F",
	  lbrkslu: "\u298D",
	  lcaron: "\u013E",
	  lcedil: "\u013C",
	  lceil: "\u2308",
	  lcub: "{",
	  lcy: "\u043B",
	  ldca: "\u2936",
	  ldquo: "\u201C",
	  ldquor: "\u201E",
	  ldrdhar: "\u2967",
	  ldrushar: "\u294B",
	  ldsh: "\u21B2",
	  le: "\u2264",
	  leftarrow: "\u2190",
	  leftarrowtail: "\u21A2",
	  leftharpoondown: "\u21BD",
	  leftharpoonup: "\u21BC",
	  leftleftarrows: "\u21C7",
	  leftrightarrow: "\u2194",
	  leftrightarrows: "\u21C6",
	  leftrightharpoons: "\u21CB",
	  leftrightsquigarrow: "\u21AD",
	  leftthreetimes: "\u22CB",
	  leg: "\u22DA",
	  leq: "\u2264",
	  leqq: "\u2266",
	  leqslant: "\u2A7D",
	  les: "\u2A7D",
	  lescc: "\u2AA8",
	  lesdot: "\u2A7F",
	  lesdoto: "\u2A81",
	  lesdotor: "\u2A83",
	  lesg: "\u22DA\uFE00",
	  lesges: "\u2A93",
	  lessapprox: "\u2A85",
	  lessdot: "\u22D6",
	  lesseqgtr: "\u22DA",
	  lesseqqgtr: "\u2A8B",
	  lessgtr: "\u2276",
	  lesssim: "\u2272",
	  lfisht: "\u297C",
	  lfloor: "\u230A",
	  lfr: "\u{1D529}",
	  lg: "\u2276",
	  lgE: "\u2A91",
	  lhard: "\u21BD",
	  lharu: "\u21BC",
	  lharul: "\u296A",
	  lhblk: "\u2584",
	  ljcy: "\u0459",
	  ll: "\u226A",
	  llarr: "\u21C7",
	  llcorner: "\u231E",
	  llhard: "\u296B",
	  lltri: "\u25FA",
	  lmidot: "\u0140",
	  lmoust: "\u23B0",
	  lmoustache: "\u23B0",
	  lnE: "\u2268",
	  lnap: "\u2A89",
	  lnapprox: "\u2A89",
	  lne: "\u2A87",
	  lneq: "\u2A87",
	  lneqq: "\u2268",
	  lnsim: "\u22E6",
	  loang: "\u27EC",
	  loarr: "\u21FD",
	  lobrk: "\u27E6",
	  longleftarrow: "\u27F5",
	  longleftrightarrow: "\u27F7",
	  longmapsto: "\u27FC",
	  longrightarrow: "\u27F6",
	  looparrowleft: "\u21AB",
	  looparrowright: "\u21AC",
	  lopar: "\u2985",
	  lopf: "\u{1D55D}",
	  loplus: "\u2A2D",
	  lotimes: "\u2A34",
	  lowast: "\u2217",
	  lowbar: "_",
	  loz: "\u25CA",
	  lozenge: "\u25CA",
	  lozf: "\u29EB",
	  lpar: "(",
	  lparlt: "\u2993",
	  lrarr: "\u21C6",
	  lrcorner: "\u231F",
	  lrhar: "\u21CB",
	  lrhard: "\u296D",
	  lrm: "\u200E",
	  lrtri: "\u22BF",
	  lsaquo: "\u2039",
	  lscr: "\u{1D4C1}",
	  lsh: "\u21B0",
	  lsim: "\u2272",
	  lsime: "\u2A8D",
	  lsimg: "\u2A8F",
	  lsqb: "[",
	  lsquo: "\u2018",
	  lsquor: "\u201A",
	  lstrok: "\u0142",
	  lt: "<",
	  ltcc: "\u2AA6",
	  ltcir: "\u2A79",
	  ltdot: "\u22D6",
	  lthree: "\u22CB",
	  ltimes: "\u22C9",
	  ltlarr: "\u2976",
	  ltquest: "\u2A7B",
	  ltrPar: "\u2996",
	  ltri: "\u25C3",
	  ltrie: "\u22B4",
	  ltrif: "\u25C2",
	  lurdshar: "\u294A",
	  luruhar: "\u2966",
	  lvertneqq: "\u2268\uFE00",
	  lvnE: "\u2268\uFE00",
	  mDDot: "\u223A",
	  macr: "\xAF",
	  male: "\u2642",
	  malt: "\u2720",
	  maltese: "\u2720",
	  map: "\u21A6",
	  mapsto: "\u21A6",
	  mapstodown: "\u21A7",
	  mapstoleft: "\u21A4",
	  mapstoup: "\u21A5",
	  marker: "\u25AE",
	  mcomma: "\u2A29",
	  mcy: "\u043C",
	  mdash: "\u2014",
	  measuredangle: "\u2221",
	  mfr: "\u{1D52A}",
	  mho: "\u2127",
	  micro: "\xB5",
	  mid: "\u2223",
	  midast: "*",
	  midcir: "\u2AF0",
	  middot: "\xB7",
	  minus: "\u2212",
	  minusb: "\u229F",
	  minusd: "\u2238",
	  minusdu: "\u2A2A",
	  mlcp: "\u2ADB",
	  mldr: "\u2026",
	  mnplus: "\u2213",
	  models: "\u22A7",
	  mopf: "\u{1D55E}",
	  mp: "\u2213",
	  mscr: "\u{1D4C2}",
	  mstpos: "\u223E",
	  mu: "\u03BC",
	  multimap: "\u22B8",
	  mumap: "\u22B8",
	  nGg: "\u22D9\u0338",
	  nGt: "\u226B\u20D2",
	  nGtv: "\u226B\u0338",
	  nLeftarrow: "\u21CD",
	  nLeftrightarrow: "\u21CE",
	  nLl: "\u22D8\u0338",
	  nLt: "\u226A\u20D2",
	  nLtv: "\u226A\u0338",
	  nRightarrow: "\u21CF",
	  nVDash: "\u22AF",
	  nVdash: "\u22AE",
	  nabla: "\u2207",
	  nacute: "\u0144",
	  nang: "\u2220\u20D2",
	  nap: "\u2249",
	  napE: "\u2A70\u0338",
	  napid: "\u224B\u0338",
	  napos: "\u0149",
	  napprox: "\u2249",
	  natur: "\u266E",
	  natural: "\u266E",
	  naturals: "\u2115",
	  nbsp: "\xA0",
	  nbump: "\u224E\u0338",
	  nbumpe: "\u224F\u0338",
	  ncap: "\u2A43",
	  ncaron: "\u0148",
	  ncedil: "\u0146",
	  ncong: "\u2247",
	  ncongdot: "\u2A6D\u0338",
	  ncup: "\u2A42",
	  ncy: "\u043D",
	  ndash: "\u2013",
	  ne: "\u2260",
	  neArr: "\u21D7",
	  nearhk: "\u2924",
	  nearr: "\u2197",
	  nearrow: "\u2197",
	  nedot: "\u2250\u0338",
	  nequiv: "\u2262",
	  nesear: "\u2928",
	  nesim: "\u2242\u0338",
	  nexist: "\u2204",
	  nexists: "\u2204",
	  nfr: "\u{1D52B}",
	  ngE: "\u2267\u0338",
	  nge: "\u2271",
	  ngeq: "\u2271",
	  ngeqq: "\u2267\u0338",
	  ngeqslant: "\u2A7E\u0338",
	  nges: "\u2A7E\u0338",
	  ngsim: "\u2275",
	  ngt: "\u226F",
	  ngtr: "\u226F",
	  nhArr: "\u21CE",
	  nharr: "\u21AE",
	  nhpar: "\u2AF2",
	  ni: "\u220B",
	  nis: "\u22FC",
	  nisd: "\u22FA",
	  niv: "\u220B",
	  njcy: "\u045A",
	  nlArr: "\u21CD",
	  nlE: "\u2266\u0338",
	  nlarr: "\u219A",
	  nldr: "\u2025",
	  nle: "\u2270",
	  nleftarrow: "\u219A",
	  nleftrightarrow: "\u21AE",
	  nleq: "\u2270",
	  nleqq: "\u2266\u0338",
	  nleqslant: "\u2A7D\u0338",
	  nles: "\u2A7D\u0338",
	  nless: "\u226E",
	  nlsim: "\u2274",
	  nlt: "\u226E",
	  nltri: "\u22EA",
	  nltrie: "\u22EC",
	  nmid: "\u2224",
	  nopf: "\u{1D55F}",
	  not: "\xAC",
	  notin: "\u2209",
	  notinE: "\u22F9\u0338",
	  notindot: "\u22F5\u0338",
	  notinva: "\u2209",
	  notinvb: "\u22F7",
	  notinvc: "\u22F6",
	  notni: "\u220C",
	  notniva: "\u220C",
	  notnivb: "\u22FE",
	  notnivc: "\u22FD",
	  npar: "\u2226",
	  nparallel: "\u2226",
	  nparsl: "\u2AFD\u20E5",
	  npart: "\u2202\u0338",
	  npolint: "\u2A14",
	  npr: "\u2280",
	  nprcue: "\u22E0",
	  npre: "\u2AAF\u0338",
	  nprec: "\u2280",
	  npreceq: "\u2AAF\u0338",
	  nrArr: "\u21CF",
	  nrarr: "\u219B",
	  nrarrc: "\u2933\u0338",
	  nrarrw: "\u219D\u0338",
	  nrightarrow: "\u219B",
	  nrtri: "\u22EB",
	  nrtrie: "\u22ED",
	  nsc: "\u2281",
	  nsccue: "\u22E1",
	  nsce: "\u2AB0\u0338",
	  nscr: "\u{1D4C3}",
	  nshortmid: "\u2224",
	  nshortparallel: "\u2226",
	  nsim: "\u2241",
	  nsime: "\u2244",
	  nsimeq: "\u2244",
	  nsmid: "\u2224",
	  nspar: "\u2226",
	  nsqsube: "\u22E2",
	  nsqsupe: "\u22E3",
	  nsub: "\u2284",
	  nsubE: "\u2AC5\u0338",
	  nsube: "\u2288",
	  nsubset: "\u2282\u20D2",
	  nsubseteq: "\u2288",
	  nsubseteqq: "\u2AC5\u0338",
	  nsucc: "\u2281",
	  nsucceq: "\u2AB0\u0338",
	  nsup: "\u2285",
	  nsupE: "\u2AC6\u0338",
	  nsupe: "\u2289",
	  nsupset: "\u2283\u20D2",
	  nsupseteq: "\u2289",
	  nsupseteqq: "\u2AC6\u0338",
	  ntgl: "\u2279",
	  ntilde: "\xF1",
	  ntlg: "\u2278",
	  ntriangleleft: "\u22EA",
	  ntrianglelefteq: "\u22EC",
	  ntriangleright: "\u22EB",
	  ntrianglerighteq: "\u22ED",
	  nu: "\u03BD",
	  num: "#",
	  numero: "\u2116",
	  numsp: "\u2007",
	  nvDash: "\u22AD",
	  nvHarr: "\u2904",
	  nvap: "\u224D\u20D2",
	  nvdash: "\u22AC",
	  nvge: "\u2265\u20D2",
	  nvgt: ">\u20D2",
	  nvinfin: "\u29DE",
	  nvlArr: "\u2902",
	  nvle: "\u2264\u20D2",
	  nvlt: "<\u20D2",
	  nvltrie: "\u22B4\u20D2",
	  nvrArr: "\u2903",
	  nvrtrie: "\u22B5\u20D2",
	  nvsim: "\u223C\u20D2",
	  nwArr: "\u21D6",
	  nwarhk: "\u2923",
	  nwarr: "\u2196",
	  nwarrow: "\u2196",
	  nwnear: "\u2927",
	  oS: "\u24C8",
	  oacute: "\xF3",
	  oast: "\u229B",
	  ocir: "\u229A",
	  ocirc: "\xF4",
	  ocy: "\u043E",
	  odash: "\u229D",
	  odblac: "\u0151",
	  odiv: "\u2A38",
	  odot: "\u2299",
	  odsold: "\u29BC",
	  oelig: "\u0153",
	  ofcir: "\u29BF",
	  ofr: "\u{1D52C}",
	  ogon: "\u02DB",
	  ograve: "\xF2",
	  ogt: "\u29C1",
	  ohbar: "\u29B5",
	  ohm: "\u03A9",
	  oint: "\u222E",
	  olarr: "\u21BA",
	  olcir: "\u29BE",
	  olcross: "\u29BB",
	  oline: "\u203E",
	  olt: "\u29C0",
	  omacr: "\u014D",
	  omega: "\u03C9",
	  omicron: "\u03BF",
	  omid: "\u29B6",
	  ominus: "\u2296",
	  oopf: "\u{1D560}",
	  opar: "\u29B7",
	  operp: "\u29B9",
	  oplus: "\u2295",
	  or: "\u2228",
	  orarr: "\u21BB",
	  ord: "\u2A5D",
	  order: "\u2134",
	  orderof: "\u2134",
	  ordf: "\xAA",
	  ordm: "\xBA",
	  origof: "\u22B6",
	  oror: "\u2A56",
	  orslope: "\u2A57",
	  orv: "\u2A5B",
	  oscr: "\u2134",
	  oslash: "\xF8",
	  osol: "\u2298",
	  otilde: "\xF5",
	  otimes: "\u2297",
	  otimesas: "\u2A36",
	  ouml: "\xF6",
	  ovbar: "\u233D",
	  par: "\u2225",
	  para: "\xB6",
	  parallel: "\u2225",
	  parsim: "\u2AF3",
	  parsl: "\u2AFD",
	  part: "\u2202",
	  pcy: "\u043F",
	  percnt: "%",
	  period: ".",
	  permil: "\u2030",
	  perp: "\u22A5",
	  pertenk: "\u2031",
	  pfr: "\u{1D52D}",
	  phi: "\u03C6",
	  phiv: "\u03D5",
	  phmmat: "\u2133",
	  phone: "\u260E",
	  pi: "\u03C0",
	  pitchfork: "\u22D4",
	  piv: "\u03D6",
	  planck: "\u210F",
	  planckh: "\u210E",
	  plankv: "\u210F",
	  plus: "+",
	  plusacir: "\u2A23",
	  plusb: "\u229E",
	  pluscir: "\u2A22",
	  plusdo: "\u2214",
	  plusdu: "\u2A25",
	  pluse: "\u2A72",
	  plusmn: "\xB1",
	  plussim: "\u2A26",
	  plustwo: "\u2A27",
	  pm: "\xB1",
	  pointint: "\u2A15",
	  popf: "\u{1D561}",
	  pound: "\xA3",
	  pr: "\u227A",
	  prE: "\u2AB3",
	  prap: "\u2AB7",
	  prcue: "\u227C",
	  pre: "\u2AAF",
	  prec: "\u227A",
	  precapprox: "\u2AB7",
	  preccurlyeq: "\u227C",
	  preceq: "\u2AAF",
	  precnapprox: "\u2AB9",
	  precneqq: "\u2AB5",
	  precnsim: "\u22E8",
	  precsim: "\u227E",
	  prime: "\u2032",
	  primes: "\u2119",
	  prnE: "\u2AB5",
	  prnap: "\u2AB9",
	  prnsim: "\u22E8",
	  prod: "\u220F",
	  profalar: "\u232E",
	  profline: "\u2312",
	  profsurf: "\u2313",
	  prop: "\u221D",
	  propto: "\u221D",
	  prsim: "\u227E",
	  prurel: "\u22B0",
	  pscr: "\u{1D4C5}",
	  psi: "\u03C8",
	  puncsp: "\u2008",
	  qfr: "\u{1D52E}",
	  qint: "\u2A0C",
	  qopf: "\u{1D562}",
	  qprime: "\u2057",
	  qscr: "\u{1D4C6}",
	  quaternions: "\u210D",
	  quatint: "\u2A16",
	  quest: "?",
	  questeq: "\u225F",
	  quot: '"',
	  rAarr: "\u21DB",
	  rArr: "\u21D2",
	  rAtail: "\u291C",
	  rBarr: "\u290F",
	  rHar: "\u2964",
	  race: "\u223D\u0331",
	  racute: "\u0155",
	  radic: "\u221A",
	  raemptyv: "\u29B3",
	  rang: "\u27E9",
	  rangd: "\u2992",
	  range: "\u29A5",
	  rangle: "\u27E9",
	  raquo: "\xBB",
	  rarr: "\u2192",
	  rarrap: "\u2975",
	  rarrb: "\u21E5",
	  rarrbfs: "\u2920",
	  rarrc: "\u2933",
	  rarrfs: "\u291E",
	  rarrhk: "\u21AA",
	  rarrlp: "\u21AC",
	  rarrpl: "\u2945",
	  rarrsim: "\u2974",
	  rarrtl: "\u21A3",
	  rarrw: "\u219D",
	  ratail: "\u291A",
	  ratio: "\u2236",
	  rationals: "\u211A",
	  rbarr: "\u290D",
	  rbbrk: "\u2773",
	  rbrace: "}",
	  rbrack: "]",
	  rbrke: "\u298C",
	  rbrksld: "\u298E",
	  rbrkslu: "\u2990",
	  rcaron: "\u0159",
	  rcedil: "\u0157",
	  rceil: "\u2309",
	  rcub: "}",
	  rcy: "\u0440",
	  rdca: "\u2937",
	  rdldhar: "\u2969",
	  rdquo: "\u201D",
	  rdquor: "\u201D",
	  rdsh: "\u21B3",
	  real: "\u211C",
	  realine: "\u211B",
	  realpart: "\u211C",
	  reals: "\u211D",
	  rect: "\u25AD",
	  reg: "\xAE",
	  rfisht: "\u297D",
	  rfloor: "\u230B",
	  rfr: "\u{1D52F}",
	  rhard: "\u21C1",
	  rharu: "\u21C0",
	  rharul: "\u296C",
	  rho: "\u03C1",
	  rhov: "\u03F1",
	  rightarrow: "\u2192",
	  rightarrowtail: "\u21A3",
	  rightharpoondown: "\u21C1",
	  rightharpoonup: "\u21C0",
	  rightleftarrows: "\u21C4",
	  rightleftharpoons: "\u21CC",
	  rightrightarrows: "\u21C9",
	  rightsquigarrow: "\u219D",
	  rightthreetimes: "\u22CC",
	  ring: "\u02DA",
	  risingdotseq: "\u2253",
	  rlarr: "\u21C4",
	  rlhar: "\u21CC",
	  rlm: "\u200F",
	  rmoust: "\u23B1",
	  rmoustache: "\u23B1",
	  rnmid: "\u2AEE",
	  roang: "\u27ED",
	  roarr: "\u21FE",
	  robrk: "\u27E7",
	  ropar: "\u2986",
	  ropf: "\u{1D563}",
	  roplus: "\u2A2E",
	  rotimes: "\u2A35",
	  rpar: ")",
	  rpargt: "\u2994",
	  rppolint: "\u2A12",
	  rrarr: "\u21C9",
	  rsaquo: "\u203A",
	  rscr: "\u{1D4C7}",
	  rsh: "\u21B1",
	  rsqb: "]",
	  rsquo: "\u2019",
	  rsquor: "\u2019",
	  rthree: "\u22CC",
	  rtimes: "\u22CA",
	  rtri: "\u25B9",
	  rtrie: "\u22B5",
	  rtrif: "\u25B8",
	  rtriltri: "\u29CE",
	  ruluhar: "\u2968",
	  rx: "\u211E",
	  sacute: "\u015B",
	  sbquo: "\u201A",
	  sc: "\u227B",
	  scE: "\u2AB4",
	  scap: "\u2AB8",
	  scaron: "\u0161",
	  sccue: "\u227D",
	  sce: "\u2AB0",
	  scedil: "\u015F",
	  scirc: "\u015D",
	  scnE: "\u2AB6",
	  scnap: "\u2ABA",
	  scnsim: "\u22E9",
	  scpolint: "\u2A13",
	  scsim: "\u227F",
	  scy: "\u0441",
	  sdot: "\u22C5",
	  sdotb: "\u22A1",
	  sdote: "\u2A66",
	  seArr: "\u21D8",
	  searhk: "\u2925",
	  searr: "\u2198",
	  searrow: "\u2198",
	  sect: "\xA7",
	  semi: ";",
	  seswar: "\u2929",
	  setminus: "\u2216",
	  setmn: "\u2216",
	  sext: "\u2736",
	  sfr: "\u{1D530}",
	  sfrown: "\u2322",
	  sharp: "\u266F",
	  shchcy: "\u0449",
	  shcy: "\u0448",
	  shortmid: "\u2223",
	  shortparallel: "\u2225",
	  shy: "\xAD",
	  sigma: "\u03C3",
	  sigmaf: "\u03C2",
	  sigmav: "\u03C2",
	  sim: "\u223C",
	  simdot: "\u2A6A",
	  sime: "\u2243",
	  simeq: "\u2243",
	  simg: "\u2A9E",
	  simgE: "\u2AA0",
	  siml: "\u2A9D",
	  simlE: "\u2A9F",
	  simne: "\u2246",
	  simplus: "\u2A24",
	  simrarr: "\u2972",
	  slarr: "\u2190",
	  smallsetminus: "\u2216",
	  smashp: "\u2A33",
	  smeparsl: "\u29E4",
	  smid: "\u2223",
	  smile: "\u2323",
	  smt: "\u2AAA",
	  smte: "\u2AAC",
	  smtes: "\u2AAC\uFE00",
	  softcy: "\u044C",
	  sol: "/",
	  solb: "\u29C4",
	  solbar: "\u233F",
	  sopf: "\u{1D564}",
	  spades: "\u2660",
	  spadesuit: "\u2660",
	  spar: "\u2225",
	  sqcap: "\u2293",
	  sqcaps: "\u2293\uFE00",
	  sqcup: "\u2294",
	  sqcups: "\u2294\uFE00",
	  sqsub: "\u228F",
	  sqsube: "\u2291",
	  sqsubset: "\u228F",
	  sqsubseteq: "\u2291",
	  sqsup: "\u2290",
	  sqsupe: "\u2292",
	  sqsupset: "\u2290",
	  sqsupseteq: "\u2292",
	  squ: "\u25A1",
	  square: "\u25A1",
	  squarf: "\u25AA",
	  squf: "\u25AA",
	  srarr: "\u2192",
	  sscr: "\u{1D4C8}",
	  ssetmn: "\u2216",
	  ssmile: "\u2323",
	  sstarf: "\u22C6",
	  star: "\u2606",
	  starf: "\u2605",
	  straightepsilon: "\u03F5",
	  straightphi: "\u03D5",
	  strns: "\xAF",
	  sub: "\u2282",
	  subE: "\u2AC5",
	  subdot: "\u2ABD",
	  sube: "\u2286",
	  subedot: "\u2AC3",
	  submult: "\u2AC1",
	  subnE: "\u2ACB",
	  subne: "\u228A",
	  subplus: "\u2ABF",
	  subrarr: "\u2979",
	  subset: "\u2282",
	  subseteq: "\u2286",
	  subseteqq: "\u2AC5",
	  subsetneq: "\u228A",
	  subsetneqq: "\u2ACB",
	  subsim: "\u2AC7",
	  subsub: "\u2AD5",
	  subsup: "\u2AD3",
	  succ: "\u227B",
	  succapprox: "\u2AB8",
	  succcurlyeq: "\u227D",
	  succeq: "\u2AB0",
	  succnapprox: "\u2ABA",
	  succneqq: "\u2AB6",
	  succnsim: "\u22E9",
	  succsim: "\u227F",
	  sum: "\u2211",
	  sung: "\u266A",
	  sup1: "\xB9",
	  sup2: "\xB2",
	  sup3: "\xB3",
	  sup: "\u2283",
	  supE: "\u2AC6",
	  supdot: "\u2ABE",
	  supdsub: "\u2AD8",
	  supe: "\u2287",
	  supedot: "\u2AC4",
	  suphsol: "\u27C9",
	  suphsub: "\u2AD7",
	  suplarr: "\u297B",
	  supmult: "\u2AC2",
	  supnE: "\u2ACC",
	  supne: "\u228B",
	  supplus: "\u2AC0",
	  supset: "\u2283",
	  supseteq: "\u2287",
	  supseteqq: "\u2AC6",
	  supsetneq: "\u228B",
	  supsetneqq: "\u2ACC",
	  supsim: "\u2AC8",
	  supsub: "\u2AD4",
	  supsup: "\u2AD6",
	  swArr: "\u21D9",
	  swarhk: "\u2926",
	  swarr: "\u2199",
	  swarrow: "\u2199",
	  swnwar: "\u292A",
	  szlig: "\xDF",
	  target: "\u2316",
	  tau: "\u03C4",
	  tbrk: "\u23B4",
	  tcaron: "\u0165",
	  tcedil: "\u0163",
	  tcy: "\u0442",
	  tdot: "\u20DB",
	  telrec: "\u2315",
	  tfr: "\u{1D531}",
	  there4: "\u2234",
	  therefore: "\u2234",
	  theta: "\u03B8",
	  thetasym: "\u03D1",
	  thetav: "\u03D1",
	  thickapprox: "\u2248",
	  thicksim: "\u223C",
	  thinsp: "\u2009",
	  thkap: "\u2248",
	  thksim: "\u223C",
	  thorn: "\xFE",
	  tilde: "\u02DC",
	  times: "\xD7",
	  timesb: "\u22A0",
	  timesbar: "\u2A31",
	  timesd: "\u2A30",
	  tint: "\u222D",
	  toea: "\u2928",
	  top: "\u22A4",
	  topbot: "\u2336",
	  topcir: "\u2AF1",
	  topf: "\u{1D565}",
	  topfork: "\u2ADA",
	  tosa: "\u2929",
	  tprime: "\u2034",
	  trade: "\u2122",
	  triangle: "\u25B5",
	  triangledown: "\u25BF",
	  triangleleft: "\u25C3",
	  trianglelefteq: "\u22B4",
	  triangleq: "\u225C",
	  triangleright: "\u25B9",
	  trianglerighteq: "\u22B5",
	  tridot: "\u25EC",
	  trie: "\u225C",
	  triminus: "\u2A3A",
	  triplus: "\u2A39",
	  trisb: "\u29CD",
	  tritime: "\u2A3B",
	  trpezium: "\u23E2",
	  tscr: "\u{1D4C9}",
	  tscy: "\u0446",
	  tshcy: "\u045B",
	  tstrok: "\u0167",
	  twixt: "\u226C",
	  twoheadleftarrow: "\u219E",
	  twoheadrightarrow: "\u21A0",
	  uArr: "\u21D1",
	  uHar: "\u2963",
	  uacute: "\xFA",
	  uarr: "\u2191",
	  ubrcy: "\u045E",
	  ubreve: "\u016D",
	  ucirc: "\xFB",
	  ucy: "\u0443",
	  udarr: "\u21C5",
	  udblac: "\u0171",
	  udhar: "\u296E",
	  ufisht: "\u297E",
	  ufr: "\u{1D532}",
	  ugrave: "\xF9",
	  uharl: "\u21BF",
	  uharr: "\u21BE",
	  uhblk: "\u2580",
	  ulcorn: "\u231C",
	  ulcorner: "\u231C",
	  ulcrop: "\u230F",
	  ultri: "\u25F8",
	  umacr: "\u016B",
	  uml: "\xA8",
	  uogon: "\u0173",
	  uopf: "\u{1D566}",
	  uparrow: "\u2191",
	  updownarrow: "\u2195",
	  upharpoonleft: "\u21BF",
	  upharpoonright: "\u21BE",
	  uplus: "\u228E",
	  upsi: "\u03C5",
	  upsih: "\u03D2",
	  upsilon: "\u03C5",
	  upuparrows: "\u21C8",
	  urcorn: "\u231D",
	  urcorner: "\u231D",
	  urcrop: "\u230E",
	  uring: "\u016F",
	  urtri: "\u25F9",
	  uscr: "\u{1D4CA}",
	  utdot: "\u22F0",
	  utilde: "\u0169",
	  utri: "\u25B5",
	  utrif: "\u25B4",
	  uuarr: "\u21C8",
	  uuml: "\xFC",
	  uwangle: "\u29A7",
	  vArr: "\u21D5",
	  vBar: "\u2AE8",
	  vBarv: "\u2AE9",
	  vDash: "\u22A8",
	  vangrt: "\u299C",
	  varepsilon: "\u03F5",
	  varkappa: "\u03F0",
	  varnothing: "\u2205",
	  varphi: "\u03D5",
	  varpi: "\u03D6",
	  varpropto: "\u221D",
	  varr: "\u2195",
	  varrho: "\u03F1",
	  varsigma: "\u03C2",
	  varsubsetneq: "\u228A\uFE00",
	  varsubsetneqq: "\u2ACB\uFE00",
	  varsupsetneq: "\u228B\uFE00",
	  varsupsetneqq: "\u2ACC\uFE00",
	  vartheta: "\u03D1",
	  vartriangleleft: "\u22B2",
	  vartriangleright: "\u22B3",
	  vcy: "\u0432",
	  vdash: "\u22A2",
	  vee: "\u2228",
	  veebar: "\u22BB",
	  veeeq: "\u225A",
	  vellip: "\u22EE",
	  verbar: "|",
	  vert: "|",
	  vfr: "\u{1D533}",
	  vltri: "\u22B2",
	  vnsub: "\u2282\u20D2",
	  vnsup: "\u2283\u20D2",
	  vopf: "\u{1D567}",
	  vprop: "\u221D",
	  vrtri: "\u22B3",
	  vscr: "\u{1D4CB}",
	  vsubnE: "\u2ACB\uFE00",
	  vsubne: "\u228A\uFE00",
	  vsupnE: "\u2ACC\uFE00",
	  vsupne: "\u228B\uFE00",
	  vzigzag: "\u299A",
	  wcirc: "\u0175",
	  wedbar: "\u2A5F",
	  wedge: "\u2227",
	  wedgeq: "\u2259",
	  weierp: "\u2118",
	  wfr: "\u{1D534}",
	  wopf: "\u{1D568}",
	  wp: "\u2118",
	  wr: "\u2240",
	  wreath: "\u2240",
	  wscr: "\u{1D4CC}",
	  xcap: "\u22C2",
	  xcirc: "\u25EF",
	  xcup: "\u22C3",
	  xdtri: "\u25BD",
	  xfr: "\u{1D535}",
	  xhArr: "\u27FA",
	  xharr: "\u27F7",
	  xi: "\u03BE",
	  xlArr: "\u27F8",
	  xlarr: "\u27F5",
	  xmap: "\u27FC",
	  xnis: "\u22FB",
	  xodot: "\u2A00",
	  xopf: "\u{1D569}",
	  xoplus: "\u2A01",
	  xotime: "\u2A02",
	  xrArr: "\u27F9",
	  xrarr: "\u27F6",
	  xscr: "\u{1D4CD}",
	  xsqcup: "\u2A06",
	  xuplus: "\u2A04",
	  xutri: "\u25B3",
	  xvee: "\u22C1",
	  xwedge: "\u22C0",
	  yacute: "\xFD",
	  yacy: "\u044F",
	  ycirc: "\u0177",
	  ycy: "\u044B",
	  yen: "\xA5",
	  yfr: "\u{1D536}",
	  yicy: "\u0457",
	  yopf: "\u{1D56A}",
	  yscr: "\u{1D4CE}",
	  yucy: "\u044E",
	  yuml: "\xFF",
	  zacute: "\u017A",
	  zcaron: "\u017E",
	  zcy: "\u0437",
	  zdot: "\u017C",
	  zeetrf: "\u2128",
	  zeta: "\u03B6",
	  zfr: "\u{1D537}",
	  zhcy: "\u0436",
	  zigrarr: "\u21DD",
	  zopf: "\u{1D56B}",
	  zscr: "\u{1D4CF}",
	  zwj: "\u200D",
	  zwnj: "\u200C"
	};

	// node_modules/.pnpm/decode-named-character-reference@1.2.0/node_modules/decode-named-character-reference/index.js
	var own = {}.hasOwnProperty;
	function decodeNamedCharacterReference(value) {
	  return own.call(characterEntities, value) ? characterEntities[value] : false;
	}

	// node_modules/.pnpm/micromark-util-chunked@2.0.1/node_modules/micromark-util-chunked/index.js
	function splice(list3, start, remove, items) {
	  const end = list3.length;
	  let chunkStart = 0;
	  let parameters;
	  if (start < 0) {
	    start = -start > end ? 0 : end + start;
	  } else {
	    start = start > end ? end : start;
	  }
	  remove = remove > 0 ? remove : 0;
	  if (items.length < 1e4) {
	    parameters = Array.from(items);
	    parameters.unshift(start, remove);
	    list3.splice(...parameters);
	  } else {
	    if (remove) list3.splice(start, remove);
	    while (chunkStart < items.length) {
	      parameters = items.slice(chunkStart, chunkStart + 1e4);
	      parameters.unshift(start, 0);
	      list3.splice(...parameters);
	      chunkStart += 1e4;
	      start += 1e4;
	    }
	  }
	}
	function push(list3, items) {
	  if (list3.length > 0) {
	    splice(list3, list3.length, 0, items);
	    return list3;
	  }
	  return items;
	}

	// node_modules/.pnpm/micromark-util-combine-extensions@2.0.1/node_modules/micromark-util-combine-extensions/index.js
	var hasOwnProperty = {}.hasOwnProperty;
	function combineExtensions(extensions) {
	  const all2 = {};
	  let index2 = -1;
	  while (++index2 < extensions.length) {
	    syntaxExtension(all2, extensions[index2]);
	  }
	  return all2;
	}
	function syntaxExtension(all2, extension2) {
	  let hook;
	  for (hook in extension2) {
	    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
	    const left = maybe || (all2[hook] = {});
	    const right = extension2[hook];
	    let code2;
	    if (right) {
	      for (code2 in right) {
	        if (!hasOwnProperty.call(left, code2)) left[code2] = [];
	        const value = right[code2];
	        constructs(
	          // @ts-expect-error Looks like a list.
	          left[code2],
	          Array.isArray(value) ? value : value ? [value] : []
	        );
	      }
	    }
	  }
	}
	function constructs(existing, list3) {
	  let index2 = -1;
	  const before = [];
	  while (++index2 < list3.length) {
	    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
	  }
	  splice(existing, 0, 0, before);
	}

	// node_modules/.pnpm/micromark-util-decode-numeric-character-reference@2.0.2/node_modules/micromark-util-decode-numeric-character-reference/index.js
	function decodeNumericCharacterReference(value, base) {
	  const code2 = Number.parseInt(value, base);
	  if (
	    // C0 except for HT, LF, FF, CR, space.
	    code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of C0, and C1 controls.
	    code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
	    code2 > 55295 && code2 < 57344 || // Noncharacters.
	    code2 > 64975 && code2 < 65008 || /* eslint-disable no-bitwise */
	    (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || /* eslint-enable no-bitwise */
	    // Out of range
	    code2 > 1114111
	  ) {
	    return "\uFFFD";
	  }
	  return String.fromCodePoint(code2);
	}

	// node_modules/.pnpm/micromark-util-normalize-identifier@2.0.1/node_modules/micromark-util-normalize-identifier/index.js
	function normalizeIdentifier(value) {
	  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
	}

	// node_modules/.pnpm/micromark-util-character@2.1.1/node_modules/micromark-util-character/index.js
	var asciiAlpha = regexCheck(/[A-Za-z]/);
	var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
	var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
	function asciiControl(code2) {
	  return (
	    // Special whitespace codes (which have negative values), C0 and Control
	    // character DEL
	    code2 !== null && (code2 < 32 || code2 === 127)
	  );
	}
	var asciiDigit = regexCheck(/\d/);
	var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
	var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
	function markdownLineEnding(code2) {
	  return code2 !== null && code2 < -2;
	}
	function markdownLineEndingOrSpace(code2) {
	  return code2 !== null && (code2 < 0 || code2 === 32);
	}
	function markdownSpace(code2) {
	  return code2 === -2 || code2 === -1 || code2 === 32;
	}
	var unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
	var unicodeWhitespace = regexCheck(/\s/);
	function regexCheck(regex) {
	  return check;
	  function check(code2) {
	    return code2 !== null && code2 > -1 && regex.test(String.fromCharCode(code2));
	  }
	}

	// node_modules/.pnpm/micromark-util-sanitize-uri@2.0.1/node_modules/micromark-util-sanitize-uri/index.js
	function normalizeUri(value) {
	  const result = [];
	  let index2 = -1;
	  let start = 0;
	  let skip = 0;
	  while (++index2 < value.length) {
	    const code2 = value.charCodeAt(index2);
	    let replace = "";
	    if (code2 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
	      skip = 2;
	    } else if (code2 < 128) {
	      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
	        replace = String.fromCharCode(code2);
	      }
	    } else if (code2 > 55295 && code2 < 57344) {
	      const next = value.charCodeAt(index2 + 1);
	      if (code2 < 56320 && next > 56319 && next < 57344) {
	        replace = String.fromCharCode(code2, next);
	        skip = 1;
	      } else {
	        replace = "\uFFFD";
	      }
	    } else {
	      replace = String.fromCharCode(code2);
	    }
	    if (replace) {
	      result.push(value.slice(start, index2), encodeURIComponent(replace));
	      start = index2 + skip + 1;
	      replace = "";
	    }
	    if (skip) {
	      index2 += skip;
	      skip = 0;
	    }
	  }
	  return result.join("") + value.slice(start);
	}

	// node_modules/.pnpm/micromark-factory-space@2.0.1/node_modules/micromark-factory-space/index.js
	function factorySpace(effects, ok3, type, max) {
	  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
	  let size = 0;
	  return start;
	  function start(code2) {
	    if (markdownSpace(code2)) {
	      effects.enter(type);
	      return prefix(code2);
	    }
	    return ok3(code2);
	  }
	  function prefix(code2) {
	    if (markdownSpace(code2) && size++ < limit) {
	      effects.consume(code2);
	      return prefix;
	    }
	    effects.exit(type);
	    return ok3(code2);
	  }
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/initialize/content.js
	var content = {
	  tokenize: initializeContent
	};
	function initializeContent(effects) {
	  const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
	  let previous2;
	  return contentStart;
	  function afterContentStartConstruct(code2) {
	    if (code2 === null) {
	      effects.consume(code2);
	      return;
	    }
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return factorySpace(effects, contentStart, "linePrefix");
	  }
	  function paragraphInitial(code2) {
	    effects.enter("paragraph");
	    return lineStart(code2);
	  }
	  function lineStart(code2) {
	    const token = effects.enter("chunkText", {
	      contentType: "text",
	      previous: previous2
	    });
	    if (previous2) {
	      previous2.next = token;
	    }
	    previous2 = token;
	    return data(code2);
	  }
	  function data(code2) {
	    if (code2 === null) {
	      effects.exit("chunkText");
	      effects.exit("paragraph");
	      effects.consume(code2);
	      return;
	    }
	    if (markdownLineEnding(code2)) {
	      effects.consume(code2);
	      effects.exit("chunkText");
	      return lineStart;
	    }
	    effects.consume(code2);
	    return data;
	  }
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/initialize/document.js
	var document$1 = {
	  tokenize: initializeDocument
	};
	var containerConstruct = {
	  tokenize: tokenizeContainer
	};
	function initializeDocument(effects) {
	  const self2 = this;
	  const stack = [];
	  let continued = 0;
	  let childFlow;
	  let childToken;
	  let lineStartOffset;
	  return start;
	  function start(code2) {
	    if (continued < stack.length) {
	      const item = stack[continued];
	      self2.containerState = item[1];
	      return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code2);
	    }
	    return checkNewContainers(code2);
	  }
	  function documentContinue(code2) {
	    continued++;
	    if (self2.containerState._closeFlow) {
	      self2.containerState._closeFlow = void 0;
	      if (childFlow) {
	        closeFlow();
	      }
	      const indexBeforeExits = self2.events.length;
	      let indexBeforeFlow = indexBeforeExits;
	      let point4;
	      while (indexBeforeFlow--) {
	        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
	          point4 = self2.events[indexBeforeFlow][1].end;
	          break;
	        }
	      }
	      exitContainers(continued);
	      let index2 = indexBeforeExits;
	      while (index2 < self2.events.length) {
	        self2.events[index2][1].end = {
	          ...point4
	        };
	        index2++;
	      }
	      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
	      self2.events.length = index2;
	      return checkNewContainers(code2);
	    }
	    return start(code2);
	  }
	  function checkNewContainers(code2) {
	    if (continued === stack.length) {
	      if (!childFlow) {
	        return documentContinued(code2);
	      }
	      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
	        return flowStart(code2);
	      }
	      self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
	    }
	    self2.containerState = {};
	    return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code2);
	  }
	  function thereIsANewContainer(code2) {
	    if (childFlow) closeFlow();
	    exitContainers(continued);
	    return documentContinued(code2);
	  }
	  function thereIsNoNewContainer(code2) {
	    self2.parser.lazy[self2.now().line] = continued !== stack.length;
	    lineStartOffset = self2.now().offset;
	    return flowStart(code2);
	  }
	  function documentContinued(code2) {
	    self2.containerState = {};
	    return effects.attempt(containerConstruct, containerContinue, flowStart)(code2);
	  }
	  function containerContinue(code2) {
	    continued++;
	    stack.push([self2.currentConstruct, self2.containerState]);
	    return documentContinued(code2);
	  }
	  function flowStart(code2) {
	    if (code2 === null) {
	      if (childFlow) closeFlow();
	      exitContainers(0);
	      effects.consume(code2);
	      return;
	    }
	    childFlow = childFlow || self2.parser.flow(self2.now());
	    effects.enter("chunkFlow", {
	      _tokenizer: childFlow,
	      contentType: "flow",
	      previous: childToken
	    });
	    return flowContinue(code2);
	  }
	  function flowContinue(code2) {
	    if (code2 === null) {
	      writeToChild(effects.exit("chunkFlow"), true);
	      exitContainers(0);
	      effects.consume(code2);
	      return;
	    }
	    if (markdownLineEnding(code2)) {
	      effects.consume(code2);
	      writeToChild(effects.exit("chunkFlow"));
	      continued = 0;
	      self2.interrupt = void 0;
	      return start;
	    }
	    effects.consume(code2);
	    return flowContinue;
	  }
	  function writeToChild(token, endOfFile) {
	    const stream = self2.sliceStream(token);
	    if (endOfFile) stream.push(null);
	    token.previous = childToken;
	    if (childToken) childToken.next = token;
	    childToken = token;
	    childFlow.defineSkip(token.start);
	    childFlow.write(stream);
	    if (self2.parser.lazy[token.start.line]) {
	      let index2 = childFlow.events.length;
	      while (index2--) {
	        if (
	          // The token starts before the line ending…
	          childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
	          (!childFlow.events[index2][1].end || // …or ends after it.
	          childFlow.events[index2][1].end.offset > lineStartOffset)
	        ) {
	          return;
	        }
	      }
	      const indexBeforeExits = self2.events.length;
	      let indexBeforeFlow = indexBeforeExits;
	      let seen;
	      let point4;
	      while (indexBeforeFlow--) {
	        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
	          if (seen) {
	            point4 = self2.events[indexBeforeFlow][1].end;
	            break;
	          }
	          seen = true;
	        }
	      }
	      exitContainers(continued);
	      index2 = indexBeforeExits;
	      while (index2 < self2.events.length) {
	        self2.events[index2][1].end = {
	          ...point4
	        };
	        index2++;
	      }
	      splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
	      self2.events.length = index2;
	    }
	  }
	  function exitContainers(size) {
	    let index2 = stack.length;
	    while (index2-- > size) {
	      const entry = stack[index2];
	      self2.containerState = entry[1];
	      entry[0].exit.call(self2, effects);
	    }
	    stack.length = size;
	  }
	  function closeFlow() {
	    childFlow.write([null]);
	    childToken = void 0;
	    childFlow = void 0;
	    self2.containerState._closeFlow = void 0;
	  }
	}
	function tokenizeContainer(effects, ok3, nok) {
	  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
	}

	// node_modules/.pnpm/micromark-util-classify-character@2.0.1/node_modules/micromark-util-classify-character/index.js
	function classifyCharacter(code2) {
	  if (code2 === null || markdownLineEndingOrSpace(code2) || unicodeWhitespace(code2)) {
	    return 1;
	  }
	  if (unicodePunctuation(code2)) {
	    return 2;
	  }
	}

	// node_modules/.pnpm/micromark-util-resolve-all@2.0.1/node_modules/micromark-util-resolve-all/index.js
	function resolveAll(constructs2, events, context) {
	  const called = [];
	  let index2 = -1;
	  while (++index2 < constructs2.length) {
	    const resolve = constructs2[index2].resolveAll;
	    if (resolve && !called.includes(resolve)) {
	      events = resolve(events, context);
	      called.push(resolve);
	    }
	  }
	  return events;
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/attention.js
	var attention = {
	  name: "attention",
	  resolveAll: resolveAllAttention,
	  tokenize: tokenizeAttention
	};
	function resolveAllAttention(events, context) {
	  let index2 = -1;
	  let open;
	  let group;
	  let text4;
	  let openingSequence;
	  let closingSequence;
	  let use;
	  let nextEvents;
	  let offset;
	  while (++index2 < events.length) {
	    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
	      open = index2;
	      while (open--) {
	        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
	        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
	          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
	            continue;
	          }
	          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
	          const start = {
	            ...events[open][1].end
	          };
	          const end = {
	            ...events[index2][1].start
	          };
	          movePoint(start, -use);
	          movePoint(end, use);
	          openingSequence = {
	            type: use > 1 ? "strongSequence" : "emphasisSequence",
	            start,
	            end: {
	              ...events[open][1].end
	            }
	          };
	          closingSequence = {
	            type: use > 1 ? "strongSequence" : "emphasisSequence",
	            start: {
	              ...events[index2][1].start
	            },
	            end
	          };
	          text4 = {
	            type: use > 1 ? "strongText" : "emphasisText",
	            start: {
	              ...events[open][1].end
	            },
	            end: {
	              ...events[index2][1].start
	            }
	          };
	          group = {
	            type: use > 1 ? "strong" : "emphasis",
	            start: {
	              ...openingSequence.start
	            },
	            end: {
	              ...closingSequence.end
	            }
	          };
	          events[open][1].end = {
	            ...openingSequence.start
	          };
	          events[index2][1].start = {
	            ...closingSequence.end
	          };
	          nextEvents = [];
	          if (events[open][1].end.offset - events[open][1].start.offset) {
	            nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
	          }
	          nextEvents = push(nextEvents, [["enter", group, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text4, context]]);
	          nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context));
	          nextEvents = push(nextEvents, [["exit", text4, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group, context]]);
	          if (events[index2][1].end.offset - events[index2][1].start.offset) {
	            offset = 2;
	            nextEvents = push(nextEvents, [["enter", events[index2][1], context], ["exit", events[index2][1], context]]);
	          } else {
	            offset = 0;
	          }
	          splice(events, open - 1, index2 - open + 3, nextEvents);
	          index2 = open + nextEvents.length - offset - 2;
	          break;
	        }
	      }
	    }
	  }
	  index2 = -1;
	  while (++index2 < events.length) {
	    if (events[index2][1].type === "attentionSequence") {
	      events[index2][1].type = "data";
	    }
	  }
	  return events;
	}
	function tokenizeAttention(effects, ok3) {
	  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
	  const previous2 = this.previous;
	  const before = classifyCharacter(previous2);
	  let marker;
	  return start;
	  function start(code2) {
	    marker = code2;
	    effects.enter("attentionSequence");
	    return inside(code2);
	  }
	  function inside(code2) {
	    if (code2 === marker) {
	      effects.consume(code2);
	      return inside;
	    }
	    const token = effects.exit("attentionSequence");
	    const after = classifyCharacter(code2);
	    const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
	    const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
	    token._open = Boolean(marker === 42 ? open : open && (before || !close));
	    token._close = Boolean(marker === 42 ? close : close && (after || !open));
	    return ok3(code2);
	  }
	}
	function movePoint(point4, offset) {
	  point4.column += offset;
	  point4.offset += offset;
	  point4._bufferIndex += offset;
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/autolink.js
	var autolink = {
	  name: "autolink",
	  tokenize: tokenizeAutolink
	};
	function tokenizeAutolink(effects, ok3, nok) {
	  let size = 0;
	  return start;
	  function start(code2) {
	    effects.enter("autolink");
	    effects.enter("autolinkMarker");
	    effects.consume(code2);
	    effects.exit("autolinkMarker");
	    effects.enter("autolinkProtocol");
	    return open;
	  }
	  function open(code2) {
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      return schemeOrEmailAtext;
	    }
	    if (code2 === 64) {
	      return nok(code2);
	    }
	    return emailAtext(code2);
	  }
	  function schemeOrEmailAtext(code2) {
	    if (code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) {
	      size = 1;
	      return schemeInsideOrEmailAtext(code2);
	    }
	    return emailAtext(code2);
	  }
	  function schemeInsideOrEmailAtext(code2) {
	    if (code2 === 58) {
	      effects.consume(code2);
	      size = 0;
	      return urlInside;
	    }
	    if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric(code2)) && size++ < 32) {
	      effects.consume(code2);
	      return schemeInsideOrEmailAtext;
	    }
	    size = 0;
	    return emailAtext(code2);
	  }
	  function urlInside(code2) {
	    if (code2 === 62) {
	      effects.exit("autolinkProtocol");
	      effects.enter("autolinkMarker");
	      effects.consume(code2);
	      effects.exit("autolinkMarker");
	      effects.exit("autolink");
	      return ok3;
	    }
	    if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
	      return nok(code2);
	    }
	    effects.consume(code2);
	    return urlInside;
	  }
	  function emailAtext(code2) {
	    if (code2 === 64) {
	      effects.consume(code2);
	      return emailAtSignOrDot;
	    }
	    if (asciiAtext(code2)) {
	      effects.consume(code2);
	      return emailAtext;
	    }
	    return nok(code2);
	  }
	  function emailAtSignOrDot(code2) {
	    return asciiAlphanumeric(code2) ? emailLabel(code2) : nok(code2);
	  }
	  function emailLabel(code2) {
	    if (code2 === 46) {
	      effects.consume(code2);
	      size = 0;
	      return emailAtSignOrDot;
	    }
	    if (code2 === 62) {
	      effects.exit("autolinkProtocol").type = "autolinkEmail";
	      effects.enter("autolinkMarker");
	      effects.consume(code2);
	      effects.exit("autolinkMarker");
	      effects.exit("autolink");
	      return ok3;
	    }
	    return emailValue(code2);
	  }
	  function emailValue(code2) {
	    if ((code2 === 45 || asciiAlphanumeric(code2)) && size++ < 63) {
	      const next = code2 === 45 ? emailValue : emailLabel;
	      effects.consume(code2);
	      return next;
	    }
	    return nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/blank-line.js
	var blankLine = {
	  partial: true,
	  tokenize: tokenizeBlankLine
	};
	function tokenizeBlankLine(effects, ok3, nok) {
	  return start;
	  function start(code2) {
	    return markdownSpace(code2) ? factorySpace(effects, after, "linePrefix")(code2) : after(code2);
	  }
	  function after(code2) {
	    return code2 === null || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/block-quote.js
	var blockQuote = {
	  continuation: {
	    tokenize: tokenizeBlockQuoteContinuation
	  },
	  exit,
	  name: "blockQuote",
	  tokenize: tokenizeBlockQuoteStart
	};
	function tokenizeBlockQuoteStart(effects, ok3, nok) {
	  const self2 = this;
	  return start;
	  function start(code2) {
	    if (code2 === 62) {
	      const state = self2.containerState;
	      if (!state.open) {
	        effects.enter("blockQuote", {
	          _container: true
	        });
	        state.open = true;
	      }
	      effects.enter("blockQuotePrefix");
	      effects.enter("blockQuoteMarker");
	      effects.consume(code2);
	      effects.exit("blockQuoteMarker");
	      return after;
	    }
	    return nok(code2);
	  }
	  function after(code2) {
	    if (markdownSpace(code2)) {
	      effects.enter("blockQuotePrefixWhitespace");
	      effects.consume(code2);
	      effects.exit("blockQuotePrefixWhitespace");
	      effects.exit("blockQuotePrefix");
	      return ok3;
	    }
	    effects.exit("blockQuotePrefix");
	    return ok3(code2);
	  }
	}
	function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
	  const self2 = this;
	  return contStart;
	  function contStart(code2) {
	    if (markdownSpace(code2)) {
	      return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
	    }
	    return contBefore(code2);
	  }
	  function contBefore(code2) {
	    return effects.attempt(blockQuote, ok3, nok)(code2);
	  }
	}
	function exit(effects) {
	  effects.exit("blockQuote");
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/character-escape.js
	var characterEscape = {
	  name: "characterEscape",
	  tokenize: tokenizeCharacterEscape
	};
	function tokenizeCharacterEscape(effects, ok3, nok) {
	  return start;
	  function start(code2) {
	    effects.enter("characterEscape");
	    effects.enter("escapeMarker");
	    effects.consume(code2);
	    effects.exit("escapeMarker");
	    return inside;
	  }
	  function inside(code2) {
	    if (asciiPunctuation(code2)) {
	      effects.enter("characterEscapeValue");
	      effects.consume(code2);
	      effects.exit("characterEscapeValue");
	      effects.exit("characterEscape");
	      return ok3;
	    }
	    return nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/character-reference.js
	var characterReference = {
	  name: "characterReference",
	  tokenize: tokenizeCharacterReference
	};
	function tokenizeCharacterReference(effects, ok3, nok) {
	  const self2 = this;
	  let size = 0;
	  let max;
	  let test;
	  return start;
	  function start(code2) {
	    effects.enter("characterReference");
	    effects.enter("characterReferenceMarker");
	    effects.consume(code2);
	    effects.exit("characterReferenceMarker");
	    return open;
	  }
	  function open(code2) {
	    if (code2 === 35) {
	      effects.enter("characterReferenceMarkerNumeric");
	      effects.consume(code2);
	      effects.exit("characterReferenceMarkerNumeric");
	      return numeric;
	    }
	    effects.enter("characterReferenceValue");
	    max = 31;
	    test = asciiAlphanumeric;
	    return value(code2);
	  }
	  function numeric(code2) {
	    if (code2 === 88 || code2 === 120) {
	      effects.enter("characterReferenceMarkerHexadecimal");
	      effects.consume(code2);
	      effects.exit("characterReferenceMarkerHexadecimal");
	      effects.enter("characterReferenceValue");
	      max = 6;
	      test = asciiHexDigit;
	      return value;
	    }
	    effects.enter("characterReferenceValue");
	    max = 7;
	    test = asciiDigit;
	    return value(code2);
	  }
	  function value(code2) {
	    if (code2 === 59 && size) {
	      const token = effects.exit("characterReferenceValue");
	      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
	        return nok(code2);
	      }
	      effects.enter("characterReferenceMarker");
	      effects.consume(code2);
	      effects.exit("characterReferenceMarker");
	      effects.exit("characterReference");
	      return ok3;
	    }
	    if (test(code2) && size++ < max) {
	      effects.consume(code2);
	      return value;
	    }
	    return nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/code-fenced.js
	var nonLazyContinuation = {
	  partial: true,
	  tokenize: tokenizeNonLazyContinuation
	};
	var codeFenced = {
	  concrete: true,
	  name: "codeFenced",
	  tokenize: tokenizeCodeFenced
	};
	function tokenizeCodeFenced(effects, ok3, nok) {
	  const self2 = this;
	  const closeStart = {
	    partial: true,
	    tokenize: tokenizeCloseStart
	  };
	  let initialPrefix = 0;
	  let sizeOpen = 0;
	  let marker;
	  return start;
	  function start(code2) {
	    return beforeSequenceOpen(code2);
	  }
	  function beforeSequenceOpen(code2) {
	    const tail = self2.events[self2.events.length - 1];
	    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
	    marker = code2;
	    effects.enter("codeFenced");
	    effects.enter("codeFencedFence");
	    effects.enter("codeFencedFenceSequence");
	    return sequenceOpen(code2);
	  }
	  function sequenceOpen(code2) {
	    if (code2 === marker) {
	      sizeOpen++;
	      effects.consume(code2);
	      return sequenceOpen;
	    }
	    if (sizeOpen < 3) {
	      return nok(code2);
	    }
	    effects.exit("codeFencedFenceSequence");
	    return markdownSpace(code2) ? factorySpace(effects, infoBefore, "whitespace")(code2) : infoBefore(code2);
	  }
	  function infoBefore(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("codeFencedFence");
	      return self2.interrupt ? ok3(code2) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
	    }
	    effects.enter("codeFencedFenceInfo");
	    effects.enter("chunkString", {
	      contentType: "string"
	    });
	    return info(code2);
	  }
	  function info(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("chunkString");
	      effects.exit("codeFencedFenceInfo");
	      return infoBefore(code2);
	    }
	    if (markdownSpace(code2)) {
	      effects.exit("chunkString");
	      effects.exit("codeFencedFenceInfo");
	      return factorySpace(effects, metaBefore, "whitespace")(code2);
	    }
	    if (code2 === 96 && code2 === marker) {
	      return nok(code2);
	    }
	    effects.consume(code2);
	    return info;
	  }
	  function metaBefore(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      return infoBefore(code2);
	    }
	    effects.enter("codeFencedFenceMeta");
	    effects.enter("chunkString", {
	      contentType: "string"
	    });
	    return meta(code2);
	  }
	  function meta(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("chunkString");
	      effects.exit("codeFencedFenceMeta");
	      return infoBefore(code2);
	    }
	    if (code2 === 96 && code2 === marker) {
	      return nok(code2);
	    }
	    effects.consume(code2);
	    return meta;
	  }
	  function atNonLazyBreak(code2) {
	    return effects.attempt(closeStart, after, contentBefore)(code2);
	  }
	  function contentBefore(code2) {
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return contentStart;
	  }
	  function contentStart(code2) {
	    return initialPrefix > 0 && markdownSpace(code2) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code2) : beforeContentChunk(code2);
	  }
	  function beforeContentChunk(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code2);
	    }
	    effects.enter("codeFlowValue");
	    return contentChunk(code2);
	  }
	  function contentChunk(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("codeFlowValue");
	      return beforeContentChunk(code2);
	    }
	    effects.consume(code2);
	    return contentChunk;
	  }
	  function after(code2) {
	    effects.exit("codeFenced");
	    return ok3(code2);
	  }
	  function tokenizeCloseStart(effects2, ok4, nok2) {
	    let size = 0;
	    return startBefore;
	    function startBefore(code2) {
	      effects2.enter("lineEnding");
	      effects2.consume(code2);
	      effects2.exit("lineEnding");
	      return start2;
	    }
	    function start2(code2) {
	      effects2.enter("codeFencedFence");
	      return markdownSpace(code2) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : beforeSequenceClose(code2);
	    }
	    function beforeSequenceClose(code2) {
	      if (code2 === marker) {
	        effects2.enter("codeFencedFenceSequence");
	        return sequenceClose(code2);
	      }
	      return nok2(code2);
	    }
	    function sequenceClose(code2) {
	      if (code2 === marker) {
	        size++;
	        effects2.consume(code2);
	        return sequenceClose;
	      }
	      if (size >= sizeOpen) {
	        effects2.exit("codeFencedFenceSequence");
	        return markdownSpace(code2) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code2) : sequenceCloseAfter(code2);
	      }
	      return nok2(code2);
	    }
	    function sequenceCloseAfter(code2) {
	      if (code2 === null || markdownLineEnding(code2)) {
	        effects2.exit("codeFencedFence");
	        return ok4(code2);
	      }
	      return nok2(code2);
	    }
	  }
	}
	function tokenizeNonLazyContinuation(effects, ok3, nok) {
	  const self2 = this;
	  return start;
	  function start(code2) {
	    if (code2 === null) {
	      return nok(code2);
	    }
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return lineStart;
	  }
	  function lineStart(code2) {
	    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/code-indented.js
	var codeIndented = {
	  name: "codeIndented",
	  tokenize: tokenizeCodeIndented
	};
	var furtherStart = {
	  partial: true,
	  tokenize: tokenizeFurtherStart
	};
	function tokenizeCodeIndented(effects, ok3, nok) {
	  const self2 = this;
	  return start;
	  function start(code2) {
	    effects.enter("codeIndented");
	    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
	  }
	  function afterPrefix(code2) {
	    const tail = self2.events[self2.events.length - 1];
	    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code2) : nok(code2);
	  }
	  function atBreak(code2) {
	    if (code2 === null) {
	      return after(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      return effects.attempt(furtherStart, atBreak, after)(code2);
	    }
	    effects.enter("codeFlowValue");
	    return inside(code2);
	  }
	  function inside(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("codeFlowValue");
	      return atBreak(code2);
	    }
	    effects.consume(code2);
	    return inside;
	  }
	  function after(code2) {
	    effects.exit("codeIndented");
	    return ok3(code2);
	  }
	}
	function tokenizeFurtherStart(effects, ok3, nok) {
	  const self2 = this;
	  return furtherStart2;
	  function furtherStart2(code2) {
	    if (self2.parser.lazy[self2.now().line]) {
	      return nok(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      effects.enter("lineEnding");
	      effects.consume(code2);
	      effects.exit("lineEnding");
	      return furtherStart2;
	    }
	    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
	  }
	  function afterPrefix(code2) {
	    const tail = self2.events[self2.events.length - 1];
	    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code2) : markdownLineEnding(code2) ? furtherStart2(code2) : nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/code-text.js
	var codeText = {
	  name: "codeText",
	  previous,
	  resolve: resolveCodeText,
	  tokenize: tokenizeCodeText
	};
	function resolveCodeText(events) {
	  let tailExitIndex = events.length - 4;
	  let headEnterIndex = 3;
	  let index2;
	  let enter;
	  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
	    index2 = headEnterIndex;
	    while (++index2 < tailExitIndex) {
	      if (events[index2][1].type === "codeTextData") {
	        events[headEnterIndex][1].type = "codeTextPadding";
	        events[tailExitIndex][1].type = "codeTextPadding";
	        headEnterIndex += 2;
	        tailExitIndex -= 2;
	        break;
	      }
	    }
	  }
	  index2 = headEnterIndex - 1;
	  tailExitIndex++;
	  while (++index2 <= tailExitIndex) {
	    if (enter === void 0) {
	      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
	        enter = index2;
	      }
	    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
	      events[enter][1].type = "codeTextData";
	      if (index2 !== enter + 2) {
	        events[enter][1].end = events[index2 - 1][1].end;
	        events.splice(enter + 2, index2 - enter - 2);
	        tailExitIndex -= index2 - enter - 2;
	        index2 = enter + 2;
	      }
	      enter = void 0;
	    }
	  }
	  return events;
	}
	function previous(code2) {
	  return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
	}
	function tokenizeCodeText(effects, ok3, nok) {
	  let sizeOpen = 0;
	  let size;
	  let token;
	  return start;
	  function start(code2) {
	    effects.enter("codeText");
	    effects.enter("codeTextSequence");
	    return sequenceOpen(code2);
	  }
	  function sequenceOpen(code2) {
	    if (code2 === 96) {
	      effects.consume(code2);
	      sizeOpen++;
	      return sequenceOpen;
	    }
	    effects.exit("codeTextSequence");
	    return between(code2);
	  }
	  function between(code2) {
	    if (code2 === null) {
	      return nok(code2);
	    }
	    if (code2 === 32) {
	      effects.enter("space");
	      effects.consume(code2);
	      effects.exit("space");
	      return between;
	    }
	    if (code2 === 96) {
	      token = effects.enter("codeTextSequence");
	      size = 0;
	      return sequenceClose(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      effects.enter("lineEnding");
	      effects.consume(code2);
	      effects.exit("lineEnding");
	      return between;
	    }
	    effects.enter("codeTextData");
	    return data(code2);
	  }
	  function data(code2) {
	    if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
	      effects.exit("codeTextData");
	      return between(code2);
	    }
	    effects.consume(code2);
	    return data;
	  }
	  function sequenceClose(code2) {
	    if (code2 === 96) {
	      effects.consume(code2);
	      size++;
	      return sequenceClose;
	    }
	    if (size === sizeOpen) {
	      effects.exit("codeTextSequence");
	      effects.exit("codeText");
	      return ok3(code2);
	    }
	    token.type = "codeTextData";
	    return data(code2);
	  }
	}

	// node_modules/.pnpm/micromark-util-subtokenize@2.1.0/node_modules/micromark-util-subtokenize/lib/splice-buffer.js
	var SpliceBuffer = class {
	  /**
	   * @param {ReadonlyArray<T> | null | undefined} [initial]
	   *   Initial items (optional).
	   * @returns
	   *   Splice buffer.
	   */
	  constructor(initial) {
	    this.left = initial ? [...initial] : [];
	    this.right = [];
	  }
	  /**
	   * Array access;
	   * does not move the cursor.
	   *
	   * @param {number} index
	   *   Index.
	   * @return {T}
	   *   Item.
	   */
	  get(index2) {
	    if (index2 < 0 || index2 >= this.left.length + this.right.length) {
	      throw new RangeError("Cannot access index `" + index2 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
	    }
	    if (index2 < this.left.length) return this.left[index2];
	    return this.right[this.right.length - index2 + this.left.length - 1];
	  }
	  /**
	   * The length of the splice buffer, one greater than the largest index in the
	   * array.
	   */
	  get length() {
	    return this.left.length + this.right.length;
	  }
	  /**
	   * Remove and return `list[0]`;
	   * moves the cursor to `0`.
	   *
	   * @returns {T | undefined}
	   *   Item, optional.
	   */
	  shift() {
	    this.setCursor(0);
	    return this.right.pop();
	  }
	  /**
	   * Slice the buffer to get an array;
	   * does not move the cursor.
	   *
	   * @param {number} start
	   *   Start.
	   * @param {number | null | undefined} [end]
	   *   End (optional).
	   * @returns {Array<T>}
	   *   Array of items.
	   */
	  slice(start, end) {
	    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
	    if (stop < this.left.length) {
	      return this.left.slice(start, stop);
	    }
	    if (start > this.left.length) {
	      return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
	    }
	    return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
	  }
	  /**
	   * Mimics the behavior of Array.prototype.splice() except for the change of
	   * interface necessary to avoid segfaults when patching in very large arrays.
	   *
	   * This operation moves cursor is moved to `start` and results in the cursor
	   * placed after any inserted items.
	   *
	   * @param {number} start
	   *   Start;
	   *   zero-based index at which to start changing the array;
	   *   negative numbers count backwards from the end of the array and values
	   *   that are out-of bounds are clamped to the appropriate end of the array.
	   * @param {number | null | undefined} [deleteCount=0]
	   *   Delete count (default: `0`);
	   *   maximum number of elements to delete, starting from start.
	   * @param {Array<T> | null | undefined} [items=[]]
	   *   Items to include in place of the deleted items (default: `[]`).
	   * @return {Array<T>}
	   *   Any removed items.
	   */
	  splice(start, deleteCount, items) {
	    const count = deleteCount || 0;
	    this.setCursor(Math.trunc(start));
	    const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
	    if (items) chunkedPush(this.left, items);
	    return removed.reverse();
	  }
	  /**
	   * Remove and return the highest-numbered item in the array, so
	   * `list[list.length - 1]`;
	   * Moves the cursor to `length`.
	   *
	   * @returns {T | undefined}
	   *   Item, optional.
	   */
	  pop() {
	    this.setCursor(Number.POSITIVE_INFINITY);
	    return this.left.pop();
	  }
	  /**
	   * Inserts a single item to the high-numbered side of the array;
	   * moves the cursor to `length`.
	   *
	   * @param {T} item
	   *   Item.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  push(item) {
	    this.setCursor(Number.POSITIVE_INFINITY);
	    this.left.push(item);
	  }
	  /**
	   * Inserts many items to the high-numbered side of the array.
	   * Moves the cursor to `length`.
	   *
	   * @param {Array<T>} items
	   *   Items.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  pushMany(items) {
	    this.setCursor(Number.POSITIVE_INFINITY);
	    chunkedPush(this.left, items);
	  }
	  /**
	   * Inserts a single item to the low-numbered side of the array;
	   * Moves the cursor to `0`.
	   *
	   * @param {T} item
	   *   Item.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  unshift(item) {
	    this.setCursor(0);
	    this.right.push(item);
	  }
	  /**
	   * Inserts many items to the low-numbered side of the array;
	   * moves the cursor to `0`.
	   *
	   * @param {Array<T>} items
	   *   Items.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  unshiftMany(items) {
	    this.setCursor(0);
	    chunkedPush(this.right, items.reverse());
	  }
	  /**
	   * Move the cursor to a specific position in the array. Requires
	   * time proportional to the distance moved.
	   *
	   * If `n < 0`, the cursor will end up at the beginning.
	   * If `n > length`, the cursor will end up at the end.
	   *
	   * @param {number} n
	   *   Position.
	   * @return {undefined}
	   *   Nothing.
	   */
	  setCursor(n) {
	    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;
	    if (n < this.left.length) {
	      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
	      chunkedPush(this.right, removed.reverse());
	    } else {
	      const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
	      chunkedPush(this.left, removed.reverse());
	    }
	  }
	};
	function chunkedPush(list3, right) {
	  let chunkStart = 0;
	  if (right.length < 1e4) {
	    list3.push(...right);
	  } else {
	    while (chunkStart < right.length) {
	      list3.push(...right.slice(chunkStart, chunkStart + 1e4));
	      chunkStart += 1e4;
	    }
	  }
	}

	// node_modules/.pnpm/micromark-util-subtokenize@2.1.0/node_modules/micromark-util-subtokenize/index.js
	function subtokenize(eventsArray) {
	  const jumps = {};
	  let index2 = -1;
	  let event;
	  let lineIndex;
	  let otherIndex;
	  let otherEvent;
	  let parameters;
	  let subevents;
	  let more;
	  const events = new SpliceBuffer(eventsArray);
	  while (++index2 < events.length) {
	    while (index2 in jumps) {
	      index2 = jumps[index2];
	    }
	    event = events.get(index2);
	    if (index2 && event[1].type === "chunkFlow" && events.get(index2 - 1)[1].type === "listItemPrefix") {
	      subevents = event[1]._tokenizer.events;
	      otherIndex = 0;
	      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
	        otherIndex += 2;
	      }
	      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
	        while (++otherIndex < subevents.length) {
	          if (subevents[otherIndex][1].type === "content") {
	            break;
	          }
	          if (subevents[otherIndex][1].type === "chunkText") {
	            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
	            otherIndex++;
	          }
	        }
	      }
	    }
	    if (event[0] === "enter") {
	      if (event[1].contentType) {
	        Object.assign(jumps, subcontent(events, index2));
	        index2 = jumps[index2];
	        more = true;
	      }
	    } else if (event[1]._container) {
	      otherIndex = index2;
	      lineIndex = void 0;
	      while (otherIndex--) {
	        otherEvent = events.get(otherIndex);
	        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
	          if (otherEvent[0] === "enter") {
	            if (lineIndex) {
	              events.get(lineIndex)[1].type = "lineEndingBlank";
	            }
	            otherEvent[1].type = "lineEnding";
	            lineIndex = otherIndex;
	          }
	        } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") ; else {
	          break;
	        }
	      }
	      if (lineIndex) {
	        event[1].end = {
	          ...events.get(lineIndex)[1].start
	        };
	        parameters = events.slice(lineIndex, index2);
	        parameters.unshift(event);
	        events.splice(lineIndex, index2 - lineIndex + 1, parameters);
	      }
	    }
	  }
	  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
	  return !more;
	}
	function subcontent(events, eventIndex) {
	  const token = events.get(eventIndex)[1];
	  const context = events.get(eventIndex)[2];
	  let startPosition = eventIndex - 1;
	  const startPositions = [];
	  let tokenizer = token._tokenizer;
	  if (!tokenizer) {
	    tokenizer = context.parser[token.contentType](token.start);
	    if (token._contentTypeTextTrailing) {
	      tokenizer._contentTypeTextTrailing = true;
	    }
	  }
	  const childEvents = tokenizer.events;
	  const jumps = [];
	  const gaps = {};
	  let stream;
	  let previous2;
	  let index2 = -1;
	  let current = token;
	  let adjust = 0;
	  let start = 0;
	  const breaks = [start];
	  while (current) {
	    while (events.get(++startPosition)[1] !== current) {
	    }
	    startPositions.push(startPosition);
	    if (!current._tokenizer) {
	      stream = context.sliceStream(current);
	      if (!current.next) {
	        stream.push(null);
	      }
	      if (previous2) {
	        tokenizer.defineSkip(current.start);
	      }
	      if (current._isInFirstContentOfListItem) {
	        tokenizer._gfmTasklistFirstContentOfListItem = true;
	      }
	      tokenizer.write(stream);
	      if (current._isInFirstContentOfListItem) {
	        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
	      }
	    }
	    previous2 = current;
	    current = current.next;
	  }
	  current = token;
	  while (++index2 < childEvents.length) {
	    if (
	      // Find a void token that includes a break.
	      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
	    ) {
	      start = index2 + 1;
	      breaks.push(start);
	      current._tokenizer = void 0;
	      current.previous = void 0;
	      current = current.next;
	    }
	  }
	  tokenizer.events = [];
	  if (current) {
	    current._tokenizer = void 0;
	    current.previous = void 0;
	  } else {
	    breaks.pop();
	  }
	  index2 = breaks.length;
	  while (index2--) {
	    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
	    const start2 = startPositions.pop();
	    jumps.push([start2, start2 + slice.length - 1]);
	    events.splice(start2, 2, slice);
	  }
	  jumps.reverse();
	  index2 = -1;
	  while (++index2 < jumps.length) {
	    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
	    adjust += jumps[index2][1] - jumps[index2][0] - 1;
	  }
	  return gaps;
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/content.js
	var content2 = {
	  resolve: resolveContent,
	  tokenize: tokenizeContent
	};
	var continuationConstruct = {
	  partial: true,
	  tokenize: tokenizeContinuation
	};
	function resolveContent(events) {
	  subtokenize(events);
	  return events;
	}
	function tokenizeContent(effects, ok3) {
	  let previous2;
	  return chunkStart;
	  function chunkStart(code2) {
	    effects.enter("content");
	    previous2 = effects.enter("chunkContent", {
	      contentType: "content"
	    });
	    return chunkInside(code2);
	  }
	  function chunkInside(code2) {
	    if (code2 === null) {
	      return contentEnd(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      return effects.check(continuationConstruct, contentContinue, contentEnd)(code2);
	    }
	    effects.consume(code2);
	    return chunkInside;
	  }
	  function contentEnd(code2) {
	    effects.exit("chunkContent");
	    effects.exit("content");
	    return ok3(code2);
	  }
	  function contentContinue(code2) {
	    effects.consume(code2);
	    effects.exit("chunkContent");
	    previous2.next = effects.enter("chunkContent", {
	      contentType: "content",
	      previous: previous2
	    });
	    previous2 = previous2.next;
	    return chunkInside;
	  }
	}
	function tokenizeContinuation(effects, ok3, nok) {
	  const self2 = this;
	  return startLookahead;
	  function startLookahead(code2) {
	    effects.exit("chunkContent");
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return factorySpace(effects, prefixed, "linePrefix");
	  }
	  function prefixed(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      return nok(code2);
	    }
	    const tail = self2.events[self2.events.length - 1];
	    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
	      return ok3(code2);
	    }
	    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code2);
	  }
	}

	// node_modules/.pnpm/micromark-factory-destination@2.0.1/node_modules/micromark-factory-destination/index.js
	function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
	  const limit = max || Number.POSITIVE_INFINITY;
	  let balance = 0;
	  return start;
	  function start(code2) {
	    if (code2 === 60) {
	      effects.enter(type);
	      effects.enter(literalType);
	      effects.enter(literalMarkerType);
	      effects.consume(code2);
	      effects.exit(literalMarkerType);
	      return enclosedBefore;
	    }
	    if (code2 === null || code2 === 32 || code2 === 41 || asciiControl(code2)) {
	      return nok(code2);
	    }
	    effects.enter(type);
	    effects.enter(rawType);
	    effects.enter(stringType);
	    effects.enter("chunkString", {
	      contentType: "string"
	    });
	    return raw(code2);
	  }
	  function enclosedBefore(code2) {
	    if (code2 === 62) {
	      effects.enter(literalMarkerType);
	      effects.consume(code2);
	      effects.exit(literalMarkerType);
	      effects.exit(literalType);
	      effects.exit(type);
	      return ok3;
	    }
	    effects.enter(stringType);
	    effects.enter("chunkString", {
	      contentType: "string"
	    });
	    return enclosed(code2);
	  }
	  function enclosed(code2) {
	    if (code2 === 62) {
	      effects.exit("chunkString");
	      effects.exit(stringType);
	      return enclosedBefore(code2);
	    }
	    if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
	      return nok(code2);
	    }
	    effects.consume(code2);
	    return code2 === 92 ? enclosedEscape : enclosed;
	  }
	  function enclosedEscape(code2) {
	    if (code2 === 60 || code2 === 62 || code2 === 92) {
	      effects.consume(code2);
	      return enclosed;
	    }
	    return enclosed(code2);
	  }
	  function raw(code2) {
	    if (!balance && (code2 === null || code2 === 41 || markdownLineEndingOrSpace(code2))) {
	      effects.exit("chunkString");
	      effects.exit(stringType);
	      effects.exit(rawType);
	      effects.exit(type);
	      return ok3(code2);
	    }
	    if (balance < limit && code2 === 40) {
	      effects.consume(code2);
	      balance++;
	      return raw;
	    }
	    if (code2 === 41) {
	      effects.consume(code2);
	      balance--;
	      return raw;
	    }
	    if (code2 === null || code2 === 32 || code2 === 40 || asciiControl(code2)) {
	      return nok(code2);
	    }
	    effects.consume(code2);
	    return code2 === 92 ? rawEscape : raw;
	  }
	  function rawEscape(code2) {
	    if (code2 === 40 || code2 === 41 || code2 === 92) {
	      effects.consume(code2);
	      return raw;
	    }
	    return raw(code2);
	  }
	}

	// node_modules/.pnpm/micromark-factory-label@2.0.1/node_modules/micromark-factory-label/index.js
	function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
	  const self2 = this;
	  let size = 0;
	  let seen;
	  return start;
	  function start(code2) {
	    effects.enter(type);
	    effects.enter(markerType);
	    effects.consume(code2);
	    effects.exit(markerType);
	    effects.enter(stringType);
	    return atBreak;
	  }
	  function atBreak(code2) {
	    if (size > 999 || code2 === null || code2 === 91 || code2 === 93 && !seen || // To do: remove in the future once we’ve switched from
	    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
	    // which doesn’t need this.
	    // Hidden footnotes hook.
	    /* c8 ignore next 3 */
	    code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
	      return nok(code2);
	    }
	    if (code2 === 93) {
	      effects.exit(stringType);
	      effects.enter(markerType);
	      effects.consume(code2);
	      effects.exit(markerType);
	      effects.exit(type);
	      return ok3;
	    }
	    if (markdownLineEnding(code2)) {
	      effects.enter("lineEnding");
	      effects.consume(code2);
	      effects.exit("lineEnding");
	      return atBreak;
	    }
	    effects.enter("chunkString", {
	      contentType: "string"
	    });
	    return labelInside(code2);
	  }
	  function labelInside(code2) {
	    if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
	      effects.exit("chunkString");
	      return atBreak(code2);
	    }
	    effects.consume(code2);
	    if (!seen) seen = !markdownSpace(code2);
	    return code2 === 92 ? labelEscape : labelInside;
	  }
	  function labelEscape(code2) {
	    if (code2 === 91 || code2 === 92 || code2 === 93) {
	      effects.consume(code2);
	      size++;
	      return labelInside;
	    }
	    return labelInside(code2);
	  }
	}

	// node_modules/.pnpm/micromark-factory-title@2.0.1/node_modules/micromark-factory-title/index.js
	function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
	  let marker;
	  return start;
	  function start(code2) {
	    if (code2 === 34 || code2 === 39 || code2 === 40) {
	      effects.enter(type);
	      effects.enter(markerType);
	      effects.consume(code2);
	      effects.exit(markerType);
	      marker = code2 === 40 ? 41 : code2;
	      return begin;
	    }
	    return nok(code2);
	  }
	  function begin(code2) {
	    if (code2 === marker) {
	      effects.enter(markerType);
	      effects.consume(code2);
	      effects.exit(markerType);
	      effects.exit(type);
	      return ok3;
	    }
	    effects.enter(stringType);
	    return atBreak(code2);
	  }
	  function atBreak(code2) {
	    if (code2 === marker) {
	      effects.exit(stringType);
	      return begin(marker);
	    }
	    if (code2 === null) {
	      return nok(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      effects.enter("lineEnding");
	      effects.consume(code2);
	      effects.exit("lineEnding");
	      return factorySpace(effects, atBreak, "linePrefix");
	    }
	    effects.enter("chunkString", {
	      contentType: "string"
	    });
	    return inside(code2);
	  }
	  function inside(code2) {
	    if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
	      effects.exit("chunkString");
	      return atBreak(code2);
	    }
	    effects.consume(code2);
	    return code2 === 92 ? escape : inside;
	  }
	  function escape(code2) {
	    if (code2 === marker || code2 === 92) {
	      effects.consume(code2);
	      return inside;
	    }
	    return inside(code2);
	  }
	}

	// node_modules/.pnpm/micromark-factory-whitespace@2.0.1/node_modules/micromark-factory-whitespace/index.js
	function factoryWhitespace(effects, ok3) {
	  let seen;
	  return start;
	  function start(code2) {
	    if (markdownLineEnding(code2)) {
	      effects.enter("lineEnding");
	      effects.consume(code2);
	      effects.exit("lineEnding");
	      seen = true;
	      return start;
	    }
	    if (markdownSpace(code2)) {
	      return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code2);
	    }
	    return ok3(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/definition.js
	var definition = {
	  name: "definition",
	  tokenize: tokenizeDefinition
	};
	var titleBefore = {
	  partial: true,
	  tokenize: tokenizeTitleBefore
	};
	function tokenizeDefinition(effects, ok3, nok) {
	  const self2 = this;
	  let identifier;
	  return start;
	  function start(code2) {
	    effects.enter("definition");
	    return before(code2);
	  }
	  function before(code2) {
	    return factoryLabel.call(
	      self2,
	      effects,
	      labelAfter,
	      // Note: we don’t need to reset the way `markdown-rs` does.
	      nok,
	      "definitionLabel",
	      "definitionLabelMarker",
	      "definitionLabelString"
	    )(code2);
	  }
	  function labelAfter(code2) {
	    identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
	    if (code2 === 58) {
	      effects.enter("definitionMarker");
	      effects.consume(code2);
	      effects.exit("definitionMarker");
	      return markerAfter;
	    }
	    return nok(code2);
	  }
	  function markerAfter(code2) {
	    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, destinationBefore)(code2) : destinationBefore(code2);
	  }
	  function destinationBefore(code2) {
	    return factoryDestination(
	      effects,
	      destinationAfter,
	      // Note: we don’t need to reset the way `markdown-rs` does.
	      nok,
	      "definitionDestination",
	      "definitionDestinationLiteral",
	      "definitionDestinationLiteralMarker",
	      "definitionDestinationRaw",
	      "definitionDestinationString"
	    )(code2);
	  }
	  function destinationAfter(code2) {
	    return effects.attempt(titleBefore, after, after)(code2);
	  }
	  function after(code2) {
	    return markdownSpace(code2) ? factorySpace(effects, afterWhitespace, "whitespace")(code2) : afterWhitespace(code2);
	  }
	  function afterWhitespace(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("definition");
	      self2.parser.defined.push(identifier);
	      return ok3(code2);
	    }
	    return nok(code2);
	  }
	}
	function tokenizeTitleBefore(effects, ok3, nok) {
	  return titleBefore2;
	  function titleBefore2(code2) {
	    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, beforeMarker)(code2) : nok(code2);
	  }
	  function beforeMarker(code2) {
	    return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code2);
	  }
	  function titleAfter(code2) {
	    return markdownSpace(code2) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code2) : titleAfterOptionalWhitespace(code2);
	  }
	  function titleAfterOptionalWhitespace(code2) {
	    return code2 === null || markdownLineEnding(code2) ? ok3(code2) : nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
	var hardBreakEscape = {
	  name: "hardBreakEscape",
	  tokenize: tokenizeHardBreakEscape
	};
	function tokenizeHardBreakEscape(effects, ok3, nok) {
	  return start;
	  function start(code2) {
	    effects.enter("hardBreakEscape");
	    effects.consume(code2);
	    return after;
	  }
	  function after(code2) {
	    if (markdownLineEnding(code2)) {
	      effects.exit("hardBreakEscape");
	      return ok3(code2);
	    }
	    return nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/heading-atx.js
	var headingAtx = {
	  name: "headingAtx",
	  resolve: resolveHeadingAtx,
	  tokenize: tokenizeHeadingAtx
	};
	function resolveHeadingAtx(events, context) {
	  let contentEnd = events.length - 2;
	  let contentStart = 3;
	  let content3;
	  let text4;
	  if (events[contentStart][1].type === "whitespace") {
	    contentStart += 2;
	  }
	  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
	    contentEnd -= 2;
	  }
	  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
	    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
	  }
	  if (contentEnd > contentStart) {
	    content3 = {
	      type: "atxHeadingText",
	      start: events[contentStart][1].start,
	      end: events[contentEnd][1].end
	    };
	    text4 = {
	      type: "chunkText",
	      start: events[contentStart][1].start,
	      end: events[contentEnd][1].end,
	      contentType: "text"
	    };
	    splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content3, context], ["enter", text4, context], ["exit", text4, context], ["exit", content3, context]]);
	  }
	  return events;
	}
	function tokenizeHeadingAtx(effects, ok3, nok) {
	  let size = 0;
	  return start;
	  function start(code2) {
	    effects.enter("atxHeading");
	    return before(code2);
	  }
	  function before(code2) {
	    effects.enter("atxHeadingSequence");
	    return sequenceOpen(code2);
	  }
	  function sequenceOpen(code2) {
	    if (code2 === 35 && size++ < 6) {
	      effects.consume(code2);
	      return sequenceOpen;
	    }
	    if (code2 === null || markdownLineEndingOrSpace(code2)) {
	      effects.exit("atxHeadingSequence");
	      return atBreak(code2);
	    }
	    return nok(code2);
	  }
	  function atBreak(code2) {
	    if (code2 === 35) {
	      effects.enter("atxHeadingSequence");
	      return sequenceFurther(code2);
	    }
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("atxHeading");
	      return ok3(code2);
	    }
	    if (markdownSpace(code2)) {
	      return factorySpace(effects, atBreak, "whitespace")(code2);
	    }
	    effects.enter("atxHeadingText");
	    return data(code2);
	  }
	  function sequenceFurther(code2) {
	    if (code2 === 35) {
	      effects.consume(code2);
	      return sequenceFurther;
	    }
	    effects.exit("atxHeadingSequence");
	    return atBreak(code2);
	  }
	  function data(code2) {
	    if (code2 === null || code2 === 35 || markdownLineEndingOrSpace(code2)) {
	      effects.exit("atxHeadingText");
	      return atBreak(code2);
	    }
	    effects.consume(code2);
	    return data;
	  }
	}

	// node_modules/.pnpm/micromark-util-html-tag-name@2.0.1/node_modules/micromark-util-html-tag-name/index.js
	var htmlBlockNames = [
	  "address",
	  "article",
	  "aside",
	  "base",
	  "basefont",
	  "blockquote",
	  "body",
	  "caption",
	  "center",
	  "col",
	  "colgroup",
	  "dd",
	  "details",
	  "dialog",
	  "dir",
	  "div",
	  "dl",
	  "dt",
	  "fieldset",
	  "figcaption",
	  "figure",
	  "footer",
	  "form",
	  "frame",
	  "frameset",
	  "h1",
	  "h2",
	  "h3",
	  "h4",
	  "h5",
	  "h6",
	  "head",
	  "header",
	  "hr",
	  "html",
	  "iframe",
	  "legend",
	  "li",
	  "link",
	  "main",
	  "menu",
	  "menuitem",
	  "nav",
	  "noframes",
	  "ol",
	  "optgroup",
	  "option",
	  "p",
	  "param",
	  "search",
	  "section",
	  "summary",
	  "table",
	  "tbody",
	  "td",
	  "tfoot",
	  "th",
	  "thead",
	  "title",
	  "tr",
	  "track",
	  "ul"
	];
	var htmlRawNames = ["pre", "script", "style", "textarea"];

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/html-flow.js
	var htmlFlow = {
	  concrete: true,
	  name: "htmlFlow",
	  resolveTo: resolveToHtmlFlow,
	  tokenize: tokenizeHtmlFlow
	};
	var blankLineBefore = {
	  partial: true,
	  tokenize: tokenizeBlankLineBefore
	};
	var nonLazyContinuationStart = {
	  partial: true,
	  tokenize: tokenizeNonLazyContinuationStart
	};
	function resolveToHtmlFlow(events) {
	  let index2 = events.length;
	  while (index2--) {
	    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
	      break;
	    }
	  }
	  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
	    events[index2][1].start = events[index2 - 2][1].start;
	    events[index2 + 1][1].start = events[index2 - 2][1].start;
	    events.splice(index2 - 2, 2);
	  }
	  return events;
	}
	function tokenizeHtmlFlow(effects, ok3, nok) {
	  const self2 = this;
	  let marker;
	  let closingTag;
	  let buffer;
	  let index2;
	  let markerB;
	  return start;
	  function start(code2) {
	    return before(code2);
	  }
	  function before(code2) {
	    effects.enter("htmlFlow");
	    effects.enter("htmlFlowData");
	    effects.consume(code2);
	    return open;
	  }
	  function open(code2) {
	    if (code2 === 33) {
	      effects.consume(code2);
	      return declarationOpen;
	    }
	    if (code2 === 47) {
	      effects.consume(code2);
	      closingTag = true;
	      return tagCloseStart;
	    }
	    if (code2 === 63) {
	      effects.consume(code2);
	      marker = 3;
	      return self2.interrupt ? ok3 : continuationDeclarationInside;
	    }
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      buffer = String.fromCharCode(code2);
	      return tagName;
	    }
	    return nok(code2);
	  }
	  function declarationOpen(code2) {
	    if (code2 === 45) {
	      effects.consume(code2);
	      marker = 2;
	      return commentOpenInside;
	    }
	    if (code2 === 91) {
	      effects.consume(code2);
	      marker = 5;
	      index2 = 0;
	      return cdataOpenInside;
	    }
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      marker = 4;
	      return self2.interrupt ? ok3 : continuationDeclarationInside;
	    }
	    return nok(code2);
	  }
	  function commentOpenInside(code2) {
	    if (code2 === 45) {
	      effects.consume(code2);
	      return self2.interrupt ? ok3 : continuationDeclarationInside;
	    }
	    return nok(code2);
	  }
	  function cdataOpenInside(code2) {
	    const value = "CDATA[";
	    if (code2 === value.charCodeAt(index2++)) {
	      effects.consume(code2);
	      if (index2 === value.length) {
	        return self2.interrupt ? ok3 : continuation;
	      }
	      return cdataOpenInside;
	    }
	    return nok(code2);
	  }
	  function tagCloseStart(code2) {
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      buffer = String.fromCharCode(code2);
	      return tagName;
	    }
	    return nok(code2);
	  }
	  function tagName(code2) {
	    if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
	      const slash = code2 === 47;
	      const name = buffer.toLowerCase();
	      if (!slash && !closingTag && htmlRawNames.includes(name)) {
	        marker = 1;
	        return self2.interrupt ? ok3(code2) : continuation(code2);
	      }
	      if (htmlBlockNames.includes(buffer.toLowerCase())) {
	        marker = 6;
	        if (slash) {
	          effects.consume(code2);
	          return basicSelfClosing;
	        }
	        return self2.interrupt ? ok3(code2) : continuation(code2);
	      }
	      marker = 7;
	      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : closingTag ? completeClosingTagAfter(code2) : completeAttributeNameBefore(code2);
	    }
	    if (code2 === 45 || asciiAlphanumeric(code2)) {
	      effects.consume(code2);
	      buffer += String.fromCharCode(code2);
	      return tagName;
	    }
	    return nok(code2);
	  }
	  function basicSelfClosing(code2) {
	    if (code2 === 62) {
	      effects.consume(code2);
	      return self2.interrupt ? ok3 : continuation;
	    }
	    return nok(code2);
	  }
	  function completeClosingTagAfter(code2) {
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return completeClosingTagAfter;
	    }
	    return completeEnd(code2);
	  }
	  function completeAttributeNameBefore(code2) {
	    if (code2 === 47) {
	      effects.consume(code2);
	      return completeEnd;
	    }
	    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
	      effects.consume(code2);
	      return completeAttributeName;
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return completeAttributeNameBefore;
	    }
	    return completeEnd(code2);
	  }
	  function completeAttributeName(code2) {
	    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
	      effects.consume(code2);
	      return completeAttributeName;
	    }
	    return completeAttributeNameAfter(code2);
	  }
	  function completeAttributeNameAfter(code2) {
	    if (code2 === 61) {
	      effects.consume(code2);
	      return completeAttributeValueBefore;
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return completeAttributeNameAfter;
	    }
	    return completeAttributeNameBefore(code2);
	  }
	  function completeAttributeValueBefore(code2) {
	    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
	      return nok(code2);
	    }
	    if (code2 === 34 || code2 === 39) {
	      effects.consume(code2);
	      markerB = code2;
	      return completeAttributeValueQuoted;
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return completeAttributeValueBefore;
	    }
	    return completeAttributeValueUnquoted(code2);
	  }
	  function completeAttributeValueQuoted(code2) {
	    if (code2 === markerB) {
	      effects.consume(code2);
	      markerB = null;
	      return completeAttributeValueQuotedAfter;
	    }
	    if (code2 === null || markdownLineEnding(code2)) {
	      return nok(code2);
	    }
	    effects.consume(code2);
	    return completeAttributeValueQuoted;
	  }
	  function completeAttributeValueUnquoted(code2) {
	    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 47 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace(code2)) {
	      return completeAttributeNameAfter(code2);
	    }
	    effects.consume(code2);
	    return completeAttributeValueUnquoted;
	  }
	  function completeAttributeValueQuotedAfter(code2) {
	    if (code2 === 47 || code2 === 62 || markdownSpace(code2)) {
	      return completeAttributeNameBefore(code2);
	    }
	    return nok(code2);
	  }
	  function completeEnd(code2) {
	    if (code2 === 62) {
	      effects.consume(code2);
	      return completeAfter;
	    }
	    return nok(code2);
	  }
	  function completeAfter(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      return continuation(code2);
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return completeAfter;
	    }
	    return nok(code2);
	  }
	  function continuation(code2) {
	    if (code2 === 45 && marker === 2) {
	      effects.consume(code2);
	      return continuationCommentInside;
	    }
	    if (code2 === 60 && marker === 1) {
	      effects.consume(code2);
	      return continuationRawTagOpen;
	    }
	    if (code2 === 62 && marker === 4) {
	      effects.consume(code2);
	      return continuationClose;
	    }
	    if (code2 === 63 && marker === 3) {
	      effects.consume(code2);
	      return continuationDeclarationInside;
	    }
	    if (code2 === 93 && marker === 5) {
	      effects.consume(code2);
	      return continuationCdataInside;
	    }
	    if (markdownLineEnding(code2) && (marker === 6 || marker === 7)) {
	      effects.exit("htmlFlowData");
	      return effects.check(blankLineBefore, continuationAfter, continuationStart)(code2);
	    }
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("htmlFlowData");
	      return continuationStart(code2);
	    }
	    effects.consume(code2);
	    return continuation;
	  }
	  function continuationStart(code2) {
	    return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code2);
	  }
	  function continuationStartNonLazy(code2) {
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return continuationBefore;
	  }
	  function continuationBefore(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      return continuationStart(code2);
	    }
	    effects.enter("htmlFlowData");
	    return continuation(code2);
	  }
	  function continuationCommentInside(code2) {
	    if (code2 === 45) {
	      effects.consume(code2);
	      return continuationDeclarationInside;
	    }
	    return continuation(code2);
	  }
	  function continuationRawTagOpen(code2) {
	    if (code2 === 47) {
	      effects.consume(code2);
	      buffer = "";
	      return continuationRawEndTag;
	    }
	    return continuation(code2);
	  }
	  function continuationRawEndTag(code2) {
	    if (code2 === 62) {
	      const name = buffer.toLowerCase();
	      if (htmlRawNames.includes(name)) {
	        effects.consume(code2);
	        return continuationClose;
	      }
	      return continuation(code2);
	    }
	    if (asciiAlpha(code2) && buffer.length < 8) {
	      effects.consume(code2);
	      buffer += String.fromCharCode(code2);
	      return continuationRawEndTag;
	    }
	    return continuation(code2);
	  }
	  function continuationCdataInside(code2) {
	    if (code2 === 93) {
	      effects.consume(code2);
	      return continuationDeclarationInside;
	    }
	    return continuation(code2);
	  }
	  function continuationDeclarationInside(code2) {
	    if (code2 === 62) {
	      effects.consume(code2);
	      return continuationClose;
	    }
	    if (code2 === 45 && marker === 2) {
	      effects.consume(code2);
	      return continuationDeclarationInside;
	    }
	    return continuation(code2);
	  }
	  function continuationClose(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("htmlFlowData");
	      return continuationAfter(code2);
	    }
	    effects.consume(code2);
	    return continuationClose;
	  }
	  function continuationAfter(code2) {
	    effects.exit("htmlFlow");
	    return ok3(code2);
	  }
	}
	function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
	  const self2 = this;
	  return start;
	  function start(code2) {
	    if (markdownLineEnding(code2)) {
	      effects.enter("lineEnding");
	      effects.consume(code2);
	      effects.exit("lineEnding");
	      return after;
	    }
	    return nok(code2);
	  }
	  function after(code2) {
	    return self2.parser.lazy[self2.now().line] ? nok(code2) : ok3(code2);
	  }
	}
	function tokenizeBlankLineBefore(effects, ok3, nok) {
	  return start;
	  function start(code2) {
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return effects.attempt(blankLine, ok3, nok);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/html-text.js
	var htmlText = {
	  name: "htmlText",
	  tokenize: tokenizeHtmlText
	};
	function tokenizeHtmlText(effects, ok3, nok) {
	  const self2 = this;
	  let marker;
	  let index2;
	  let returnState;
	  return start;
	  function start(code2) {
	    effects.enter("htmlText");
	    effects.enter("htmlTextData");
	    effects.consume(code2);
	    return open;
	  }
	  function open(code2) {
	    if (code2 === 33) {
	      effects.consume(code2);
	      return declarationOpen;
	    }
	    if (code2 === 47) {
	      effects.consume(code2);
	      return tagCloseStart;
	    }
	    if (code2 === 63) {
	      effects.consume(code2);
	      return instruction;
	    }
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      return tagOpen;
	    }
	    return nok(code2);
	  }
	  function declarationOpen(code2) {
	    if (code2 === 45) {
	      effects.consume(code2);
	      return commentOpenInside;
	    }
	    if (code2 === 91) {
	      effects.consume(code2);
	      index2 = 0;
	      return cdataOpenInside;
	    }
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      return declaration;
	    }
	    return nok(code2);
	  }
	  function commentOpenInside(code2) {
	    if (code2 === 45) {
	      effects.consume(code2);
	      return commentEnd;
	    }
	    return nok(code2);
	  }
	  function comment(code2) {
	    if (code2 === null) {
	      return nok(code2);
	    }
	    if (code2 === 45) {
	      effects.consume(code2);
	      return commentClose;
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = comment;
	      return lineEndingBefore(code2);
	    }
	    effects.consume(code2);
	    return comment;
	  }
	  function commentClose(code2) {
	    if (code2 === 45) {
	      effects.consume(code2);
	      return commentEnd;
	    }
	    return comment(code2);
	  }
	  function commentEnd(code2) {
	    return code2 === 62 ? end(code2) : code2 === 45 ? commentClose(code2) : comment(code2);
	  }
	  function cdataOpenInside(code2) {
	    const value = "CDATA[";
	    if (code2 === value.charCodeAt(index2++)) {
	      effects.consume(code2);
	      return index2 === value.length ? cdata : cdataOpenInside;
	    }
	    return nok(code2);
	  }
	  function cdata(code2) {
	    if (code2 === null) {
	      return nok(code2);
	    }
	    if (code2 === 93) {
	      effects.consume(code2);
	      return cdataClose;
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = cdata;
	      return lineEndingBefore(code2);
	    }
	    effects.consume(code2);
	    return cdata;
	  }
	  function cdataClose(code2) {
	    if (code2 === 93) {
	      effects.consume(code2);
	      return cdataEnd;
	    }
	    return cdata(code2);
	  }
	  function cdataEnd(code2) {
	    if (code2 === 62) {
	      return end(code2);
	    }
	    if (code2 === 93) {
	      effects.consume(code2);
	      return cdataEnd;
	    }
	    return cdata(code2);
	  }
	  function declaration(code2) {
	    if (code2 === null || code2 === 62) {
	      return end(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = declaration;
	      return lineEndingBefore(code2);
	    }
	    effects.consume(code2);
	    return declaration;
	  }
	  function instruction(code2) {
	    if (code2 === null) {
	      return nok(code2);
	    }
	    if (code2 === 63) {
	      effects.consume(code2);
	      return instructionClose;
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = instruction;
	      return lineEndingBefore(code2);
	    }
	    effects.consume(code2);
	    return instruction;
	  }
	  function instructionClose(code2) {
	    return code2 === 62 ? end(code2) : instruction(code2);
	  }
	  function tagCloseStart(code2) {
	    if (asciiAlpha(code2)) {
	      effects.consume(code2);
	      return tagClose;
	    }
	    return nok(code2);
	  }
	  function tagClose(code2) {
	    if (code2 === 45 || asciiAlphanumeric(code2)) {
	      effects.consume(code2);
	      return tagClose;
	    }
	    return tagCloseBetween(code2);
	  }
	  function tagCloseBetween(code2) {
	    if (markdownLineEnding(code2)) {
	      returnState = tagCloseBetween;
	      return lineEndingBefore(code2);
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return tagCloseBetween;
	    }
	    return end(code2);
	  }
	  function tagOpen(code2) {
	    if (code2 === 45 || asciiAlphanumeric(code2)) {
	      effects.consume(code2);
	      return tagOpen;
	    }
	    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
	      return tagOpenBetween(code2);
	    }
	    return nok(code2);
	  }
	  function tagOpenBetween(code2) {
	    if (code2 === 47) {
	      effects.consume(code2);
	      return end;
	    }
	    if (code2 === 58 || code2 === 95 || asciiAlpha(code2)) {
	      effects.consume(code2);
	      return tagOpenAttributeName;
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = tagOpenBetween;
	      return lineEndingBefore(code2);
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return tagOpenBetween;
	    }
	    return end(code2);
	  }
	  function tagOpenAttributeName(code2) {
	    if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric(code2)) {
	      effects.consume(code2);
	      return tagOpenAttributeName;
	    }
	    return tagOpenAttributeNameAfter(code2);
	  }
	  function tagOpenAttributeNameAfter(code2) {
	    if (code2 === 61) {
	      effects.consume(code2);
	      return tagOpenAttributeValueBefore;
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = tagOpenAttributeNameAfter;
	      return lineEndingBefore(code2);
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return tagOpenAttributeNameAfter;
	    }
	    return tagOpenBetween(code2);
	  }
	  function tagOpenAttributeValueBefore(code2) {
	    if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
	      return nok(code2);
	    }
	    if (code2 === 34 || code2 === 39) {
	      effects.consume(code2);
	      marker = code2;
	      return tagOpenAttributeValueQuoted;
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = tagOpenAttributeValueBefore;
	      return lineEndingBefore(code2);
	    }
	    if (markdownSpace(code2)) {
	      effects.consume(code2);
	      return tagOpenAttributeValueBefore;
	    }
	    effects.consume(code2);
	    return tagOpenAttributeValueUnquoted;
	  }
	  function tagOpenAttributeValueQuoted(code2) {
	    if (code2 === marker) {
	      effects.consume(code2);
	      marker = void 0;
	      return tagOpenAttributeValueQuotedAfter;
	    }
	    if (code2 === null) {
	      return nok(code2);
	    }
	    if (markdownLineEnding(code2)) {
	      returnState = tagOpenAttributeValueQuoted;
	      return lineEndingBefore(code2);
	    }
	    effects.consume(code2);
	    return tagOpenAttributeValueQuoted;
	  }
	  function tagOpenAttributeValueUnquoted(code2) {
	    if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
	      return nok(code2);
	    }
	    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
	      return tagOpenBetween(code2);
	    }
	    effects.consume(code2);
	    return tagOpenAttributeValueUnquoted;
	  }
	  function tagOpenAttributeValueQuotedAfter(code2) {
	    if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace(code2)) {
	      return tagOpenBetween(code2);
	    }
	    return nok(code2);
	  }
	  function end(code2) {
	    if (code2 === 62) {
	      effects.consume(code2);
	      effects.exit("htmlTextData");
	      effects.exit("htmlText");
	      return ok3;
	    }
	    return nok(code2);
	  }
	  function lineEndingBefore(code2) {
	    effects.exit("htmlTextData");
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return lineEndingAfter;
	  }
	  function lineEndingAfter(code2) {
	    return markdownSpace(code2) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2) : lineEndingAfterPrefix(code2);
	  }
	  function lineEndingAfterPrefix(code2) {
	    effects.enter("htmlTextData");
	    return returnState(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/label-end.js
	var labelEnd = {
	  name: "labelEnd",
	  resolveAll: resolveAllLabelEnd,
	  resolveTo: resolveToLabelEnd,
	  tokenize: tokenizeLabelEnd
	};
	var resourceConstruct = {
	  tokenize: tokenizeResource
	};
	var referenceFullConstruct = {
	  tokenize: tokenizeReferenceFull
	};
	var referenceCollapsedConstruct = {
	  tokenize: tokenizeReferenceCollapsed
	};
	function resolveAllLabelEnd(events) {
	  let index2 = -1;
	  const newEvents = [];
	  while (++index2 < events.length) {
	    const token = events[index2][1];
	    newEvents.push(events[index2]);
	    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
	      const offset = token.type === "labelImage" ? 4 : 2;
	      token.type = "data";
	      index2 += offset;
	    }
	  }
	  if (events.length !== newEvents.length) {
	    splice(events, 0, events.length, newEvents);
	  }
	  return events;
	}
	function resolveToLabelEnd(events, context) {
	  let index2 = events.length;
	  let offset = 0;
	  let token;
	  let open;
	  let close;
	  let media;
	  while (index2--) {
	    token = events[index2][1];
	    if (open) {
	      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
	        break;
	      }
	      if (events[index2][0] === "enter" && token.type === "labelLink") {
	        token._inactive = true;
	      }
	    } else if (close) {
	      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
	        open = index2;
	        if (token.type !== "labelLink") {
	          offset = 2;
	          break;
	        }
	      }
	    } else if (token.type === "labelEnd") {
	      close = index2;
	    }
	  }
	  const group = {
	    type: events[open][1].type === "labelLink" ? "link" : "image",
	    start: {
	      ...events[open][1].start
	    },
	    end: {
	      ...events[events.length - 1][1].end
	    }
	  };
	  const label = {
	    type: "label",
	    start: {
	      ...events[open][1].start
	    },
	    end: {
	      ...events[close][1].end
	    }
	  };
	  const text4 = {
	    type: "labelText",
	    start: {
	      ...events[open + offset + 2][1].end
	    },
	    end: {
	      ...events[close - 2][1].start
	    }
	  };
	  media = [["enter", group, context], ["enter", label, context]];
	  media = push(media, events.slice(open + 1, open + offset + 3));
	  media = push(media, [["enter", text4, context]]);
	  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context));
	  media = push(media, [["exit", text4, context], events[close - 2], events[close - 1], ["exit", label, context]]);
	  media = push(media, events.slice(close + 1));
	  media = push(media, [["exit", group, context]]);
	  splice(events, open, events.length, media);
	  return events;
	}
	function tokenizeLabelEnd(effects, ok3, nok) {
	  const self2 = this;
	  let index2 = self2.events.length;
	  let labelStart;
	  let defined;
	  while (index2--) {
	    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
	      labelStart = self2.events[index2][1];
	      break;
	    }
	  }
	  return start;
	  function start(code2) {
	    if (!labelStart) {
	      return nok(code2);
	    }
	    if (labelStart._inactive) {
	      return labelEndNok(code2);
	    }
	    defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
	      start: labelStart.end,
	      end: self2.now()
	    })));
	    effects.enter("labelEnd");
	    effects.enter("labelMarker");
	    effects.consume(code2);
	    effects.exit("labelMarker");
	    effects.exit("labelEnd");
	    return after;
	  }
	  function after(code2) {
	    if (code2 === 40) {
	      return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code2);
	    }
	    if (code2 === 91) {
	      return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code2);
	    }
	    return defined ? labelEndOk(code2) : labelEndNok(code2);
	  }
	  function referenceNotFull(code2) {
	    return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code2);
	  }
	  function labelEndOk(code2) {
	    return ok3(code2);
	  }
	  function labelEndNok(code2) {
	    labelStart._balanced = true;
	    return nok(code2);
	  }
	}
	function tokenizeResource(effects, ok3, nok) {
	  return resourceStart;
	  function resourceStart(code2) {
	    effects.enter("resource");
	    effects.enter("resourceMarker");
	    effects.consume(code2);
	    effects.exit("resourceMarker");
	    return resourceBefore;
	  }
	  function resourceBefore(code2) {
	    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceOpen)(code2) : resourceOpen(code2);
	  }
	  function resourceOpen(code2) {
	    if (code2 === 41) {
	      return resourceEnd(code2);
	    }
	    return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code2);
	  }
	  function resourceDestinationAfter(code2) {
	    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceBetween)(code2) : resourceEnd(code2);
	  }
	  function resourceDestinationMissing(code2) {
	    return nok(code2);
	  }
	  function resourceBetween(code2) {
	    if (code2 === 34 || code2 === 39 || code2 === 40) {
	      return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code2);
	    }
	    return resourceEnd(code2);
	  }
	  function resourceTitleAfter(code2) {
	    return markdownLineEndingOrSpace(code2) ? factoryWhitespace(effects, resourceEnd)(code2) : resourceEnd(code2);
	  }
	  function resourceEnd(code2) {
	    if (code2 === 41) {
	      effects.enter("resourceMarker");
	      effects.consume(code2);
	      effects.exit("resourceMarker");
	      effects.exit("resource");
	      return ok3;
	    }
	    return nok(code2);
	  }
	}
	function tokenizeReferenceFull(effects, ok3, nok) {
	  const self2 = this;
	  return referenceFull;
	  function referenceFull(code2) {
	    return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code2);
	  }
	  function referenceFullAfter(code2) {
	    return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code2) : nok(code2);
	  }
	  function referenceFullMissing(code2) {
	    return nok(code2);
	  }
	}
	function tokenizeReferenceCollapsed(effects, ok3, nok) {
	  return referenceCollapsedStart;
	  function referenceCollapsedStart(code2) {
	    effects.enter("reference");
	    effects.enter("referenceMarker");
	    effects.consume(code2);
	    effects.exit("referenceMarker");
	    return referenceCollapsedOpen;
	  }
	  function referenceCollapsedOpen(code2) {
	    if (code2 === 93) {
	      effects.enter("referenceMarker");
	      effects.consume(code2);
	      effects.exit("referenceMarker");
	      effects.exit("reference");
	      return ok3;
	    }
	    return nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/label-start-image.js
	var labelStartImage = {
	  name: "labelStartImage",
	  resolveAll: labelEnd.resolveAll,
	  tokenize: tokenizeLabelStartImage
	};
	function tokenizeLabelStartImage(effects, ok3, nok) {
	  const self2 = this;
	  return start;
	  function start(code2) {
	    effects.enter("labelImage");
	    effects.enter("labelImageMarker");
	    effects.consume(code2);
	    effects.exit("labelImageMarker");
	    return open;
	  }
	  function open(code2) {
	    if (code2 === 91) {
	      effects.enter("labelMarker");
	      effects.consume(code2);
	      effects.exit("labelMarker");
	      effects.exit("labelImage");
	      return after;
	    }
	    return nok(code2);
	  }
	  function after(code2) {
	    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/label-start-link.js
	var labelStartLink = {
	  name: "labelStartLink",
	  resolveAll: labelEnd.resolveAll,
	  tokenize: tokenizeLabelStartLink
	};
	function tokenizeLabelStartLink(effects, ok3, nok) {
	  const self2 = this;
	  return start;
	  function start(code2) {
	    effects.enter("labelLink");
	    effects.enter("labelMarker");
	    effects.consume(code2);
	    effects.exit("labelMarker");
	    effects.exit("labelLink");
	    return after;
	  }
	  function after(code2) {
	    return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok3(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/line-ending.js
	var lineEnding = {
	  name: "lineEnding",
	  tokenize: tokenizeLineEnding
	};
	function tokenizeLineEnding(effects, ok3) {
	  return start;
	  function start(code2) {
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    return factorySpace(effects, ok3, "linePrefix");
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/thematic-break.js
	var thematicBreak = {
	  name: "thematicBreak",
	  tokenize: tokenizeThematicBreak
	};
	function tokenizeThematicBreak(effects, ok3, nok) {
	  let size = 0;
	  let marker;
	  return start;
	  function start(code2) {
	    effects.enter("thematicBreak");
	    return before(code2);
	  }
	  function before(code2) {
	    marker = code2;
	    return atBreak(code2);
	  }
	  function atBreak(code2) {
	    if (code2 === marker) {
	      effects.enter("thematicBreakSequence");
	      return sequence(code2);
	    }
	    if (size >= 3 && (code2 === null || markdownLineEnding(code2))) {
	      effects.exit("thematicBreak");
	      return ok3(code2);
	    }
	    return nok(code2);
	  }
	  function sequence(code2) {
	    if (code2 === marker) {
	      effects.consume(code2);
	      size++;
	      return sequence;
	    }
	    effects.exit("thematicBreakSequence");
	    return markdownSpace(code2) ? factorySpace(effects, atBreak, "whitespace")(code2) : atBreak(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/list.js
	var list = {
	  continuation: {
	    tokenize: tokenizeListContinuation
	  },
	  exit: tokenizeListEnd,
	  name: "list",
	  tokenize: tokenizeListStart
	};
	var listItemPrefixWhitespaceConstruct = {
	  partial: true,
	  tokenize: tokenizeListItemPrefixWhitespace
	};
	var indentConstruct = {
	  partial: true,
	  tokenize: tokenizeIndent
	};
	function tokenizeListStart(effects, ok3, nok) {
	  const self2 = this;
	  const tail = self2.events[self2.events.length - 1];
	  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
	  let size = 0;
	  return start;
	  function start(code2) {
	    const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
	    if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
	      if (!self2.containerState.type) {
	        self2.containerState.type = kind;
	        effects.enter(kind, {
	          _container: true
	        });
	      }
	      if (kind === "listUnordered") {
	        effects.enter("listItemPrefix");
	        return code2 === 42 || code2 === 45 ? effects.check(thematicBreak, nok, atMarker)(code2) : atMarker(code2);
	      }
	      if (!self2.interrupt || code2 === 49) {
	        effects.enter("listItemPrefix");
	        effects.enter("listItemValue");
	        return inside(code2);
	      }
	    }
	    return nok(code2);
	  }
	  function inside(code2) {
	    if (asciiDigit(code2) && ++size < 10) {
	      effects.consume(code2);
	      return inside;
	    }
	    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
	      effects.exit("listItemValue");
	      return atMarker(code2);
	    }
	    return nok(code2);
	  }
	  function atMarker(code2) {
	    effects.enter("listItemMarker");
	    effects.consume(code2);
	    effects.exit("listItemMarker");
	    self2.containerState.marker = self2.containerState.marker || code2;
	    return effects.check(
	      blankLine,
	      // Can’t be empty when interrupting.
	      self2.interrupt ? nok : onBlank,
	      effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
	    );
	  }
	  function onBlank(code2) {
	    self2.containerState.initialBlankLine = true;
	    initialSize++;
	    return endOfPrefix(code2);
	  }
	  function otherPrefix(code2) {
	    if (markdownSpace(code2)) {
	      effects.enter("listItemPrefixWhitespace");
	      effects.consume(code2);
	      effects.exit("listItemPrefixWhitespace");
	      return endOfPrefix;
	    }
	    return nok(code2);
	  }
	  function endOfPrefix(code2) {
	    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
	    return ok3(code2);
	  }
	}
	function tokenizeListContinuation(effects, ok3, nok) {
	  const self2 = this;
	  self2.containerState._closeFlow = void 0;
	  return effects.check(blankLine, onBlank, notBlank);
	  function onBlank(code2) {
	    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
	    return factorySpace(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code2);
	  }
	  function notBlank(code2) {
	    if (self2.containerState.furtherBlankLines || !markdownSpace(code2)) {
	      self2.containerState.furtherBlankLines = void 0;
	      self2.containerState.initialBlankLine = void 0;
	      return notInCurrentItem(code2);
	    }
	    self2.containerState.furtherBlankLines = void 0;
	    self2.containerState.initialBlankLine = void 0;
	    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code2);
	  }
	  function notInCurrentItem(code2) {
	    self2.containerState._closeFlow = true;
	    self2.interrupt = void 0;
	    return factorySpace(effects, effects.attempt(list, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code2);
	  }
	}
	function tokenizeIndent(effects, ok3, nok) {
	  const self2 = this;
	  return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
	  function afterPrefix(code2) {
	    const tail = self2.events[self2.events.length - 1];
	    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code2) : nok(code2);
	  }
	}
	function tokenizeListEnd(effects) {
	  effects.exit(this.containerState.type);
	}
	function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
	  const self2 = this;
	  return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
	  function afterPrefix(code2) {
	    const tail = self2.events[self2.events.length - 1];
	    return !markdownSpace(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code2) : nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark-core-commonmark@2.0.3/node_modules/micromark-core-commonmark/lib/setext-underline.js
	var setextUnderline = {
	  name: "setextUnderline",
	  resolveTo: resolveToSetextUnderline,
	  tokenize: tokenizeSetextUnderline
	};
	function resolveToSetextUnderline(events, context) {
	  let index2 = events.length;
	  let content3;
	  let text4;
	  let definition2;
	  while (index2--) {
	    if (events[index2][0] === "enter") {
	      if (events[index2][1].type === "content") {
	        content3 = index2;
	        break;
	      }
	      if (events[index2][1].type === "paragraph") {
	        text4 = index2;
	      }
	    } else {
	      if (events[index2][1].type === "content") {
	        events.splice(index2, 1);
	      }
	      if (!definition2 && events[index2][1].type === "definition") {
	        definition2 = index2;
	      }
	    }
	  }
	  const heading2 = {
	    type: "setextHeading",
	    start: {
	      ...events[content3][1].start
	    },
	    end: {
	      ...events[events.length - 1][1].end
	    }
	  };
	  events[text4][1].type = "setextHeadingText";
	  if (definition2) {
	    events.splice(text4, 0, ["enter", heading2, context]);
	    events.splice(definition2 + 1, 0, ["exit", events[content3][1], context]);
	    events[content3][1].end = {
	      ...events[definition2][1].end
	    };
	  } else {
	    events[content3][1] = heading2;
	  }
	  events.push(["exit", heading2, context]);
	  return events;
	}
	function tokenizeSetextUnderline(effects, ok3, nok) {
	  const self2 = this;
	  let marker;
	  return start;
	  function start(code2) {
	    let index2 = self2.events.length;
	    let paragraph2;
	    while (index2--) {
	      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
	        paragraph2 = self2.events[index2][1].type === "paragraph";
	        break;
	      }
	    }
	    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
	      effects.enter("setextHeadingLine");
	      marker = code2;
	      return before(code2);
	    }
	    return nok(code2);
	  }
	  function before(code2) {
	    effects.enter("setextHeadingLineSequence");
	    return inside(code2);
	  }
	  function inside(code2) {
	    if (code2 === marker) {
	      effects.consume(code2);
	      return inside;
	    }
	    effects.exit("setextHeadingLineSequence");
	    return markdownSpace(code2) ? factorySpace(effects, after, "lineSuffix")(code2) : after(code2);
	  }
	  function after(code2) {
	    if (code2 === null || markdownLineEnding(code2)) {
	      effects.exit("setextHeadingLine");
	      return ok3(code2);
	    }
	    return nok(code2);
	  }
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/initialize/flow.js
	var flow = {
	  tokenize: initializeFlow
	};
	function initializeFlow(effects) {
	  const self2 = this;
	  const initial = effects.attempt(
	    // Try to parse a blank line.
	    blankLine,
	    atBlankEnding,
	    // Try to parse initial flow (essentially, only code).
	    effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content2, afterConstruct)), "linePrefix"))
	  );
	  return initial;
	  function atBlankEnding(code2) {
	    if (code2 === null) {
	      effects.consume(code2);
	      return;
	    }
	    effects.enter("lineEndingBlank");
	    effects.consume(code2);
	    effects.exit("lineEndingBlank");
	    self2.currentConstruct = void 0;
	    return initial;
	  }
	  function afterConstruct(code2) {
	    if (code2 === null) {
	      effects.consume(code2);
	      return;
	    }
	    effects.enter("lineEnding");
	    effects.consume(code2);
	    effects.exit("lineEnding");
	    self2.currentConstruct = void 0;
	    return initial;
	  }
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/initialize/text.js
	var resolver = {
	  resolveAll: createResolver()
	};
	var string = initializeFactory("string");
	var text = initializeFactory("text");
	function initializeFactory(field) {
	  return {
	    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
	    tokenize: initializeText
	  };
	  function initializeText(effects) {
	    const self2 = this;
	    const constructs2 = this.parser.constructs[field];
	    const text4 = effects.attempt(constructs2, start, notText);
	    return start;
	    function start(code2) {
	      return atBreak(code2) ? text4(code2) : notText(code2);
	    }
	    function notText(code2) {
	      if (code2 === null) {
	        effects.consume(code2);
	        return;
	      }
	      effects.enter("data");
	      effects.consume(code2);
	      return data;
	    }
	    function data(code2) {
	      if (atBreak(code2)) {
	        effects.exit("data");
	        return text4(code2);
	      }
	      effects.consume(code2);
	      return data;
	    }
	    function atBreak(code2) {
	      if (code2 === null) {
	        return true;
	      }
	      const list3 = constructs2[code2];
	      let index2 = -1;
	      if (list3) {
	        while (++index2 < list3.length) {
	          const item = list3[index2];
	          if (!item.previous || item.previous.call(self2, self2.previous)) {
	            return true;
	          }
	        }
	      }
	      return false;
	    }
	  }
	}
	function createResolver(extraResolver) {
	  return resolveAllText;
	  function resolveAllText(events, context) {
	    let index2 = -1;
	    let enter;
	    while (++index2 <= events.length) {
	      if (enter === void 0) {
	        if (events[index2] && events[index2][1].type === "data") {
	          enter = index2;
	          index2++;
	        }
	      } else if (!events[index2] || events[index2][1].type !== "data") {
	        if (index2 !== enter + 2) {
	          events[enter][1].end = events[index2 - 1][1].end;
	          events.splice(enter + 2, index2 - enter - 2);
	          index2 = enter + 2;
	        }
	        enter = void 0;
	      }
	    }
	    return extraResolver ? extraResolver(events, context) : events;
	  }
	}
	function resolveAllLineSuffixes(events, context) {
	  let eventIndex = 0;
	  while (++eventIndex <= events.length) {
	    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
	      const data = events[eventIndex - 1][1];
	      const chunks = context.sliceStream(data);
	      let index2 = chunks.length;
	      let bufferIndex = -1;
	      let size = 0;
	      let tabs;
	      while (index2--) {
	        const chunk = chunks[index2];
	        if (typeof chunk === "string") {
	          bufferIndex = chunk.length;
	          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
	            size++;
	            bufferIndex--;
	          }
	          if (bufferIndex) break;
	          bufferIndex = -1;
	        } else if (chunk === -2) {
	          tabs = true;
	          size++;
	        } else if (chunk === -1) ; else {
	          index2++;
	          break;
	        }
	      }
	      if (context._contentTypeTextTrailing && eventIndex === events.length) {
	        size = 0;
	      }
	      if (size) {
	        const token = {
	          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
	          start: {
	            _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex,
	            _index: data.start._index + index2,
	            line: data.end.line,
	            column: data.end.column - size,
	            offset: data.end.offset - size
	          },
	          end: {
	            ...data.end
	          }
	        };
	        data.end = {
	          ...token.start
	        };
	        if (data.start.offset === data.end.offset) {
	          Object.assign(data, token);
	        } else {
	          events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
	          eventIndex += 2;
	        }
	      }
	      eventIndex++;
	    }
	  }
	  return events;
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/constructs.js
	var constructs_exports = {};
	__export(constructs_exports, {
	  attentionMarkers: () => attentionMarkers,
	  contentInitial: () => contentInitial,
	  disable: () => disable,
	  document: () => document2,
	  flow: () => flow2,
	  flowInitial: () => flowInitial,
	  insideSpan: () => insideSpan,
	  string: () => string2,
	  text: () => text2
	});
	var document2 = {
	  [42]: list,
	  [43]: list,
	  [45]: list,
	  [48]: list,
	  [49]: list,
	  [50]: list,
	  [51]: list,
	  [52]: list,
	  [53]: list,
	  [54]: list,
	  [55]: list,
	  [56]: list,
	  [57]: list,
	  [62]: blockQuote
	};
	var contentInitial = {
	  [91]: definition
	};
	var flowInitial = {
	  [-2]: codeIndented,
	  [-1]: codeIndented,
	  [32]: codeIndented
	};
	var flow2 = {
	  [35]: headingAtx,
	  [42]: thematicBreak,
	  [45]: [setextUnderline, thematicBreak],
	  [60]: htmlFlow,
	  [61]: setextUnderline,
	  [95]: thematicBreak,
	  [96]: codeFenced,
	  [126]: codeFenced
	};
	var string2 = {
	  [38]: characterReference,
	  [92]: characterEscape
	};
	var text2 = {
	  [-5]: lineEnding,
	  [-4]: lineEnding,
	  [-3]: lineEnding,
	  [33]: labelStartImage,
	  [38]: characterReference,
	  [42]: attention,
	  [60]: [autolink, htmlText],
	  [91]: labelStartLink,
	  [92]: [hardBreakEscape, characterEscape],
	  [93]: labelEnd,
	  [95]: attention,
	  [96]: codeText
	};
	var insideSpan = {
	  null: [attention, resolver]
	};
	var attentionMarkers = {
	  null: [42, 95]
	};
	var disable = {
	  null: []
	};

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/create-tokenizer.js
	function createTokenizer(parser, initialize, from) {
	  let point4 = {
	    _bufferIndex: -1,
	    _index: 0,
	    line: from && from.line || 1,
	    column: from && from.column || 1,
	    offset: from && from.offset || 0
	  };
	  const columnStart = {};
	  const resolveAllConstructs = [];
	  let chunks = [];
	  let stack = [];
	  const effects = {
	    attempt: constructFactory(onsuccessfulconstruct),
	    check: constructFactory(onsuccessfulcheck),
	    consume,
	    enter,
	    exit: exit2,
	    interrupt: constructFactory(onsuccessfulcheck, {
	      interrupt: true
	    })
	  };
	  const context = {
	    code: null,
	    containerState: {},
	    defineSkip,
	    events: [],
	    now,
	    parser,
	    previous: null,
	    sliceSerialize,
	    sliceStream,
	    write
	  };
	  let state = initialize.tokenize.call(context, effects);
	  if (initialize.resolveAll) {
	    resolveAllConstructs.push(initialize);
	  }
	  return context;
	  function write(slice) {
	    chunks = push(chunks, slice);
	    main();
	    if (chunks[chunks.length - 1] !== null) {
	      return [];
	    }
	    addResult(initialize, 0);
	    context.events = resolveAll(resolveAllConstructs, context.events, context);
	    return context.events;
	  }
	  function sliceSerialize(token, expandTabs) {
	    return serializeChunks(sliceStream(token), expandTabs);
	  }
	  function sliceStream(token) {
	    return sliceChunks(chunks, token);
	  }
	  function now() {
	    const {
	      _bufferIndex,
	      _index,
	      line,
	      column,
	      offset
	    } = point4;
	    return {
	      _bufferIndex,
	      _index,
	      line,
	      column,
	      offset
	    };
	  }
	  function defineSkip(value) {
	    columnStart[value.line] = value.column;
	    accountForPotentialSkip();
	  }
	  function main() {
	    let chunkIndex;
	    while (point4._index < chunks.length) {
	      const chunk = chunks[point4._index];
	      if (typeof chunk === "string") {
	        chunkIndex = point4._index;
	        if (point4._bufferIndex < 0) {
	          point4._bufferIndex = 0;
	        }
	        while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
	          go(chunk.charCodeAt(point4._bufferIndex));
	        }
	      } else {
	        go(chunk);
	      }
	    }
	  }
	  function go(code2) {
	    state = state(code2);
	  }
	  function consume(code2) {
	    if (markdownLineEnding(code2)) {
	      point4.line++;
	      point4.column = 1;
	      point4.offset += code2 === -3 ? 2 : 1;
	      accountForPotentialSkip();
	    } else if (code2 !== -1) {
	      point4.column++;
	      point4.offset++;
	    }
	    if (point4._bufferIndex < 0) {
	      point4._index++;
	    } else {
	      point4._bufferIndex++;
	      if (point4._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
	      // strings.
	      /** @type {string} */
	      chunks[point4._index].length) {
	        point4._bufferIndex = -1;
	        point4._index++;
	      }
	    }
	    context.previous = code2;
	  }
	  function enter(type, fields) {
	    const token = fields || {};
	    token.type = type;
	    token.start = now();
	    context.events.push(["enter", token, context]);
	    stack.push(token);
	    return token;
	  }
	  function exit2(type) {
	    const token = stack.pop();
	    token.end = now();
	    context.events.push(["exit", token, context]);
	    return token;
	  }
	  function onsuccessfulconstruct(construct, info) {
	    addResult(construct, info.from);
	  }
	  function onsuccessfulcheck(_, info) {
	    info.restore();
	  }
	  function constructFactory(onreturn, fields) {
	    return hook;
	    function hook(constructs2, returnState, bogusState) {
	      let listOfConstructs;
	      let constructIndex;
	      let currentConstruct;
	      let info;
	      return Array.isArray(constructs2) ? (
	        /* c8 ignore next 1 */
	        handleListOfConstructs(constructs2)
	      ) : "tokenize" in constructs2 ? (
	        // Looks like a construct.
	        handleListOfConstructs([
	          /** @type {Construct} */
	          constructs2
	        ])
	      ) : handleMapOfConstructs(constructs2);
	      function handleMapOfConstructs(map) {
	        return start;
	        function start(code2) {
	          const left = code2 !== null && map[code2];
	          const all2 = code2 !== null && map.null;
	          const list3 = [
	            // To do: add more extension tests.
	            /* c8 ignore next 2 */
	            ...Array.isArray(left) ? left : left ? [left] : [],
	            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
	          ];
	          return handleListOfConstructs(list3)(code2);
	        }
	      }
	      function handleListOfConstructs(list3) {
	        listOfConstructs = list3;
	        constructIndex = 0;
	        if (list3.length === 0) {
	          return bogusState;
	        }
	        return handleConstruct(list3[constructIndex]);
	      }
	      function handleConstruct(construct) {
	        return start;
	        function start(code2) {
	          info = store();
	          currentConstruct = construct;
	          if (!construct.partial) {
	            context.currentConstruct = construct;
	          }
	          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
	            return nok();
	          }
	          return construct.tokenize.call(
	            // If we do have fields, create an object w/ `context` as its
	            // prototype.
	            // This allows a “live binding”, which is needed for `interrupt`.
	            fields ? Object.assign(Object.create(context), fields) : context,
	            effects,
	            ok3,
	            nok
	          )(code2);
	        }
	      }
	      function ok3(code2) {
	        onreturn(currentConstruct, info);
	        return returnState;
	      }
	      function nok(code2) {
	        info.restore();
	        if (++constructIndex < listOfConstructs.length) {
	          return handleConstruct(listOfConstructs[constructIndex]);
	        }
	        return bogusState;
	      }
	    }
	  }
	  function addResult(construct, from2) {
	    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
	      resolveAllConstructs.push(construct);
	    }
	    if (construct.resolve) {
	      splice(context.events, from2, context.events.length - from2, construct.resolve(context.events.slice(from2), context));
	    }
	    if (construct.resolveTo) {
	      context.events = construct.resolveTo(context.events, context);
	    }
	  }
	  function store() {
	    const startPoint = now();
	    const startPrevious = context.previous;
	    const startCurrentConstruct = context.currentConstruct;
	    const startEventsIndex = context.events.length;
	    const startStack = Array.from(stack);
	    return {
	      from: startEventsIndex,
	      restore
	    };
	    function restore() {
	      point4 = startPoint;
	      context.previous = startPrevious;
	      context.currentConstruct = startCurrentConstruct;
	      context.events.length = startEventsIndex;
	      stack = startStack;
	      accountForPotentialSkip();
	    }
	  }
	  function accountForPotentialSkip() {
	    if (point4.line in columnStart && point4.column < 2) {
	      point4.column = columnStart[point4.line];
	      point4.offset += columnStart[point4.line] - 1;
	    }
	  }
	}
	function sliceChunks(chunks, token) {
	  const startIndex = token.start._index;
	  const startBufferIndex = token.start._bufferIndex;
	  const endIndex = token.end._index;
	  const endBufferIndex = token.end._bufferIndex;
	  let view;
	  if (startIndex === endIndex) {
	    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
	  } else {
	    view = chunks.slice(startIndex, endIndex);
	    if (startBufferIndex > -1) {
	      const head = view[0];
	      if (typeof head === "string") {
	        view[0] = head.slice(startBufferIndex);
	      } else {
	        view.shift();
	      }
	    }
	    if (endBufferIndex > 0) {
	      view.push(chunks[endIndex].slice(0, endBufferIndex));
	    }
	  }
	  return view;
	}
	function serializeChunks(chunks, expandTabs) {
	  let index2 = -1;
	  const result = [];
	  let atTab;
	  while (++index2 < chunks.length) {
	    const chunk = chunks[index2];
	    let value;
	    if (typeof chunk === "string") {
	      value = chunk;
	    } else switch (chunk) {
	      case -5: {
	        value = "\r";
	        break;
	      }
	      case -4: {
	        value = "\n";
	        break;
	      }
	      case -3: {
	        value = "\r\n";
	        break;
	      }
	      case -2: {
	        value = expandTabs ? " " : "	";
	        break;
	      }
	      case -1: {
	        if (!expandTabs && atTab) continue;
	        value = " ";
	        break;
	      }
	      default: {
	        value = String.fromCharCode(chunk);
	      }
	    }
	    atTab = chunk === -2;
	    result.push(value);
	  }
	  return result.join("");
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/parse.js
	function parse(options) {
	  const settings = options || {};
	  const constructs2 = (
	    /** @type {FullNormalizedExtension} */
	    combineExtensions([constructs_exports, ...settings.extensions || []])
	  );
	  const parser = {
	    constructs: constructs2,
	    content: create(content),
	    defined: [],
	    document: create(document$1),
	    flow: create(flow),
	    lazy: {},
	    string: create(string),
	    text: create(text)
	  };
	  return parser;
	  function create(initial) {
	    return creator;
	    function creator(from) {
	      return createTokenizer(parser, initial, from);
	    }
	  }
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/postprocess.js
	function postprocess(events) {
	  while (!subtokenize(events)) {
	  }
	  return events;
	}

	// node_modules/.pnpm/micromark@4.0.2/node_modules/micromark/lib/preprocess.js
	var search = /[\0\t\n\r]/g;
	function preprocess() {
	  let column = 1;
	  let buffer = "";
	  let start = true;
	  let atCarriageReturn;
	  return preprocessor;
	  function preprocessor(value, encoding, end) {
	    const chunks = [];
	    let match;
	    let next;
	    let startPosition;
	    let endPosition;
	    let code2;
	    value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
	    startPosition = 0;
	    buffer = "";
	    if (start) {
	      if (value.charCodeAt(0) === 65279) {
	        startPosition++;
	      }
	      start = void 0;
	    }
	    while (startPosition < value.length) {
	      search.lastIndex = startPosition;
	      match = search.exec(value);
	      endPosition = match && match.index !== void 0 ? match.index : value.length;
	      code2 = value.charCodeAt(endPosition);
	      if (!match) {
	        buffer = value.slice(startPosition);
	        break;
	      }
	      if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
	        chunks.push(-3);
	        atCarriageReturn = void 0;
	      } else {
	        if (atCarriageReturn) {
	          chunks.push(-5);
	          atCarriageReturn = void 0;
	        }
	        if (startPosition < endPosition) {
	          chunks.push(value.slice(startPosition, endPosition));
	          column += endPosition - startPosition;
	        }
	        switch (code2) {
	          case 0: {
	            chunks.push(65533);
	            column++;
	            break;
	          }
	          case 9: {
	            next = Math.ceil(column / 4) * 4;
	            chunks.push(-2);
	            while (column++ < next) chunks.push(-1);
	            break;
	          }
	          case 10: {
	            chunks.push(-4);
	            column = 1;
	            break;
	          }
	          default: {
	            atCarriageReturn = true;
	            column = 1;
	          }
	        }
	      }
	      startPosition = endPosition + 1;
	    }
	    if (end) {
	      if (atCarriageReturn) chunks.push(-5);
	      if (buffer) chunks.push(buffer);
	      chunks.push(null);
	    }
	    return chunks;
	  }
	}

	// node_modules/.pnpm/micromark-util-decode-string@2.0.1/node_modules/micromark-util-decode-string/index.js
	var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
	function decodeString(value) {
	  return value.replace(characterEscapeOrReference, decode);
	}
	function decode($0, $1, $2) {
	  if ($1) {
	    return $1;
	  }
	  const head = $2.charCodeAt(0);
	  if (head === 35) {
	    const head2 = $2.charCodeAt(1);
	    const hex = head2 === 120 || head2 === 88;
	    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
	  }
	  return decodeNamedCharacterReference($2) || $0;
	}

	// node_modules/.pnpm/unist-util-stringify-position@4.0.0/node_modules/unist-util-stringify-position/lib/index.js
	function stringifyPosition(value) {
	  if (!value || typeof value !== "object") {
	    return "";
	  }
	  if ("position" in value || "type" in value) {
	    return position(value.position);
	  }
	  if ("start" in value || "end" in value) {
	    return position(value);
	  }
	  if ("line" in value || "column" in value) {
	    return point(value);
	  }
	  return "";
	}
	function point(point4) {
	  return index(point4 && point4.line) + ":" + index(point4 && point4.column);
	}
	function position(pos) {
	  return point(pos && pos.start) + "-" + point(pos && pos.end);
	}
	function index(value) {
	  return value && typeof value === "number" ? value : 1;
	}

	// node_modules/.pnpm/mdast-util-from-markdown@2.0.2/node_modules/mdast-util-from-markdown/lib/index.js
	var own2 = {}.hasOwnProperty;
	function fromMarkdown(value, encoding, options) {
	  if (typeof encoding !== "string") {
	    options = encoding;
	    encoding = void 0;
	  }
	  return compiler(options)(postprocess(parse(options).document().write(preprocess()(value, encoding, true))));
	}
	function compiler(options) {
	  const config = {
	    transforms: [],
	    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
	    enter: {
	      autolink: opener(link2),
	      autolinkProtocol: onenterdata,
	      autolinkEmail: onenterdata,
	      atxHeading: opener(heading2),
	      blockQuote: opener(blockQuote2),
	      characterEscape: onenterdata,
	      characterReference: onenterdata,
	      codeFenced: opener(codeFlow),
	      codeFencedFenceInfo: buffer,
	      codeFencedFenceMeta: buffer,
	      codeIndented: opener(codeFlow, buffer),
	      codeText: opener(codeText2, buffer),
	      codeTextData: onenterdata,
	      data: onenterdata,
	      codeFlowValue: onenterdata,
	      definition: opener(definition2),
	      definitionDestinationString: buffer,
	      definitionLabelString: buffer,
	      definitionTitleString: buffer,
	      emphasis: opener(emphasis2),
	      hardBreakEscape: opener(hardBreak2),
	      hardBreakTrailing: opener(hardBreak2),
	      htmlFlow: opener(html2, buffer),
	      htmlFlowData: onenterdata,
	      htmlText: opener(html2, buffer),
	      htmlTextData: onenterdata,
	      image: opener(image2),
	      label: buffer,
	      link: opener(link2),
	      listItem: opener(listItem2),
	      listItemValue: onenterlistitemvalue,
	      listOrdered: opener(list3, onenterlistordered),
	      listUnordered: opener(list3),
	      paragraph: opener(paragraph2),
	      reference: onenterreference,
	      referenceString: buffer,
	      resourceDestinationString: buffer,
	      resourceTitleString: buffer,
	      setextHeading: opener(heading2),
	      strong: opener(strong2),
	      thematicBreak: opener(thematicBreak3)
	    },
	    exit: {
	      atxHeading: closer(),
	      atxHeadingSequence: onexitatxheadingsequence,
	      autolink: closer(),
	      autolinkEmail: onexitautolinkemail,
	      autolinkProtocol: onexitautolinkprotocol,
	      blockQuote: closer(),
	      characterEscapeValue: onexitdata,
	      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
	      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
	      characterReferenceValue: onexitcharacterreferencevalue,
	      characterReference: onexitcharacterreference,
	      codeFenced: closer(onexitcodefenced),
	      codeFencedFence: onexitcodefencedfence,
	      codeFencedFenceInfo: onexitcodefencedfenceinfo,
	      codeFencedFenceMeta: onexitcodefencedfencemeta,
	      codeFlowValue: onexitdata,
	      codeIndented: closer(onexitcodeindented),
	      codeText: closer(onexitcodetext),
	      codeTextData: onexitdata,
	      data: onexitdata,
	      definition: closer(),
	      definitionDestinationString: onexitdefinitiondestinationstring,
	      definitionLabelString: onexitdefinitionlabelstring,
	      definitionTitleString: onexitdefinitiontitlestring,
	      emphasis: closer(),
	      hardBreakEscape: closer(onexithardbreak),
	      hardBreakTrailing: closer(onexithardbreak),
	      htmlFlow: closer(onexithtmlflow),
	      htmlFlowData: onexitdata,
	      htmlText: closer(onexithtmltext),
	      htmlTextData: onexitdata,
	      image: closer(onexitimage),
	      label: onexitlabel,
	      labelText: onexitlabeltext,
	      lineEnding: onexitlineending,
	      link: closer(onexitlink),
	      listItem: closer(),
	      listOrdered: closer(),
	      listUnordered: closer(),
	      paragraph: closer(),
	      referenceString: onexitreferencestring,
	      resourceDestinationString: onexitresourcedestinationstring,
	      resourceTitleString: onexitresourcetitlestring,
	      resource: onexitresource,
	      setextHeading: closer(onexitsetextheading),
	      setextHeadingLineSequence: onexitsetextheadinglinesequence,
	      setextHeadingText: onexitsetextheadingtext,
	      strong: closer(),
	      thematicBreak: closer()
	    }
	  };
	  configure(config, (options || {}).mdastExtensions || []);
	  const data = {};
	  return compile;
	  function compile(events) {
	    let tree = {
	      type: "root",
	      children: []
	    };
	    const context = {
	      stack: [tree],
	      tokenStack: [],
	      config,
	      enter,
	      exit: exit2,
	      buffer,
	      resume,
	      data
	    };
	    const listStack = [];
	    let index2 = -1;
	    while (++index2 < events.length) {
	      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
	        if (events[index2][0] === "enter") {
	          listStack.push(index2);
	        } else {
	          const tail = listStack.pop();
	          index2 = prepareList(events, tail, index2);
	        }
	      }
	    }
	    index2 = -1;
	    while (++index2 < events.length) {
	      const handler = config[events[index2][0]];
	      if (own2.call(handler, events[index2][1].type)) {
	        handler[events[index2][1].type].call(Object.assign({
	          sliceSerialize: events[index2][2].sliceSerialize
	        }, context), events[index2][1]);
	      }
	    }
	    if (context.tokenStack.length > 0) {
	      const tail = context.tokenStack[context.tokenStack.length - 1];
	      const handler = tail[1] || defaultOnError;
	      handler.call(context, void 0, tail[0]);
	    }
	    tree.position = {
	      start: point2(events.length > 0 ? events[0][1].start : {
	        line: 1,
	        column: 1,
	        offset: 0
	      }),
	      end: point2(events.length > 0 ? events[events.length - 2][1].end : {
	        line: 1,
	        column: 1,
	        offset: 0
	      })
	    };
	    index2 = -1;
	    while (++index2 < config.transforms.length) {
	      tree = config.transforms[index2](tree) || tree;
	    }
	    return tree;
	  }
	  function prepareList(events, start, length) {
	    let index2 = start - 1;
	    let containerBalance = -1;
	    let listSpread = false;
	    let listItem3;
	    let lineIndex;
	    let firstBlankLineIndex;
	    let atMarker;
	    while (++index2 <= length) {
	      const event = events[index2];
	      switch (event[1].type) {
	        case "listUnordered":
	        case "listOrdered":
	        case "blockQuote": {
	          if (event[0] === "enter") {
	            containerBalance++;
	          } else {
	            containerBalance--;
	          }
	          atMarker = void 0;
	          break;
	        }
	        case "lineEndingBlank": {
	          if (event[0] === "enter") {
	            if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
	              firstBlankLineIndex = index2;
	            }
	            atMarker = void 0;
	          }
	          break;
	        }
	        case "linePrefix":
	        case "listItemValue":
	        case "listItemMarker":
	        case "listItemPrefix":
	        case "listItemPrefixWhitespace": {
	          break;
	        }
	        default: {
	          atMarker = void 0;
	        }
	      }
	      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
	        if (listItem3) {
	          let tailIndex = index2;
	          lineIndex = void 0;
	          while (tailIndex--) {
	            const tailEvent = events[tailIndex];
	            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
	              if (tailEvent[0] === "exit") continue;
	              if (lineIndex) {
	                events[lineIndex][1].type = "lineEndingBlank";
	                listSpread = true;
	              }
	              tailEvent[1].type = "lineEnding";
	              lineIndex = tailIndex;
	            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") ; else {
	              break;
	            }
	          }
	          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
	            listItem3._spread = true;
	          }
	          listItem3.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
	          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
	          index2++;
	          length++;
	        }
	        if (event[1].type === "listItemPrefix") {
	          const item = {
	            type: "listItem",
	            _spread: false,
	            start: Object.assign({}, event[1].start),
	            // @ts-expect-error: we’ll add `end` in a second.
	            end: void 0
	          };
	          listItem3 = item;
	          events.splice(index2, 0, ["enter", item, event[2]]);
	          index2++;
	          length++;
	          firstBlankLineIndex = void 0;
	          atMarker = true;
	        }
	      }
	    }
	    events[start][1]._spread = listSpread;
	    return length;
	  }
	  function opener(create, and) {
	    return open;
	    function open(token) {
	      enter.call(this, create(token), token);
	      if (and) and.call(this, token);
	    }
	  }
	  function buffer() {
	    this.stack.push({
	      type: "fragment",
	      children: []
	    });
	  }
	  function enter(node2, token, errorHandler) {
	    const parent = this.stack[this.stack.length - 1];
	    const siblings = parent.children;
	    siblings.push(node2);
	    this.stack.push(node2);
	    this.tokenStack.push([token, errorHandler || void 0]);
	    node2.position = {
	      start: point2(token.start),
	      // @ts-expect-error: `end` will be patched later.
	      end: void 0
	    };
	  }
	  function closer(and) {
	    return close;
	    function close(token) {
	      if (and) and.call(this, token);
	      exit2.call(this, token);
	    }
	  }
	  function exit2(token, onExitError) {
	    const node2 = this.stack.pop();
	    const open = this.tokenStack.pop();
	    if (!open) {
	      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
	        start: token.start,
	        end: token.end
	      }) + "): it\u2019s not open");
	    } else if (open[0].type !== token.type) {
	      if (onExitError) {
	        onExitError.call(this, token, open[0]);
	      } else {
	        const handler = open[1] || defaultOnError;
	        handler.call(this, token, open[0]);
	      }
	    }
	    node2.position.end = point2(token.end);
	  }
	  function resume() {
	    return toString(this.stack.pop());
	  }
	  function onenterlistordered() {
	    this.data.expectingFirstListItemValue = true;
	  }
	  function onenterlistitemvalue(token) {
	    if (this.data.expectingFirstListItemValue) {
	      const ancestor = this.stack[this.stack.length - 2];
	      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
	      this.data.expectingFirstListItemValue = void 0;
	    }
	  }
	  function onexitcodefencedfenceinfo() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.lang = data2;
	  }
	  function onexitcodefencedfencemeta() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.meta = data2;
	  }
	  function onexitcodefencedfence() {
	    if (this.data.flowCodeInside) return;
	    this.buffer();
	    this.data.flowCodeInside = true;
	  }
	  function onexitcodefenced() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
	    this.data.flowCodeInside = void 0;
	  }
	  function onexitcodeindented() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.value = data2.replace(/(\r?\n|\r)$/g, "");
	  }
	  function onexitdefinitionlabelstring(token) {
	    const label = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.label = label;
	    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	  }
	  function onexitdefinitiontitlestring() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.title = data2;
	  }
	  function onexitdefinitiondestinationstring() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.url = data2;
	  }
	  function onexitatxheadingsequence(token) {
	    const node2 = this.stack[this.stack.length - 1];
	    if (!node2.depth) {
	      const depth = this.sliceSerialize(token).length;
	      node2.depth = depth;
	    }
	  }
	  function onexitsetextheadingtext() {
	    this.data.setextHeadingSlurpLineEnding = true;
	  }
	  function onexitsetextheadinglinesequence(token) {
	    const node2 = this.stack[this.stack.length - 1];
	    node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
	  }
	  function onexitsetextheading() {
	    this.data.setextHeadingSlurpLineEnding = void 0;
	  }
	  function onenterdata(token) {
	    const node2 = this.stack[this.stack.length - 1];
	    const siblings = node2.children;
	    let tail = siblings[siblings.length - 1];
	    if (!tail || tail.type !== "text") {
	      tail = text4();
	      tail.position = {
	        start: point2(token.start),
	        // @ts-expect-error: we’ll add `end` later.
	        end: void 0
	      };
	      siblings.push(tail);
	    }
	    this.stack.push(tail);
	  }
	  function onexitdata(token) {
	    const tail = this.stack.pop();
	    tail.value += this.sliceSerialize(token);
	    tail.position.end = point2(token.end);
	  }
	  function onexitlineending(token) {
	    const context = this.stack[this.stack.length - 1];
	    if (this.data.atHardBreak) {
	      const tail = context.children[context.children.length - 1];
	      tail.position.end = point2(token.end);
	      this.data.atHardBreak = void 0;
	      return;
	    }
	    if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
	      onenterdata.call(this, token);
	      onexitdata.call(this, token);
	    }
	  }
	  function onexithardbreak() {
	    this.data.atHardBreak = true;
	  }
	  function onexithtmlflow() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.value = data2;
	  }
	  function onexithtmltext() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.value = data2;
	  }
	  function onexitcodetext() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.value = data2;
	  }
	  function onexitlink() {
	    const node2 = this.stack[this.stack.length - 1];
	    if (this.data.inReference) {
	      const referenceType = this.data.referenceType || "shortcut";
	      node2.type += "Reference";
	      node2.referenceType = referenceType;
	      delete node2.url;
	      delete node2.title;
	    } else {
	      delete node2.identifier;
	      delete node2.label;
	    }
	    this.data.referenceType = void 0;
	  }
	  function onexitimage() {
	    const node2 = this.stack[this.stack.length - 1];
	    if (this.data.inReference) {
	      const referenceType = this.data.referenceType || "shortcut";
	      node2.type += "Reference";
	      node2.referenceType = referenceType;
	      delete node2.url;
	      delete node2.title;
	    } else {
	      delete node2.identifier;
	      delete node2.label;
	    }
	    this.data.referenceType = void 0;
	  }
	  function onexitlabeltext(token) {
	    const string3 = this.sliceSerialize(token);
	    const ancestor = this.stack[this.stack.length - 2];
	    ancestor.label = decodeString(string3);
	    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
	  }
	  function onexitlabel() {
	    const fragment = this.stack[this.stack.length - 1];
	    const value = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    this.data.inReference = true;
	    if (node2.type === "link") {
	      const children = fragment.children;
	      node2.children = children;
	    } else {
	      node2.alt = value;
	    }
	  }
	  function onexitresourcedestinationstring() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.url = data2;
	  }
	  function onexitresourcetitlestring() {
	    const data2 = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.title = data2;
	  }
	  function onexitresource() {
	    this.data.inReference = void 0;
	  }
	  function onenterreference() {
	    this.data.referenceType = "collapsed";
	  }
	  function onexitreferencestring(token) {
	    const label = this.resume();
	    const node2 = this.stack[this.stack.length - 1];
	    node2.label = label;
	    node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	    this.data.referenceType = "full";
	  }
	  function onexitcharacterreferencemarker(token) {
	    this.data.characterReferenceType = token.type;
	  }
	  function onexitcharacterreferencevalue(token) {
	    const data2 = this.sliceSerialize(token);
	    const type = this.data.characterReferenceType;
	    let value;
	    if (type) {
	      value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
	      this.data.characterReferenceType = void 0;
	    } else {
	      const result = decodeNamedCharacterReference(data2);
	      value = result;
	    }
	    const tail = this.stack[this.stack.length - 1];
	    tail.value += value;
	  }
	  function onexitcharacterreference(token) {
	    const tail = this.stack.pop();
	    tail.position.end = point2(token.end);
	  }
	  function onexitautolinkprotocol(token) {
	    onexitdata.call(this, token);
	    const node2 = this.stack[this.stack.length - 1];
	    node2.url = this.sliceSerialize(token);
	  }
	  function onexitautolinkemail(token) {
	    onexitdata.call(this, token);
	    const node2 = this.stack[this.stack.length - 1];
	    node2.url = "mailto:" + this.sliceSerialize(token);
	  }
	  function blockQuote2() {
	    return {
	      type: "blockquote",
	      children: []
	    };
	  }
	  function codeFlow() {
	    return {
	      type: "code",
	      lang: null,
	      meta: null,
	      value: ""
	    };
	  }
	  function codeText2() {
	    return {
	      type: "inlineCode",
	      value: ""
	    };
	  }
	  function definition2() {
	    return {
	      type: "definition",
	      identifier: "",
	      label: null,
	      title: null,
	      url: ""
	    };
	  }
	  function emphasis2() {
	    return {
	      type: "emphasis",
	      children: []
	    };
	  }
	  function heading2() {
	    return {
	      type: "heading",
	      // @ts-expect-error `depth` will be set later.
	      depth: 0,
	      children: []
	    };
	  }
	  function hardBreak2() {
	    return {
	      type: "break"
	    };
	  }
	  function html2() {
	    return {
	      type: "html",
	      value: ""
	    };
	  }
	  function image2() {
	    return {
	      type: "image",
	      title: null,
	      url: "",
	      alt: null
	    };
	  }
	  function link2() {
	    return {
	      type: "link",
	      title: null,
	      url: "",
	      children: []
	    };
	  }
	  function list3(token) {
	    return {
	      type: "list",
	      ordered: token.type === "listOrdered",
	      start: null,
	      spread: token._spread,
	      children: []
	    };
	  }
	  function listItem2(token) {
	    return {
	      type: "listItem",
	      spread: token._spread,
	      checked: null,
	      children: []
	    };
	  }
	  function paragraph2() {
	    return {
	      type: "paragraph",
	      children: []
	    };
	  }
	  function strong2() {
	    return {
	      type: "strong",
	      children: []
	    };
	  }
	  function text4() {
	    return {
	      type: "text",
	      value: ""
	    };
	  }
	  function thematicBreak3() {
	    return {
	      type: "thematicBreak"
	    };
	  }
	}
	function point2(d) {
	  return {
	    line: d.line,
	    column: d.column,
	    offset: d.offset
	  };
	}
	function configure(combined, extensions) {
	  let index2 = -1;
	  while (++index2 < extensions.length) {
	    const value = extensions[index2];
	    if (Array.isArray(value)) {
	      configure(combined, value);
	    } else {
	      extension(combined, value);
	    }
	  }
	}
	function extension(combined, extension2) {
	  let key;
	  for (key in extension2) {
	    if (own2.call(extension2, key)) {
	      switch (key) {
	        case "canContainEols": {
	          const right = extension2[key];
	          if (right) {
	            combined[key].push(...right);
	          }
	          break;
	        }
	        case "transforms": {
	          const right = extension2[key];
	          if (right) {
	            combined[key].push(...right);
	          }
	          break;
	        }
	        case "enter":
	        case "exit": {
	          const right = extension2[key];
	          if (right) {
	            Object.assign(combined[key], right);
	          }
	          break;
	        }
	      }
	    }
	  }
	}
	function defaultOnError(left, right) {
	  if (left) {
	    throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
	      start: left.start,
	      end: left.end
	    }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
	      start: right.start,
	      end: right.end
	    }) + ") is open");
	  } else {
	    throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
	      start: right.start,
	      end: right.end
	    }) + ") is still open");
	  }
	}

	// node_modules/.pnpm/remark-parse@11.0.0/node_modules/remark-parse/lib/index.js
	function remarkParse(options) {
	  const self2 = this;
	  self2.parser = parser;
	  function parser(doc) {
	    return fromMarkdown(doc, {
	      ...self2.data("settings"),
	      ...options,
	      // Note: these options are not in the readme.
	      // The goal is for them to be set by plugins on `data` instead of being
	      // passed by users.
	      extensions: self2.data("micromarkExtensions") || [],
	      mdastExtensions: self2.data("fromMarkdownExtensions") || []
	    });
	  }
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
	function blockquote(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "blockquote",
	    properties: {},
	    children: state.wrap(state.all(node2), true)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/break.js
	function hardBreak(state, node2) {
	  const result = { type: "element", tagName: "br", properties: {}, children: [] };
	  state.patch(node2, result);
	  return [state.applyData(node2, result), { type: "text", value: "\n" }];
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/code.js
	function code(state, node2) {
	  const value = node2.value ? node2.value + "\n" : "";
	  const properties = {};
	  if (node2.lang) {
	    properties.className = ["language-" + node2.lang];
	  }
	  let result = {
	    type: "element",
	    tagName: "code",
	    properties,
	    children: [{ type: "text", value }]
	  };
	  if (node2.meta) {
	    result.data = { meta: node2.meta };
	  }
	  state.patch(node2, result);
	  result = state.applyData(node2, result);
	  result = { type: "element", tagName: "pre", properties: {}, children: [result] };
	  state.patch(node2, result);
	  return result;
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/delete.js
	function strikethrough(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "del",
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
	function emphasis(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "em",
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
	function footnoteReference(state, node2) {
	  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
	  const id = String(node2.identifier).toUpperCase();
	  const safeId = normalizeUri(id.toLowerCase());
	  const index2 = state.footnoteOrder.indexOf(id);
	  let counter;
	  let reuseCounter = state.footnoteCounts.get(id);
	  if (reuseCounter === void 0) {
	    reuseCounter = 0;
	    state.footnoteOrder.push(id);
	    counter = state.footnoteOrder.length;
	  } else {
	    counter = index2 + 1;
	  }
	  reuseCounter += 1;
	  state.footnoteCounts.set(id, reuseCounter);
	  const link2 = {
	    type: "element",
	    tagName: "a",
	    properties: {
	      href: "#" + clobberPrefix + "fn-" + safeId,
	      id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
	      dataFootnoteRef: true,
	      ariaDescribedBy: ["footnote-label"]
	    },
	    children: [{ type: "text", value: String(counter) }]
	  };
	  state.patch(node2, link2);
	  const sup = {
	    type: "element",
	    tagName: "sup",
	    properties: {},
	    children: [link2]
	  };
	  state.patch(node2, sup);
	  return state.applyData(node2, sup);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/heading.js
	function heading(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "h" + node2.depth,
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/html.js
	function html(state, node2) {
	  if (state.options.allowDangerousHtml) {
	    const result = { type: "raw", value: node2.value };
	    state.patch(node2, result);
	    return state.applyData(node2, result);
	  }
	  return void 0;
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/revert.js
	function revert(state, node2) {
	  const subtype = node2.referenceType;
	  let suffix = "]";
	  if (subtype === "collapsed") {
	    suffix += "[]";
	  } else if (subtype === "full") {
	    suffix += "[" + (node2.label || node2.identifier) + "]";
	  }
	  if (node2.type === "imageReference") {
	    return [{ type: "text", value: "![" + node2.alt + suffix }];
	  }
	  const contents = state.all(node2);
	  const head = contents[0];
	  if (head && head.type === "text") {
	    head.value = "[" + head.value;
	  } else {
	    contents.unshift({ type: "text", value: "[" });
	  }
	  const tail = contents[contents.length - 1];
	  if (tail && tail.type === "text") {
	    tail.value += suffix;
	  } else {
	    contents.push({ type: "text", value: suffix });
	  }
	  return contents;
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
	function imageReference(state, node2) {
	  const id = String(node2.identifier).toUpperCase();
	  const definition2 = state.definitionById.get(id);
	  if (!definition2) {
	    return revert(state, node2);
	  }
	  const properties = { src: normalizeUri(definition2.url || ""), alt: node2.alt };
	  if (definition2.title !== null && definition2.title !== void 0) {
	    properties.title = definition2.title;
	  }
	  const result = { type: "element", tagName: "img", properties, children: [] };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/image.js
	function image(state, node2) {
	  const properties = { src: normalizeUri(node2.url) };
	  if (node2.alt !== null && node2.alt !== void 0) {
	    properties.alt = node2.alt;
	  }
	  if (node2.title !== null && node2.title !== void 0) {
	    properties.title = node2.title;
	  }
	  const result = { type: "element", tagName: "img", properties, children: [] };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
	function inlineCode(state, node2) {
	  const text4 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
	  state.patch(node2, text4);
	  const result = {
	    type: "element",
	    tagName: "code",
	    properties: {},
	    children: [text4]
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
	function linkReference(state, node2) {
	  const id = String(node2.identifier).toUpperCase();
	  const definition2 = state.definitionById.get(id);
	  if (!definition2) {
	    return revert(state, node2);
	  }
	  const properties = { href: normalizeUri(definition2.url || "") };
	  if (definition2.title !== null && definition2.title !== void 0) {
	    properties.title = definition2.title;
	  }
	  const result = {
	    type: "element",
	    tagName: "a",
	    properties,
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/link.js
	function link(state, node2) {
	  const properties = { href: normalizeUri(node2.url) };
	  if (node2.title !== null && node2.title !== void 0) {
	    properties.title = node2.title;
	  }
	  const result = {
	    type: "element",
	    tagName: "a",
	    properties,
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/list-item.js
	function listItem(state, node2, parent) {
	  const results = state.all(node2);
	  const loose = parent ? listLoose(parent) : listItemLoose(node2);
	  const properties = {};
	  const children = [];
	  if (typeof node2.checked === "boolean") {
	    const head = results[0];
	    let paragraph2;
	    if (head && head.type === "element" && head.tagName === "p") {
	      paragraph2 = head;
	    } else {
	      paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
	      results.unshift(paragraph2);
	    }
	    if (paragraph2.children.length > 0) {
	      paragraph2.children.unshift({ type: "text", value: " " });
	    }
	    paragraph2.children.unshift({
	      type: "element",
	      tagName: "input",
	      properties: { type: "checkbox", checked: node2.checked, disabled: true },
	      children: []
	    });
	    properties.className = ["task-list-item"];
	  }
	  let index2 = -1;
	  while (++index2 < results.length) {
	    const child = results[index2];
	    if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
	      children.push({ type: "text", value: "\n" });
	    }
	    if (child.type === "element" && child.tagName === "p" && !loose) {
	      children.push(...child.children);
	    } else {
	      children.push(child);
	    }
	  }
	  const tail = results[results.length - 1];
	  if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
	    children.push({ type: "text", value: "\n" });
	  }
	  const result = { type: "element", tagName: "li", properties, children };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}
	function listLoose(node2) {
	  let loose = false;
	  if (node2.type === "list") {
	    loose = node2.spread || false;
	    const children = node2.children;
	    let index2 = -1;
	    while (!loose && ++index2 < children.length) {
	      loose = listItemLoose(children[index2]);
	    }
	  }
	  return loose;
	}
	function listItemLoose(node2) {
	  const spread = node2.spread;
	  return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/list.js
	function list2(state, node2) {
	  const properties = {};
	  const results = state.all(node2);
	  let index2 = -1;
	  if (typeof node2.start === "number" && node2.start !== 1) {
	    properties.start = node2.start;
	  }
	  while (++index2 < results.length) {
	    const child = results[index2];
	    if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
	      properties.className = ["contains-task-list"];
	      break;
	    }
	  }
	  const result = {
	    type: "element",
	    tagName: node2.ordered ? "ol" : "ul",
	    properties,
	    children: state.wrap(results, true)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
	function paragraph(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "p",
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/root.js
	function root$3(state, node2) {
	  const result = { type: "root", children: state.wrap(state.all(node2)) };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/strong.js
	function strong(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "strong",
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/unist-util-position@5.0.0/node_modules/unist-util-position/lib/index.js
	var pointEnd = point3("end");
	var pointStart = point3("start");
	function point3(type) {
	  return point4;
	  function point4(node2) {
	    const point5 = node2 && node2.position && node2.position[type] || {};
	    if (typeof point5.line === "number" && point5.line > 0 && typeof point5.column === "number" && point5.column > 0) {
	      return {
	        line: point5.line,
	        column: point5.column,
	        offset: typeof point5.offset === "number" && point5.offset > -1 ? point5.offset : void 0
	      };
	    }
	  }
	}
	function position2(node2) {
	  const start = pointStart(node2);
	  const end = pointEnd(node2);
	  if (start && end) {
	    return { start, end };
	  }
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/table.js
	function table(state, node2) {
	  const rows = state.all(node2);
	  const firstRow = rows.shift();
	  const tableContent = [];
	  if (firstRow) {
	    const head = {
	      type: "element",
	      tagName: "thead",
	      properties: {},
	      children: state.wrap([firstRow], true)
	    };
	    state.patch(node2.children[0], head);
	    tableContent.push(head);
	  }
	  if (rows.length > 0) {
	    const body = {
	      type: "element",
	      tagName: "tbody",
	      properties: {},
	      children: state.wrap(rows, true)
	    };
	    const start = pointStart(node2.children[1]);
	    const end = pointEnd(node2.children[node2.children.length - 1]);
	    if (start && end) body.position = { start, end };
	    tableContent.push(body);
	  }
	  const result = {
	    type: "element",
	    tagName: "table",
	    properties: {},
	    children: state.wrap(tableContent, true)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/table-row.js
	function tableRow(state, node2, parent) {
	  const siblings = parent ? parent.children : void 0;
	  const rowIndex = siblings ? siblings.indexOf(node2) : 1;
	  const tagName = rowIndex === 0 ? "th" : "td";
	  const align = parent && parent.type === "table" ? parent.align : void 0;
	  const length = align ? align.length : node2.children.length;
	  let cellIndex = -1;
	  const cells = [];
	  while (++cellIndex < length) {
	    const cell = node2.children[cellIndex];
	    const properties = {};
	    const alignValue = align ? align[cellIndex] : void 0;
	    if (alignValue) {
	      properties.align = alignValue;
	    }
	    let result2 = { type: "element", tagName, properties, children: [] };
	    if (cell) {
	      result2.children = state.all(cell);
	      state.patch(cell, result2);
	      result2 = state.applyData(cell, result2);
	    }
	    cells.push(result2);
	  }
	  const result = {
	    type: "element",
	    tagName: "tr",
	    properties: {},
	    children: state.wrap(cells, true)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
	function tableCell(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "td",
	    // Assume body cell.
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/trim-lines@3.0.1/node_modules/trim-lines/index.js
	var tab = 9;
	var space = 32;
	function trimLines(value) {
	  const source = String(value);
	  const search2 = /\r?\n|\r/g;
	  let match = search2.exec(source);
	  let last = 0;
	  const lines = [];
	  while (match) {
	    lines.push(
	      trimLine(source.slice(last, match.index), last > 0, true),
	      match[0]
	    );
	    last = match.index + match[0].length;
	    match = search2.exec(source);
	  }
	  lines.push(trimLine(source.slice(last), last > 0, false));
	  return lines.join("");
	}
	function trimLine(value, start, end) {
	  let startIndex = 0;
	  let endIndex = value.length;
	  if (start) {
	    let code2 = value.codePointAt(startIndex);
	    while (code2 === tab || code2 === space) {
	      startIndex++;
	      code2 = value.codePointAt(startIndex);
	    }
	  }
	  if (end) {
	    let code2 = value.codePointAt(endIndex - 1);
	    while (code2 === tab || code2 === space) {
	      endIndex--;
	      code2 = value.codePointAt(endIndex - 1);
	    }
	  }
	  return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/text.js
	function text3(state, node2) {
	  const result = { type: "text", value: trimLines(String(node2.value)) };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
	function thematicBreak2(state, node2) {
	  const result = {
	    type: "element",
	    tagName: "hr",
	    properties: {},
	    children: []
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/handlers/index.js
	var handlers = {
	  blockquote,
	  break: hardBreak,
	  code,
	  delete: strikethrough,
	  emphasis,
	  footnoteReference,
	  heading,
	  html,
	  imageReference,
	  image,
	  inlineCode,
	  linkReference,
	  link,
	  listItem,
	  list: list2,
	  paragraph,
	  // @ts-expect-error: root is different, but hard to type.
	  root: root$3,
	  strong,
	  table,
	  tableCell,
	  tableRow,
	  text: text3,
	  thematicBreak: thematicBreak2,
	  toml: ignore,
	  yaml: ignore,
	  definition: ignore,
	  footnoteDefinition: ignore
	};
	function ignore() {
	  return void 0;
	}

	// node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/types.js
	var VOID = -1;
	var PRIMITIVE = 0;
	var ARRAY = 1;
	var OBJECT = 2;
	var DATE = 3;
	var REGEXP = 4;
	var MAP = 5;
	var SET = 6;
	var ERROR = 7;
	var BIGINT = 8;

	// node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/deserialize.js
	var env = typeof self === "object" ? self : globalThis;
	var deserializer = ($, _) => {
	  const as = (out, index2) => {
	    $.set(index2, out);
	    return out;
	  };
	  const unpair = (index2) => {
	    if ($.has(index2))
	      return $.get(index2);
	    const [type, value] = _[index2];
	    switch (type) {
	      case PRIMITIVE:
	      case VOID:
	        return as(value, index2);
	      case ARRAY: {
	        const arr = as([], index2);
	        for (const index3 of value)
	          arr.push(unpair(index3));
	        return arr;
	      }
	      case OBJECT: {
	        const object = as({}, index2);
	        for (const [key, index3] of value)
	          object[unpair(key)] = unpair(index3);
	        return object;
	      }
	      case DATE:
	        return as(new Date(value), index2);
	      case REGEXP: {
	        const { source, flags } = value;
	        return as(new RegExp(source, flags), index2);
	      }
	      case MAP: {
	        const map = as(/* @__PURE__ */ new Map(), index2);
	        for (const [key, index3] of value)
	          map.set(unpair(key), unpair(index3));
	        return map;
	      }
	      case SET: {
	        const set = as(/* @__PURE__ */ new Set(), index2);
	        for (const index3 of value)
	          set.add(unpair(index3));
	        return set;
	      }
	      case ERROR: {
	        const { name, message } = value;
	        return as(new env[name](message), index2);
	      }
	      case BIGINT:
	        return as(BigInt(value), index2);
	      case "BigInt":
	        return as(Object(BigInt(value)), index2);
	      case "ArrayBuffer":
	        return as(new Uint8Array(value).buffer, value);
	      case "DataView": {
	        const { buffer } = new Uint8Array(value);
	        return as(new DataView(buffer), value);
	      }
	    }
	    return as(new env[type](value), index2);
	  };
	  return unpair;
	};
	var deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);

	// node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/serialize.js
	var EMPTY = "";
	var { toString: toString2 } = {};
	var { keys } = Object;
	var typeOf = (value) => {
	  const type = typeof value;
	  if (type !== "object" || !value)
	    return [PRIMITIVE, type];
	  const asString = toString2.call(value).slice(8, -1);
	  switch (asString) {
	    case "Array":
	      return [ARRAY, EMPTY];
	    case "Object":
	      return [OBJECT, EMPTY];
	    case "Date":
	      return [DATE, EMPTY];
	    case "RegExp":
	      return [REGEXP, EMPTY];
	    case "Map":
	      return [MAP, EMPTY];
	    case "Set":
	      return [SET, EMPTY];
	    case "DataView":
	      return [ARRAY, asString];
	  }
	  if (asString.includes("Array"))
	    return [ARRAY, asString];
	  if (asString.includes("Error"))
	    return [ERROR, asString];
	  return [OBJECT, asString];
	};
	var shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
	var serializer = (strict, json, $, _) => {
	  const as = (out, value) => {
	    const index2 = _.push(out) - 1;
	    $.set(value, index2);
	    return index2;
	  };
	  const pair = (value) => {
	    if ($.has(value))
	      return $.get(value);
	    let [TYPE, type] = typeOf(value);
	    switch (TYPE) {
	      case PRIMITIVE: {
	        let entry = value;
	        switch (type) {
	          case "bigint":
	            TYPE = BIGINT;
	            entry = value.toString();
	            break;
	          case "function":
	          case "symbol":
	            if (strict)
	              throw new TypeError("unable to serialize " + type);
	            entry = null;
	            break;
	          case "undefined":
	            return as([VOID], value);
	        }
	        return as([TYPE, entry], value);
	      }
	      case ARRAY: {
	        if (type) {
	          let spread = value;
	          if (type === "DataView") {
	            spread = new Uint8Array(value.buffer);
	          } else if (type === "ArrayBuffer") {
	            spread = new Uint8Array(value);
	          }
	          return as([type, [...spread]], value);
	        }
	        const arr = [];
	        const index2 = as([TYPE, arr], value);
	        for (const entry of value)
	          arr.push(pair(entry));
	        return index2;
	      }
	      case OBJECT: {
	        if (type) {
	          switch (type) {
	            case "BigInt":
	              return as([type, value.toString()], value);
	            case "Boolean":
	            case "Number":
	            case "String":
	              return as([type, value.valueOf()], value);
	          }
	        }
	        if (json && "toJSON" in value)
	          return pair(value.toJSON());
	        const entries = [];
	        const index2 = as([TYPE, entries], value);
	        for (const key of keys(value)) {
	          if (strict || !shouldSkip(typeOf(value[key])))
	            entries.push([pair(key), pair(value[key])]);
	        }
	        return index2;
	      }
	      case DATE:
	        return as([TYPE, value.toISOString()], value);
	      case REGEXP: {
	        const { source, flags } = value;
	        return as([TYPE, { source, flags }], value);
	      }
	      case MAP: {
	        const entries = [];
	        const index2 = as([TYPE, entries], value);
	        for (const [key, entry] of value) {
	          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))
	            entries.push([pair(key), pair(entry)]);
	        }
	        return index2;
	      }
	      case SET: {
	        const entries = [];
	        const index2 = as([TYPE, entries], value);
	        for (const entry of value) {
	          if (strict || !shouldSkip(typeOf(entry)))
	            entries.push(pair(entry));
	        }
	        return index2;
	      }
	    }
	    const { message } = value;
	    return as([TYPE, { name: type, message }], value);
	  };
	  return pair;
	};
	var serialize = (value, { json, lossy } = {}) => {
	  const _ = [];
	  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;
	};

	// node_modules/.pnpm/@ungap+structured-clone@1.3.0/node_modules/@ungap/structured-clone/esm/index.js
	var esm_default = typeof structuredClone === "function" ? (
	  /* c8 ignore start */
	  (any, options) => options && ("json" in options || "lossy" in options) ? deserialize(serialize(any, options)) : structuredClone(any)
	) : (any, options) => deserialize(serialize(any, options));

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/footer.js
	function defaultFootnoteBackContent(_, rereferenceIndex) {
	  const result = [{ type: "text", value: "\u21A9" }];
	  if (rereferenceIndex > 1) {
	    result.push({
	      type: "element",
	      tagName: "sup",
	      properties: {},
	      children: [{ type: "text", value: String(rereferenceIndex) }]
	    });
	  }
	  return result;
	}
	function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
	  return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
	}
	function footer(state) {
	  const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
	  const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
	  const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
	  const footnoteLabel = state.options.footnoteLabel || "Footnotes";
	  const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
	  const footnoteLabelProperties = state.options.footnoteLabelProperties || {
	    className: ["sr-only"]
	  };
	  const listItems = [];
	  let referenceIndex = -1;
	  while (++referenceIndex < state.footnoteOrder.length) {
	    const definition2 = state.footnoteById.get(
	      state.footnoteOrder[referenceIndex]
	    );
	    if (!definition2) {
	      continue;
	    }
	    const content3 = state.all(definition2);
	    const id = String(definition2.identifier).toUpperCase();
	    const safeId = normalizeUri(id.toLowerCase());
	    let rereferenceIndex = 0;
	    const backReferences = [];
	    const counts = state.footnoteCounts.get(id);
	    while (counts !== void 0 && ++rereferenceIndex <= counts) {
	      if (backReferences.length > 0) {
	        backReferences.push({ type: "text", value: " " });
	      }
	      let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
	      if (typeof children === "string") {
	        children = { type: "text", value: children };
	      }
	      backReferences.push({
	        type: "element",
	        tagName: "a",
	        properties: {
	          href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
	          dataFootnoteBackref: "",
	          ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
	          className: ["data-footnote-backref"]
	        },
	        children: Array.isArray(children) ? children : [children]
	      });
	    }
	    const tail = content3[content3.length - 1];
	    if (tail && tail.type === "element" && tail.tagName === "p") {
	      const tailTail = tail.children[tail.children.length - 1];
	      if (tailTail && tailTail.type === "text") {
	        tailTail.value += " ";
	      } else {
	        tail.children.push({ type: "text", value: " " });
	      }
	      tail.children.push(...backReferences);
	    } else {
	      content3.push(...backReferences);
	    }
	    const listItem2 = {
	      type: "element",
	      tagName: "li",
	      properties: { id: clobberPrefix + "fn-" + safeId },
	      children: state.wrap(content3, true)
	    };
	    state.patch(definition2, listItem2);
	    listItems.push(listItem2);
	  }
	  if (listItems.length === 0) {
	    return;
	  }
	  return {
	    type: "element",
	    tagName: "section",
	    properties: { dataFootnotes: true, className: ["footnotes"] },
	    children: [
	      {
	        type: "element",
	        tagName: footnoteLabelTagName,
	        properties: {
	          ...esm_default(footnoteLabelProperties),
	          id: "footnote-label"
	        },
	        children: [{ type: "text", value: footnoteLabel }]
	      },
	      { type: "text", value: "\n" },
	      {
	        type: "element",
	        tagName: "ol",
	        properties: {},
	        children: state.wrap(listItems, true)
	      },
	      { type: "text", value: "\n" }
	    ]
	  };
	}

	// node_modules/.pnpm/unist-util-is@6.0.0/node_modules/unist-util-is/lib/index.js
	var convert = (
	  // Note: overloads in JSDoc can’t yet use different `@template`s.
	  /**
	   * @type {(
	   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
	   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
	   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
	   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
	   *   ((test?: Test) => Check)
	   * )}
	   */
	  /**
	   * @param {Test} [test]
	   * @returns {Check}
	   */
	  function(test) {
	    if (test === null || test === void 0) {
	      return ok2;
	    }
	    if (typeof test === "function") {
	      return castFactory(test);
	    }
	    if (typeof test === "object") {
	      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
	    }
	    if (typeof test === "string") {
	      return typeFactory(test);
	    }
	    throw new Error("Expected function, string, or object as test");
	  }
	);
	function anyFactory(tests) {
	  const checks = [];
	  let index2 = -1;
	  while (++index2 < tests.length) {
	    checks[index2] = convert(tests[index2]);
	  }
	  return castFactory(any);
	  function any(...parameters) {
	    let index3 = -1;
	    while (++index3 < checks.length) {
	      if (checks[index3].apply(this, parameters)) return true;
	    }
	    return false;
	  }
	}
	function propsFactory(check) {
	  const checkAsRecord = (
	    /** @type {Record<string, unknown>} */
	    check
	  );
	  return castFactory(all2);
	  function all2(node2) {
	    const nodeAsRecord = (
	      /** @type {Record<string, unknown>} */
	      /** @type {unknown} */
	      node2
	    );
	    let key;
	    for (key in check) {
	      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;
	    }
	    return true;
	  }
	}
	function typeFactory(check) {
	  return castFactory(type);
	  function type(node2) {
	    return node2 && node2.type === check;
	  }
	}
	function castFactory(testFunction) {
	  return check;
	  function check(value, index2, parent) {
	    return Boolean(
	      looksLikeANode(value) && testFunction.call(
	        this,
	        value,
	        typeof index2 === "number" ? index2 : void 0,
	        parent || void 0
	      )
	    );
	  }
	}
	function ok2() {
	  return true;
	}
	function looksLikeANode(value) {
	  return value !== null && typeof value === "object" && "type" in value;
	}

	// node_modules/.pnpm/unist-util-visit-parents@6.0.1/node_modules/unist-util-visit-parents/lib/color.js
	function color(d) {
	  return d;
	}

	// node_modules/.pnpm/unist-util-visit-parents@6.0.1/node_modules/unist-util-visit-parents/lib/index.js
	var empty = [];
	var CONTINUE = true;
	var EXIT = false;
	var SKIP = "skip";
	function visitParents(tree, test, visitor, reverse) {
	  let check;
	  if (typeof test === "function" && typeof visitor !== "function") {
	    reverse = visitor;
	    visitor = test;
	  } else {
	    check = test;
	  }
	  const is2 = convert(check);
	  const step = reverse ? -1 : 1;
	  factory(tree, void 0, [])();
	  function factory(node2, index2, parents) {
	    const value = (
	      /** @type {Record<string, unknown>} */
	      node2 && typeof node2 === "object" ? node2 : {}
	    );
	    if (typeof value.type === "string") {
	      const name = (
	        // `hast`
	        typeof value.tagName === "string" ? value.tagName : (
	          // `xast`
	          typeof value.name === "string" ? value.name : void 0
	        )
	      );
	      Object.defineProperty(visit3, "name", {
	        value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
	      });
	    }
	    return visit3;
	    function visit3() {
	      let result = empty;
	      let subresult;
	      let offset;
	      let grandparents;
	      if (!test || is2(node2, index2, parents[parents.length - 1] || void 0)) {
	        result = toResult(visitor(node2, parents));
	        if (result[0] === EXIT) {
	          return result;
	        }
	      }
	      if ("children" in node2 && node2.children) {
	        const nodeAsParent = (
	          /** @type {UnistParent} */
	          node2
	        );
	        if (nodeAsParent.children && result[0] !== SKIP) {
	          offset = (reverse ? nodeAsParent.children.length : -1) + step;
	          grandparents = parents.concat(nodeAsParent);
	          while (offset > -1 && offset < nodeAsParent.children.length) {
	            const child = nodeAsParent.children[offset];
	            subresult = factory(child, offset, grandparents)();
	            if (subresult[0] === EXIT) {
	              return subresult;
	            }
	            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
	          }
	        }
	      }
	      return result;
	    }
	  }
	}
	function toResult(value) {
	  if (Array.isArray(value)) {
	    return value;
	  }
	  if (typeof value === "number") {
	    return [CONTINUE, value];
	  }
	  return value === null || value === void 0 ? empty : [value];
	}

	// node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js
	function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
	  let reverse;
	  let test;
	  let visitor;
	  if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
	    test = void 0;
	    visitor = testOrVisitor;
	    reverse = visitorOrReverse;
	  } else {
	    test = testOrVisitor;
	    visitor = visitorOrReverse;
	    reverse = maybeReverse;
	  }
	  visitParents(tree, test, overload, reverse);
	  function overload(node2, parents) {
	    const parent = parents[parents.length - 1];
	    const index2 = parent ? parent.children.indexOf(node2) : void 0;
	    return visitor(node2, index2, parent);
	  }
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/state.js
	var own3 = {}.hasOwnProperty;
	var emptyOptions2 = {};
	function createState(tree, options) {
	  const settings = options || emptyOptions2;
	  const definitionById = /* @__PURE__ */ new Map();
	  const footnoteById = /* @__PURE__ */ new Map();
	  const footnoteCounts = /* @__PURE__ */ new Map();
	  const handlers2 = { ...handlers, ...settings.handlers };
	  const state = {
	    all: all2,
	    applyData,
	    definitionById,
	    footnoteById,
	    footnoteCounts,
	    footnoteOrder: [],
	    handlers: handlers2,
	    one: one2,
	    options: settings,
	    patch,
	    wrap
	  };
	  visit(tree, function(node2) {
	    if (node2.type === "definition" || node2.type === "footnoteDefinition") {
	      const map = node2.type === "definition" ? definitionById : footnoteById;
	      const id = String(node2.identifier).toUpperCase();
	      if (!map.has(id)) {
	        map.set(id, node2);
	      }
	    }
	  });
	  return state;
	  function one2(node2, parent) {
	    const type = node2.type;
	    const handle = state.handlers[type];
	    if (own3.call(state.handlers, type) && handle) {
	      return handle(state, node2, parent);
	    }
	    if (state.options.passThrough && state.options.passThrough.includes(type)) {
	      if ("children" in node2) {
	        const { children, ...shallow } = node2;
	        const result = esm_default(shallow);
	        result.children = state.all(node2);
	        return result;
	      }
	      return esm_default(node2);
	    }
	    const unknown = state.options.unknownHandler || defaultUnknownHandler;
	    return unknown(state, node2, parent);
	  }
	  function all2(parent) {
	    const values = [];
	    if ("children" in parent) {
	      const nodes = parent.children;
	      let index2 = -1;
	      while (++index2 < nodes.length) {
	        const result = state.one(nodes[index2], parent);
	        if (result) {
	          if (index2 && nodes[index2 - 1].type === "break") {
	            if (!Array.isArray(result) && result.type === "text") {
	              result.value = trimMarkdownSpaceStart(result.value);
	            }
	            if (!Array.isArray(result) && result.type === "element") {
	              const head = result.children[0];
	              if (head && head.type === "text") {
	                head.value = trimMarkdownSpaceStart(head.value);
	              }
	            }
	          }
	          if (Array.isArray(result)) {
	            values.push(...result);
	          } else {
	            values.push(result);
	          }
	        }
	      }
	    }
	    return values;
	  }
	}
	function patch(from, to) {
	  if (from.position) to.position = position2(from);
	}
	function applyData(from, to) {
	  let result = to;
	  if (from && from.data) {
	    const hName = from.data.hName;
	    const hChildren = from.data.hChildren;
	    const hProperties = from.data.hProperties;
	    if (typeof hName === "string") {
	      if (result.type === "element") {
	        result.tagName = hName;
	      } else {
	        const children = "children" in result ? result.children : [result];
	        result = { type: "element", tagName: hName, properties: {}, children };
	      }
	    }
	    if (result.type === "element" && hProperties) {
	      Object.assign(result.properties, esm_default(hProperties));
	    }
	    if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
	      result.children = hChildren;
	    }
	  }
	  return result;
	}
	function defaultUnknownHandler(state, node2) {
	  const data = node2.data || {};
	  const result = "value" in node2 && !(own3.call(data, "hProperties") || own3.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
	    type: "element",
	    tagName: "div",
	    properties: {},
	    children: state.all(node2)
	  };
	  state.patch(node2, result);
	  return state.applyData(node2, result);
	}
	function wrap(nodes, loose) {
	  const result = [];
	  let index2 = -1;
	  if (loose) {
	    result.push({ type: "text", value: "\n" });
	  }
	  while (++index2 < nodes.length) {
	    if (index2) result.push({ type: "text", value: "\n" });
	    result.push(nodes[index2]);
	  }
	  if (loose && nodes.length > 0) {
	    result.push({ type: "text", value: "\n" });
	  }
	  return result;
	}
	function trimMarkdownSpaceStart(value) {
	  let index2 = 0;
	  let code2 = value.charCodeAt(index2);
	  while (code2 === 9 || code2 === 32) {
	    index2++;
	    code2 = value.charCodeAt(index2);
	  }
	  return value.slice(index2);
	}

	// node_modules/.pnpm/mdast-util-to-hast@13.2.0/node_modules/mdast-util-to-hast/lib/index.js
	function toHast(tree, options) {
	  const state = createState(tree, options);
	  const node2 = state.one(tree, void 0);
	  const foot = footer(state);
	  const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
	  if (foot) {
	    result.children.push({ type: "text", value: "\n" }, foot);
	  }
	  return result;
	}

	// node_modules/.pnpm/remark-rehype@11.1.2/node_modules/remark-rehype/lib/index.js
	function remarkRehype(destination, options) {
	  if (destination && "run" in destination) {
	    return async function(tree, file) {
	      const hastTree = (
	        /** @type {HastRoot} */
	        toHast(tree, { file, ...options })
	      );
	      await destination.run(hastTree, file);
	    };
	  }
	  return function(tree, file) {
	    return (
	      /** @type {HastRoot} */
	      toHast(tree, { file, ...destination || options })
	    );
	  };
	}

	// node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js
	function bail(error) {
	  if (error) {
	    throw error;
	  }
	}

	// node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/index.js
	var import_extend = __toESM(require_extend(), 1);

	// node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js
	function isPlainObject(value) {
	  if (typeof value !== "object" || value === null) {
	    return false;
	  }
	  const prototype = Object.getPrototypeOf(value);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
	}

	// node_modules/.pnpm/trough@2.2.0/node_modules/trough/lib/index.js
	function trough() {
	  const fns = [];
	  const pipeline = { run, use };
	  return pipeline;
	  function run(...values) {
	    let middlewareIndex = -1;
	    const callback = values.pop();
	    if (typeof callback !== "function") {
	      throw new TypeError("Expected function as last argument, not " + callback);
	    }
	    next(null, ...values);
	    function next(error, ...output) {
	      const fn = fns[++middlewareIndex];
	      let index2 = -1;
	      if (error) {
	        callback(error);
	        return;
	      }
	      while (++index2 < values.length) {
	        if (output[index2] === null || output[index2] === void 0) {
	          output[index2] = values[index2];
	        }
	      }
	      values = output;
	      if (fn) {
	        wrap2(fn, next)(...output);
	      } else {
	        callback(null, ...output);
	      }
	    }
	  }
	  function use(middelware) {
	    if (typeof middelware !== "function") {
	      throw new TypeError(
	        "Expected `middelware` to be a function, not " + middelware
	      );
	    }
	    fns.push(middelware);
	    return pipeline;
	  }
	}
	function wrap2(middleware, callback) {
	  let called;
	  return wrapped;
	  function wrapped(...parameters) {
	    const fnExpectsCallback = middleware.length > parameters.length;
	    let result;
	    if (fnExpectsCallback) {
	      parameters.push(done);
	    }
	    try {
	      result = middleware.apply(this, parameters);
	    } catch (error) {
	      const exception = (
	        /** @type {Error} */
	        error
	      );
	      if (fnExpectsCallback && called) {
	        throw exception;
	      }
	      return done(exception);
	    }
	    if (!fnExpectsCallback) {
	      if (result && result.then && typeof result.then === "function") {
	        result.then(then, done);
	      } else if (result instanceof Error) {
	        done(result);
	      } else {
	        then(result);
	      }
	    }
	  }
	  function done(error, ...output) {
	    if (!called) {
	      called = true;
	      callback(error, ...output);
	    }
	  }
	  function then(value) {
	    done(null, value);
	  }
	}

	// node_modules/.pnpm/vfile-message@4.0.3/node_modules/vfile-message/lib/index.js
	var VFileMessage = class extends Error {
	  /**
	   * Create a message for `reason`.
	   *
	   * > 🪦 **Note**: also has obsolete signatures.
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Options | null | undefined} [options]
	   * @returns
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns
	   *
	   * @overload
	   * @param {string} reason
	   * @param {string | null | undefined} [origin]
	   * @returns
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {string | null | undefined} [origin]
	   * @returns
	   *
	   * @param {Error | VFileMessage | string} causeOrReason
	   *   Reason for message, should use markdown.
	   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
	   *   Configuration (optional).
	   * @param {string | null | undefined} [origin]
	   *   Place in code where the message originates (example:
	   *   `'my-package:my-rule'` or `'my-rule'`).
	   * @returns
	   *   Instance of `VFileMessage`.
	   */
	  // eslint-disable-next-line complexity
	  constructor(causeOrReason, optionsOrParentOrPlace, origin) {
	    super();
	    if (typeof optionsOrParentOrPlace === "string") {
	      origin = optionsOrParentOrPlace;
	      optionsOrParentOrPlace = void 0;
	    }
	    let reason = "";
	    let options = {};
	    let legacyCause = false;
	    if (optionsOrParentOrPlace) {
	      if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
	        options = { place: optionsOrParentOrPlace };
	      } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
	        options = { place: optionsOrParentOrPlace };
	      } else if ("type" in optionsOrParentOrPlace) {
	        options = {
	          ancestors: [optionsOrParentOrPlace],
	          place: optionsOrParentOrPlace.position
	        };
	      } else {
	        options = { ...optionsOrParentOrPlace };
	      }
	    }
	    if (typeof causeOrReason === "string") {
	      reason = causeOrReason;
	    } else if (!options.cause && causeOrReason) {
	      legacyCause = true;
	      reason = causeOrReason.message;
	      options.cause = causeOrReason;
	    }
	    if (!options.ruleId && !options.source && typeof origin === "string") {
	      const index2 = origin.indexOf(":");
	      if (index2 === -1) {
	        options.ruleId = origin;
	      } else {
	        options.source = origin.slice(0, index2);
	        options.ruleId = origin.slice(index2 + 1);
	      }
	    }
	    if (!options.place && options.ancestors && options.ancestors) {
	      const parent = options.ancestors[options.ancestors.length - 1];
	      if (parent) {
	        options.place = parent.position;
	      }
	    }
	    const start = options.place && "start" in options.place ? options.place.start : options.place;
	    this.ancestors = options.ancestors || void 0;
	    this.cause = options.cause || void 0;
	    this.column = start ? start.column : void 0;
	    this.fatal = void 0;
	    this.file = "";
	    this.message = reason;
	    this.line = start ? start.line : void 0;
	    this.name = stringifyPosition(options.place) || "1:1";
	    this.place = options.place || void 0;
	    this.reason = this.message;
	    this.ruleId = options.ruleId || void 0;
	    this.source = options.source || void 0;
	    this.stack = legacyCause && options.cause && typeof options.cause.stack === "string" ? options.cause.stack : "";
	    this.actual = void 0;
	    this.expected = void 0;
	    this.note = void 0;
	    this.url = void 0;
	  }
	};
	VFileMessage.prototype.file = "";
	VFileMessage.prototype.name = "";
	VFileMessage.prototype.reason = "";
	VFileMessage.prototype.message = "";
	VFileMessage.prototype.stack = "";
	VFileMessage.prototype.column = void 0;
	VFileMessage.prototype.line = void 0;
	VFileMessage.prototype.ancestors = void 0;
	VFileMessage.prototype.cause = void 0;
	VFileMessage.prototype.fatal = void 0;
	VFileMessage.prototype.place = void 0;
	VFileMessage.prototype.ruleId = void 0;
	VFileMessage.prototype.source = void 0;

	// node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minpath.browser.js
	var minpath = { basename, dirname, extname, join, sep: "/" };
	function basename(path, extname2) {
	  if (extname2 !== void 0 && typeof extname2 !== "string") {
	    throw new TypeError('"ext" argument must be a string');
	  }
	  assertPath(path);
	  let start = 0;
	  let end = -1;
	  let index2 = path.length;
	  let seenNonSlash;
	  if (extname2 === void 0 || extname2.length === 0 || extname2.length > path.length) {
	    while (index2--) {
	      if (path.codePointAt(index2) === 47) {
	        if (seenNonSlash) {
	          start = index2 + 1;
	          break;
	        }
	      } else if (end < 0) {
	        seenNonSlash = true;
	        end = index2 + 1;
	      }
	    }
	    return end < 0 ? "" : path.slice(start, end);
	  }
	  if (extname2 === path) {
	    return "";
	  }
	  let firstNonSlashEnd = -1;
	  let extnameIndex = extname2.length - 1;
	  while (index2--) {
	    if (path.codePointAt(index2) === 47) {
	      if (seenNonSlash) {
	        start = index2 + 1;
	        break;
	      }
	    } else {
	      if (firstNonSlashEnd < 0) {
	        seenNonSlash = true;
	        firstNonSlashEnd = index2 + 1;
	      }
	      if (extnameIndex > -1) {
	        if (path.codePointAt(index2) === extname2.codePointAt(extnameIndex--)) {
	          if (extnameIndex < 0) {
	            end = index2;
	          }
	        } else {
	          extnameIndex = -1;
	          end = firstNonSlashEnd;
	        }
	      }
	    }
	  }
	  if (start === end) {
	    end = firstNonSlashEnd;
	  } else if (end < 0) {
	    end = path.length;
	  }
	  return path.slice(start, end);
	}
	function dirname(path) {
	  assertPath(path);
	  if (path.length === 0) {
	    return ".";
	  }
	  let end = -1;
	  let index2 = path.length;
	  let unmatchedSlash;
	  while (--index2) {
	    if (path.codePointAt(index2) === 47) {
	      if (unmatchedSlash) {
	        end = index2;
	        break;
	      }
	    } else if (!unmatchedSlash) {
	      unmatchedSlash = true;
	    }
	  }
	  return end < 0 ? path.codePointAt(0) === 47 ? "/" : "." : end === 1 && path.codePointAt(0) === 47 ? "//" : path.slice(0, end);
	}
	function extname(path) {
	  assertPath(path);
	  let index2 = path.length;
	  let end = -1;
	  let startPart = 0;
	  let startDot = -1;
	  let preDotState = 0;
	  let unmatchedSlash;
	  while (index2--) {
	    const code2 = path.codePointAt(index2);
	    if (code2 === 47) {
	      if (unmatchedSlash) {
	        startPart = index2 + 1;
	        break;
	      }
	      continue;
	    }
	    if (end < 0) {
	      unmatchedSlash = true;
	      end = index2 + 1;
	    }
	    if (code2 === 46) {
	      if (startDot < 0) {
	        startDot = index2;
	      } else if (preDotState !== 1) {
	        preDotState = 1;
	      }
	    } else if (startDot > -1) {
	      preDotState = -1;
	    }
	  }
	  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
	  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
	  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
	    return "";
	  }
	  return path.slice(startDot, end);
	}
	function join(...segments) {
	  let index2 = -1;
	  let joined;
	  while (++index2 < segments.length) {
	    assertPath(segments[index2]);
	    if (segments[index2]) {
	      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
	    }
	  }
	  return joined === void 0 ? "." : normalize(joined);
	}
	function normalize(path) {
	  assertPath(path);
	  const absolute = path.codePointAt(0) === 47;
	  let value = normalizeString(path, !absolute);
	  if (value.length === 0 && !absolute) {
	    value = ".";
	  }
	  if (value.length > 0 && path.codePointAt(path.length - 1) === 47) {
	    value += "/";
	  }
	  return absolute ? "/" + value : value;
	}
	function normalizeString(path, allowAboveRoot) {
	  let result = "";
	  let lastSegmentLength = 0;
	  let lastSlash = -1;
	  let dots = 0;
	  let index2 = -1;
	  let code2;
	  let lastSlashIndex;
	  while (++index2 <= path.length) {
	    if (index2 < path.length) {
	      code2 = path.codePointAt(index2);
	    } else if (code2 === 47) {
	      break;
	    } else {
	      code2 = 47;
	    }
	    if (code2 === 47) {
	      if (lastSlash === index2 - 1 || dots === 1) ; else if (lastSlash !== index2 - 1 && dots === 2) {
	        if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
	          if (result.length > 2) {
	            lastSlashIndex = result.lastIndexOf("/");
	            if (lastSlashIndex !== result.length - 1) {
	              if (lastSlashIndex < 0) {
	                result = "";
	                lastSegmentLength = 0;
	              } else {
	                result = result.slice(0, lastSlashIndex);
	                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
	              }
	              lastSlash = index2;
	              dots = 0;
	              continue;
	            }
	          } else if (result.length > 0) {
	            result = "";
	            lastSegmentLength = 0;
	            lastSlash = index2;
	            dots = 0;
	            continue;
	          }
	        }
	        if (allowAboveRoot) {
	          result = result.length > 0 ? result + "/.." : "..";
	          lastSegmentLength = 2;
	        }
	      } else {
	        if (result.length > 0) {
	          result += "/" + path.slice(lastSlash + 1, index2);
	        } else {
	          result = path.slice(lastSlash + 1, index2);
	        }
	        lastSegmentLength = index2 - lastSlash - 1;
	      }
	      lastSlash = index2;
	      dots = 0;
	    } else if (code2 === 46 && dots > -1) {
	      dots++;
	    } else {
	      dots = -1;
	    }
	  }
	  return result;
	}
	function assertPath(path) {
	  if (typeof path !== "string") {
	    throw new TypeError(
	      "Path must be a string. Received " + JSON.stringify(path)
	    );
	  }
	}

	// node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minproc.browser.js
	var minproc = { cwd };
	function cwd() {
	  return "/";
	}

	// node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minurl.shared.js
	function isUrl(fileUrlOrPath) {
	  return Boolean(
	    fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
	    fileUrlOrPath.auth === void 0
	  );
	}

	// node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/minurl.browser.js
	function urlToPath(path) {
	  if (typeof path === "string") {
	    path = new URL(path);
	  } else if (!isUrl(path)) {
	    const error = new TypeError(
	      'The "path" argument must be of type string or an instance of URL. Received `' + path + "`"
	    );
	    error.code = "ERR_INVALID_ARG_TYPE";
	    throw error;
	  }
	  if (path.protocol !== "file:") {
	    const error = new TypeError("The URL must be of scheme file");
	    error.code = "ERR_INVALID_URL_SCHEME";
	    throw error;
	  }
	  return getPathFromURLPosix(path);
	}
	function getPathFromURLPosix(url) {
	  if (url.hostname !== "") {
	    const error = new TypeError(
	      'File URL host must be "localhost" or empty on darwin'
	    );
	    error.code = "ERR_INVALID_FILE_URL_HOST";
	    throw error;
	  }
	  const pathname = url.pathname;
	  let index2 = -1;
	  while (++index2 < pathname.length) {
	    if (pathname.codePointAt(index2) === 37 && pathname.codePointAt(index2 + 1) === 50) {
	      const third = pathname.codePointAt(index2 + 2);
	      if (third === 70 || third === 102) {
	        const error = new TypeError(
	          "File URL path must not include encoded / characters"
	        );
	        error.code = "ERR_INVALID_FILE_URL_PATH";
	        throw error;
	      }
	    }
	  }
	  return decodeURIComponent(pathname);
	}

	// node_modules/.pnpm/vfile@6.0.3/node_modules/vfile/lib/index.js
	var order = (
	  /** @type {const} */
	  [
	    "history",
	    "path",
	    "basename",
	    "stem",
	    "extname",
	    "dirname"
	  ]
	);
	var VFile = class {
	  /**
	   * Create a new virtual file.
	   *
	   * `options` is treated as:
	   *
	   * *   `string` or `Uint8Array` — `{value: options}`
	   * *   `URL` — `{path: options}`
	   * *   `VFile` — shallow copies its data over to the new file
	   * *   `object` — all fields are shallow copied over to the new file
	   *
	   * Path related fields are set in the following order (least specific to
	   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
	   * `dirname`.
	   *
	   * You cannot set `dirname` or `extname` without setting either `history`,
	   * `path`, `basename`, or `stem` too.
	   *
	   * @param {Compatible | null | undefined} [value]
	   *   File value.
	   * @returns
	   *   New instance.
	   */
	  constructor(value) {
	    let options;
	    if (!value) {
	      options = {};
	    } else if (isUrl(value)) {
	      options = { path: value };
	    } else if (typeof value === "string" || isUint8Array(value)) {
	      options = { value };
	    } else {
	      options = value;
	    }
	    this.cwd = "cwd" in options ? "" : minproc.cwd();
	    this.data = {};
	    this.history = [];
	    this.messages = [];
	    this.value;
	    this.map;
	    this.result;
	    this.stored;
	    let index2 = -1;
	    while (++index2 < order.length) {
	      const field2 = order[index2];
	      if (field2 in options && options[field2] !== void 0 && options[field2] !== null) {
	        this[field2] = field2 === "history" ? [...options[field2]] : options[field2];
	      }
	    }
	    let field;
	    for (field in options) {
	      if (!order.includes(field)) {
	        this[field] = options[field];
	      }
	    }
	  }
	  /**
	   * Get the basename (including extname) (example: `'index.min.js'`).
	   *
	   * @returns {string | undefined}
	   *   Basename.
	   */
	  get basename() {
	    return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
	  }
	  /**
	   * Set basename (including extname) (`'index.min.js'`).
	   *
	   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
	   * on windows).
	   * Cannot be nullified (use `file.path = file.dirname` instead).
	   *
	   * @param {string} basename
	   *   Basename.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  set basename(basename2) {
	    assertNonEmpty(basename2, "basename");
	    assertPart(basename2, "basename");
	    this.path = minpath.join(this.dirname || "", basename2);
	  }
	  /**
	   * Get the parent path (example: `'~'`).
	   *
	   * @returns {string | undefined}
	   *   Dirname.
	   */
	  get dirname() {
	    return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
	  }
	  /**
	   * Set the parent path (example: `'~'`).
	   *
	   * Cannot be set if there’s no `path` yet.
	   *
	   * @param {string | undefined} dirname
	   *   Dirname.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  set dirname(dirname2) {
	    assertPath2(this.basename, "dirname");
	    this.path = minpath.join(dirname2 || "", this.basename);
	  }
	  /**
	   * Get the extname (including dot) (example: `'.js'`).
	   *
	   * @returns {string | undefined}
	   *   Extname.
	   */
	  get extname() {
	    return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
	  }
	  /**
	   * Set the extname (including dot) (example: `'.js'`).
	   *
	   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
	   * on windows).
	   * Cannot be set if there’s no `path` yet.
	   *
	   * @param {string | undefined} extname
	   *   Extname.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  set extname(extname2) {
	    assertPart(extname2, "extname");
	    assertPath2(this.dirname, "extname");
	    if (extname2) {
	      if (extname2.codePointAt(0) !== 46) {
	        throw new Error("`extname` must start with `.`");
	      }
	      if (extname2.includes(".", 1)) {
	        throw new Error("`extname` cannot contain multiple dots");
	      }
	    }
	    this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
	  }
	  /**
	   * Get the full path (example: `'~/index.min.js'`).
	   *
	   * @returns {string}
	   *   Path.
	   */
	  get path() {
	    return this.history[this.history.length - 1];
	  }
	  /**
	   * Set the full path (example: `'~/index.min.js'`).
	   *
	   * Cannot be nullified.
	   * You can set a file URL (a `URL` object with a `file:` protocol) which will
	   * be turned into a path with `url.fileURLToPath`.
	   *
	   * @param {URL | string} path
	   *   Path.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  set path(path) {
	    if (isUrl(path)) {
	      path = urlToPath(path);
	    }
	    assertNonEmpty(path, "path");
	    if (this.path !== path) {
	      this.history.push(path);
	    }
	  }
	  /**
	   * Get the stem (basename w/o extname) (example: `'index.min'`).
	   *
	   * @returns {string | undefined}
	   *   Stem.
	   */
	  get stem() {
	    return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
	  }
	  /**
	   * Set the stem (basename w/o extname) (example: `'index.min'`).
	   *
	   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
	   * on windows).
	   * Cannot be nullified (use `file.path = file.dirname` instead).
	   *
	   * @param {string} stem
	   *   Stem.
	   * @returns {undefined}
	   *   Nothing.
	   */
	  set stem(stem) {
	    assertNonEmpty(stem, "stem");
	    assertPart(stem, "stem");
	    this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
	  }
	  // Normal prototypal methods.
	  /**
	   * Create a fatal message for `reason` associated with the file.
	   *
	   * The `fatal` field of the message is set to `true` (error; file not usable)
	   * and the `file` field is set to the current file path.
	   * The message is added to the `messages` field on `file`.
	   *
	   * > 🪦 **Note**: also has obsolete signatures.
	   *
	   * @overload
	   * @param {string} reason
	   * @param {MessageOptions | null | undefined} [options]
	   * @returns {never}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns {never}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns {never}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {string | null | undefined} [origin]
	   * @returns {never}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns {never}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns {never}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {string | null | undefined} [origin]
	   * @returns {never}
	   *
	   * @param {Error | VFileMessage | string} causeOrReason
	   *   Reason for message, should use markdown.
	   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
	   *   Configuration (optional).
	   * @param {string | null | undefined} [origin]
	   *   Place in code where the message originates (example:
	   *   `'my-package:my-rule'` or `'my-rule'`).
	   * @returns {never}
	   *   Never.
	   * @throws {VFileMessage}
	   *   Message.
	   */
	  fail(causeOrReason, optionsOrParentOrPlace, origin) {
	    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
	    message.fatal = true;
	    throw message;
	  }
	  /**
	   * Create an info message for `reason` associated with the file.
	   *
	   * The `fatal` field of the message is set to `undefined` (info; change
	   * likely not needed) and the `file` field is set to the current file path.
	   * The message is added to the `messages` field on `file`.
	   *
	   * > 🪦 **Note**: also has obsolete signatures.
	   *
	   * @overload
	   * @param {string} reason
	   * @param {MessageOptions | null | undefined} [options]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @param {Error | VFileMessage | string} causeOrReason
	   *   Reason for message, should use markdown.
	   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
	   *   Configuration (optional).
	   * @param {string | null | undefined} [origin]
	   *   Place in code where the message originates (example:
	   *   `'my-package:my-rule'` or `'my-rule'`).
	   * @returns {VFileMessage}
	   *   Message.
	   */
	  info(causeOrReason, optionsOrParentOrPlace, origin) {
	    const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
	    message.fatal = void 0;
	    return message;
	  }
	  /**
	   * Create a message for `reason` associated with the file.
	   *
	   * The `fatal` field of the message is set to `false` (warning; change may be
	   * needed) and the `file` field is set to the current file path.
	   * The message is added to the `messages` field on `file`.
	   *
	   * > 🪦 **Note**: also has obsolete signatures.
	   *
	   * @overload
	   * @param {string} reason
	   * @param {MessageOptions | null | undefined} [options]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {string} reason
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Node | NodeLike | null | undefined} parent
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {Point | Position | null | undefined} place
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @overload
	   * @param {Error | VFileMessage} cause
	   * @param {string | null | undefined} [origin]
	   * @returns {VFileMessage}
	   *
	   * @param {Error | VFileMessage | string} causeOrReason
	   *   Reason for message, should use markdown.
	   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
	   *   Configuration (optional).
	   * @param {string | null | undefined} [origin]
	   *   Place in code where the message originates (example:
	   *   `'my-package:my-rule'` or `'my-rule'`).
	   * @returns {VFileMessage}
	   *   Message.
	   */
	  message(causeOrReason, optionsOrParentOrPlace, origin) {
	    const message = new VFileMessage(
	      // @ts-expect-error: the overloads are fine.
	      causeOrReason,
	      optionsOrParentOrPlace,
	      origin
	    );
	    if (this.path) {
	      message.name = this.path + ":" + message.name;
	      message.file = this.path;
	    }
	    message.fatal = false;
	    this.messages.push(message);
	    return message;
	  }
	  /**
	   * Serialize the file.
	   *
	   * > **Note**: which encodings are supported depends on the engine.
	   * > For info on Node.js, see:
	   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
	   *
	   * @param {string | null | undefined} [encoding='utf8']
	   *   Character encoding to understand `value` as when it’s a `Uint8Array`
	   *   (default: `'utf-8'`).
	   * @returns {string}
	   *   Serialized file.
	   */
	  toString(encoding) {
	    if (this.value === void 0) {
	      return "";
	    }
	    if (typeof this.value === "string") {
	      return this.value;
	    }
	    const decoder = new TextDecoder(encoding || void 0);
	    return decoder.decode(this.value);
	  }
	};
	function assertPart(part, name) {
	  if (part && part.includes(minpath.sep)) {
	    throw new Error(
	      "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
	    );
	  }
	}
	function assertNonEmpty(part, name) {
	  if (!part) {
	    throw new Error("`" + name + "` cannot be empty");
	  }
	}
	function assertPath2(path, name) {
	  if (!path) {
	    throw new Error("Setting `" + name + "` requires `path` to be set too");
	  }
	}
	function isUint8Array(value) {
	  return Boolean(
	    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
	  );
	}

	// node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/callable-instance.js
	var CallableInstance = (
	  /**
	   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
	   */
	  /** @type {unknown} */
	  /**
	   * @this {Function}
	   * @param {string | symbol} property
	   * @returns {(...parameters: Array<unknown>) => unknown}
	   */
	  function(property) {
	    const self2 = this;
	    const constr = self2.constructor;
	    const proto = (
	      /** @type {Record<string | symbol, Function>} */
	      // Prototypes do exist.
	      // type-coverage:ignore-next-line
	      constr.prototype
	    );
	    const value = proto[property];
	    const apply = function() {
	      return value.apply(apply, arguments);
	    };
	    Object.setPrototypeOf(apply, proto);
	    return apply;
	  }
	);

	// node_modules/.pnpm/unified@11.0.5/node_modules/unified/lib/index.js
	var own4 = {}.hasOwnProperty;
	var Processor = class _Processor extends CallableInstance {
	  /**
	   * Create a processor.
	   */
	  constructor() {
	    super("copy");
	    this.Compiler = void 0;
	    this.Parser = void 0;
	    this.attachers = [];
	    this.compiler = void 0;
	    this.freezeIndex = -1;
	    this.frozen = void 0;
	    this.namespace = {};
	    this.parser = void 0;
	    this.transformers = trough();
	  }
	  /**
	   * Copy a processor.
	   *
	   * @deprecated
	   *   This is a private internal method and should not be used.
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *   New *unfrozen* processor ({@linkcode Processor}) that is
	   *   configured to work the same as its ancestor.
	   *   When the descendant processor is configured in the future it does not
	   *   affect the ancestral processor.
	   */
	  copy() {
	    const destination = (
	      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
	      new _Processor()
	    );
	    let index2 = -1;
	    while (++index2 < this.attachers.length) {
	      const attacher = this.attachers[index2];
	      destination.use(...attacher);
	    }
	    destination.data((0, import_extend.default)(true, {}, this.namespace));
	    return destination;
	  }
	  /**
	   * Configure the processor with info available to all plugins.
	   * Information is stored in an object.
	   *
	   * Typically, options can be given to a specific plugin, but sometimes it
	   * makes sense to have information shared with several plugins.
	   * For example, a list of HTML elements that are self-closing, which is
	   * needed during all phases.
	   *
	   * > **Note**: setting information cannot occur on *frozen* processors.
	   * > Call the processor first to create a new unfrozen processor.
	   *
	   * > **Note**: to register custom data in TypeScript, augment the
	   * > {@linkcode Data} interface.
	   *
	   * @example
	   *   This example show how to get and set info:
	   *
	   *   ```js
	   *   import {unified} from 'unified'
	   *
	   *   const processor = unified().data('alpha', 'bravo')
	   *
	   *   processor.data('alpha') // => 'bravo'
	   *
	   *   processor.data() // => {alpha: 'bravo'}
	   *
	   *   processor.data({charlie: 'delta'})
	   *
	   *   processor.data() // => {charlie: 'delta'}
	   *   ```
	   *
	   * @template {keyof Data} Key
	   *
	   * @overload
	   * @returns {Data}
	   *
	   * @overload
	   * @param {Data} dataset
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *
	   * @overload
	   * @param {Key} key
	   * @returns {Data[Key]}
	   *
	   * @overload
	   * @param {Key} key
	   * @param {Data[Key]} value
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *
	   * @param {Data | Key} [key]
	   *   Key to get or set, or entire dataset to set, or nothing to get the
	   *   entire dataset (optional).
	   * @param {Data[Key]} [value]
	   *   Value to set (optional).
	   * @returns {unknown}
	   *   The current processor when setting, the value at `key` when getting, or
	   *   the entire dataset when getting without key.
	   */
	  data(key, value) {
	    if (typeof key === "string") {
	      if (arguments.length === 2) {
	        assertUnfrozen("data", this.frozen);
	        this.namespace[key] = value;
	        return this;
	      }
	      return own4.call(this.namespace, key) && this.namespace[key] || void 0;
	    }
	    if (key) {
	      assertUnfrozen("data", this.frozen);
	      this.namespace = key;
	      return this;
	    }
	    return this.namespace;
	  }
	  /**
	   * Freeze a processor.
	   *
	   * Frozen processors are meant to be extended and not to be configured
	   * directly.
	   *
	   * When a processor is frozen it cannot be unfrozen.
	   * New processors working the same way can be created by calling the
	   * processor.
	   *
	   * It’s possible to freeze processors explicitly by calling `.freeze()`.
	   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
	   * `.stringify()`, `.process()`, or `.processSync()` are called.
	   *
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *   The current processor.
	   */
	  freeze() {
	    if (this.frozen) {
	      return this;
	    }
	    const self2 = (
	      /** @type {Processor} */
	      /** @type {unknown} */
	      this
	    );
	    while (++this.freezeIndex < this.attachers.length) {
	      const [attacher, ...options] = this.attachers[this.freezeIndex];
	      if (options[0] === false) {
	        continue;
	      }
	      if (options[0] === true) {
	        options[0] = void 0;
	      }
	      const transformer = attacher.call(self2, ...options);
	      if (typeof transformer === "function") {
	        this.transformers.use(transformer);
	      }
	    }
	    this.frozen = true;
	    this.freezeIndex = Number.POSITIVE_INFINITY;
	    return this;
	  }
	  /**
	   * Parse text to a syntax tree.
	   *
	   * > **Note**: `parse` freezes the processor if not already *frozen*.
	   *
	   * > **Note**: `parse` performs the parse phase, not the run phase or other
	   * > phases.
	   *
	   * @param {Compatible | undefined} [file]
	   *   file to parse (optional); typically `string` or `VFile`; any value
	   *   accepted as `x` in `new VFile(x)`.
	   * @returns {ParseTree extends undefined ? Node : ParseTree}
	   *   Syntax tree representing `file`.
	   */
	  parse(file) {
	    this.freeze();
	    const realFile = vfile(file);
	    const parser = this.parser || this.Parser;
	    assertParser("parse", parser);
	    return parser(String(realFile), realFile);
	  }
	  /**
	   * Process the given file as configured on the processor.
	   *
	   * > **Note**: `process` freezes the processor if not already *frozen*.
	   *
	   * > **Note**: `process` performs the parse, run, and stringify phases.
	   *
	   * @overload
	   * @param {Compatible | undefined} file
	   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
	   * @returns {undefined}
	   *
	   * @overload
	   * @param {Compatible | undefined} [file]
	   * @returns {Promise<VFileWithOutput<CompileResult>>}
	   *
	   * @param {Compatible | undefined} [file]
	   *   File (optional); typically `string` or `VFile`]; any value accepted as
	   *   `x` in `new VFile(x)`.
	   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
	   *   Callback (optional).
	   * @returns {Promise<VFile> | undefined}
	   *   Nothing if `done` is given.
	   *   Otherwise a promise, rejected with a fatal error or resolved with the
	   *   processed file.
	   *
	   *   The parsed, transformed, and compiled value is available at
	   *   `file.value` (see note).
	   *
	   *   > **Note**: unified typically compiles by serializing: most
	   *   > compilers return `string` (or `Uint8Array`).
	   *   > Some compilers, such as the one configured with
	   *   > [`rehype-react`][rehype-react], return other values (in this case, a
	   *   > React tree).
	   *   > If you’re using a compiler that doesn’t serialize, expect different
	   *   > result values.
	   *   >
	   *   > To register custom results in TypeScript, add them to
	   *   > {@linkcode CompileResultMap}.
	   *
	   *   [rehype-react]: https://github.com/rehypejs/rehype-react
	   */
	  process(file, done) {
	    const self2 = this;
	    this.freeze();
	    assertParser("process", this.parser || this.Parser);
	    assertCompiler("process", this.compiler || this.Compiler);
	    return done ? executor(void 0, done) : new Promise(executor);
	    function executor(resolve, reject) {
	      const realFile = vfile(file);
	      const parseTree = (
	        /** @type {HeadTree extends undefined ? Node : HeadTree} */
	        /** @type {unknown} */
	        self2.parse(realFile)
	      );
	      self2.run(parseTree, realFile, function(error, tree, file2) {
	        if (error || !tree || !file2) {
	          return realDone(error);
	        }
	        const compileTree = (
	          /** @type {CompileTree extends undefined ? Node : CompileTree} */
	          /** @type {unknown} */
	          tree
	        );
	        const compileResult = self2.stringify(compileTree, file2);
	        if (looksLikeAValue(compileResult)) {
	          file2.value = compileResult;
	        } else {
	          file2.result = compileResult;
	        }
	        realDone(
	          error,
	          /** @type {VFileWithOutput<CompileResult>} */
	          file2
	        );
	      });
	      function realDone(error, file2) {
	        if (error || !file2) {
	          reject(error);
	        } else if (resolve) {
	          resolve(file2);
	        } else {
	          done(void 0, file2);
	        }
	      }
	    }
	  }
	  /**
	   * Process the given file as configured on the processor.
	   *
	   * An error is thrown if asynchronous transforms are configured.
	   *
	   * > **Note**: `processSync` freezes the processor if not already *frozen*.
	   *
	   * > **Note**: `processSync` performs the parse, run, and stringify phases.
	   *
	   * @param {Compatible | undefined} [file]
	   *   File (optional); typically `string` or `VFile`; any value accepted as
	   *   `x` in `new VFile(x)`.
	   * @returns {VFileWithOutput<CompileResult>}
	   *   The processed file.
	   *
	   *   The parsed, transformed, and compiled value is available at
	   *   `file.value` (see note).
	   *
	   *   > **Note**: unified typically compiles by serializing: most
	   *   > compilers return `string` (or `Uint8Array`).
	   *   > Some compilers, such as the one configured with
	   *   > [`rehype-react`][rehype-react], return other values (in this case, a
	   *   > React tree).
	   *   > If you’re using a compiler that doesn’t serialize, expect different
	   *   > result values.
	   *   >
	   *   > To register custom results in TypeScript, add them to
	   *   > {@linkcode CompileResultMap}.
	   *
	   *   [rehype-react]: https://github.com/rehypejs/rehype-react
	   */
	  processSync(file) {
	    let complete = false;
	    let result;
	    this.freeze();
	    assertParser("processSync", this.parser || this.Parser);
	    assertCompiler("processSync", this.compiler || this.Compiler);
	    this.process(file, realDone);
	    assertDone("processSync", "process", complete);
	    return result;
	    function realDone(error, file2) {
	      complete = true;
	      bail(error);
	      result = file2;
	    }
	  }
	  /**
	   * Run *transformers* on a syntax tree.
	   *
	   * > **Note**: `run` freezes the processor if not already *frozen*.
	   *
	   * > **Note**: `run` performs the run phase, not other phases.
	   *
	   * @overload
	   * @param {HeadTree extends undefined ? Node : HeadTree} tree
	   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
	   * @returns {undefined}
	   *
	   * @overload
	   * @param {HeadTree extends undefined ? Node : HeadTree} tree
	   * @param {Compatible | undefined} file
	   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
	   * @returns {undefined}
	   *
	   * @overload
	   * @param {HeadTree extends undefined ? Node : HeadTree} tree
	   * @param {Compatible | undefined} [file]
	   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
	   *
	   * @param {HeadTree extends undefined ? Node : HeadTree} tree
	   *   Tree to transform and inspect.
	   * @param {(
	   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
	   *   Compatible
	   * )} [file]
	   *   File associated with `node` (optional); any value accepted as `x` in
	   *   `new VFile(x)`.
	   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
	   *   Callback (optional).
	   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
	   *   Nothing if `done` is given.
	   *   Otherwise, a promise rejected with a fatal error or resolved with the
	   *   transformed tree.
	   */
	  run(tree, file, done) {
	    assertNode(tree);
	    this.freeze();
	    const transformers = this.transformers;
	    if (!done && typeof file === "function") {
	      done = file;
	      file = void 0;
	    }
	    return done ? executor(void 0, done) : new Promise(executor);
	    function executor(resolve, reject) {
	      const realFile = vfile(file);
	      transformers.run(tree, realFile, realDone);
	      function realDone(error, outputTree, file2) {
	        const resultingTree = (
	          /** @type {TailTree extends undefined ? Node : TailTree} */
	          outputTree || tree
	        );
	        if (error) {
	          reject(error);
	        } else if (resolve) {
	          resolve(resultingTree);
	        } else {
	          done(void 0, resultingTree, file2);
	        }
	      }
	    }
	  }
	  /**
	   * Run *transformers* on a syntax tree.
	   *
	   * An error is thrown if asynchronous transforms are configured.
	   *
	   * > **Note**: `runSync` freezes the processor if not already *frozen*.
	   *
	   * > **Note**: `runSync` performs the run phase, not other phases.
	   *
	   * @param {HeadTree extends undefined ? Node : HeadTree} tree
	   *   Tree to transform and inspect.
	   * @param {Compatible | undefined} [file]
	   *   File associated with `node` (optional); any value accepted as `x` in
	   *   `new VFile(x)`.
	   * @returns {TailTree extends undefined ? Node : TailTree}
	   *   Transformed tree.
	   */
	  runSync(tree, file) {
	    let complete = false;
	    let result;
	    this.run(tree, file, realDone);
	    assertDone("runSync", "run", complete);
	    return result;
	    function realDone(error, tree2) {
	      bail(error);
	      result = tree2;
	      complete = true;
	    }
	  }
	  /**
	   * Compile a syntax tree.
	   *
	   * > **Note**: `stringify` freezes the processor if not already *frozen*.
	   *
	   * > **Note**: `stringify` performs the stringify phase, not the run phase
	   * > or other phases.
	   *
	   * @param {CompileTree extends undefined ? Node : CompileTree} tree
	   *   Tree to compile.
	   * @param {Compatible | undefined} [file]
	   *   File associated with `node` (optional); any value accepted as `x` in
	   *   `new VFile(x)`.
	   * @returns {CompileResult extends undefined ? Value : CompileResult}
	   *   Textual representation of the tree (see note).
	   *
	   *   > **Note**: unified typically compiles by serializing: most compilers
	   *   > return `string` (or `Uint8Array`).
	   *   > Some compilers, such as the one configured with
	   *   > [`rehype-react`][rehype-react], return other values (in this case, a
	   *   > React tree).
	   *   > If you’re using a compiler that doesn’t serialize, expect different
	   *   > result values.
	   *   >
	   *   > To register custom results in TypeScript, add them to
	   *   > {@linkcode CompileResultMap}.
	   *
	   *   [rehype-react]: https://github.com/rehypejs/rehype-react
	   */
	  stringify(tree, file) {
	    this.freeze();
	    const realFile = vfile(file);
	    const compiler2 = this.compiler || this.Compiler;
	    assertCompiler("stringify", compiler2);
	    assertNode(tree);
	    return compiler2(tree, realFile);
	  }
	  /**
	   * Configure the processor to use a plugin, a list of usable values, or a
	   * preset.
	   *
	   * If the processor is already using a plugin, the previous plugin
	   * configuration is changed based on the options that are passed in.
	   * In other words, the plugin is not added a second time.
	   *
	   * > **Note**: `use` cannot be called on *frozen* processors.
	   * > Call the processor first to create a new unfrozen processor.
	   *
	   * @example
	   *   There are many ways to pass plugins to `.use()`.
	   *   This example gives an overview:
	   *
	   *   ```js
	   *   import {unified} from 'unified'
	   *
	   *   unified()
	   *     // Plugin with options:
	   *     .use(pluginA, {x: true, y: true})
	   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
	   *     .use(pluginA, {y: false, z: true})
	   *     // Plugins:
	   *     .use([pluginB, pluginC])
	   *     // Two plugins, the second with options:
	   *     .use([pluginD, [pluginE, {}]])
	   *     // Preset with plugins and settings:
	   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
	   *     // Settings only:
	   *     .use({settings: {position: false}})
	   *   ```
	   *
	   * @template {Array<unknown>} [Parameters=[]]
	   * @template {Node | string | undefined} [Input=undefined]
	   * @template [Output=Input]
	   *
	   * @overload
	   * @param {Preset | null | undefined} [preset]
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *
	   * @overload
	   * @param {PluggableList} list
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *
	   * @overload
	   * @param {Plugin<Parameters, Input, Output>} plugin
	   * @param {...(Parameters | [boolean])} parameters
	   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
	   *
	   * @param {PluggableList | Plugin | Preset | null | undefined} value
	   *   Usable value.
	   * @param {...unknown} parameters
	   *   Parameters, when a plugin is given as a usable value.
	   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
	   *   Current processor.
	   */
	  use(value, ...parameters) {
	    const attachers = this.attachers;
	    const namespace = this.namespace;
	    assertUnfrozen("use", this.frozen);
	    if (value === null || value === void 0) ; else if (typeof value === "function") {
	      addPlugin(value, parameters);
	    } else if (typeof value === "object") {
	      if (Array.isArray(value)) {
	        addList(value);
	      } else {
	        addPreset(value);
	      }
	    } else {
	      throw new TypeError("Expected usable value, not `" + value + "`");
	    }
	    return this;
	    function add(value2) {
	      if (typeof value2 === "function") {
	        addPlugin(value2, []);
	      } else if (typeof value2 === "object") {
	        if (Array.isArray(value2)) {
	          const [plugin, ...parameters2] = (
	            /** @type {PluginTuple<Array<unknown>>} */
	            value2
	          );
	          addPlugin(plugin, parameters2);
	        } else {
	          addPreset(value2);
	        }
	      } else {
	        throw new TypeError("Expected usable value, not `" + value2 + "`");
	      }
	    }
	    function addPreset(result) {
	      if (!("plugins" in result) && !("settings" in result)) {
	        throw new Error(
	          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
	        );
	      }
	      addList(result.plugins);
	      if (result.settings) {
	        namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
	      }
	    }
	    function addList(plugins) {
	      let index2 = -1;
	      if (plugins === null || plugins === void 0) ; else if (Array.isArray(plugins)) {
	        while (++index2 < plugins.length) {
	          const thing = plugins[index2];
	          add(thing);
	        }
	      } else {
	        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
	      }
	    }
	    function addPlugin(plugin, parameters2) {
	      let index2 = -1;
	      let entryIndex = -1;
	      while (++index2 < attachers.length) {
	        if (attachers[index2][0] === plugin) {
	          entryIndex = index2;
	          break;
	        }
	      }
	      if (entryIndex === -1) {
	        attachers.push([plugin, ...parameters2]);
	      } else if (parameters2.length > 0) {
	        let [primary, ...rest] = parameters2;
	        const currentPrimary = attachers[entryIndex][1];
	        if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
	          primary = (0, import_extend.default)(true, currentPrimary, primary);
	        }
	        attachers[entryIndex] = [plugin, primary, ...rest];
	      }
	    }
	  }
	};
	var unified = new Processor().freeze();
	function assertParser(name, value) {
	  if (typeof value !== "function") {
	    throw new TypeError("Cannot `" + name + "` without `parser`");
	  }
	}
	function assertCompiler(name, value) {
	  if (typeof value !== "function") {
	    throw new TypeError("Cannot `" + name + "` without `compiler`");
	  }
	}
	function assertUnfrozen(name, frozen) {
	  if (frozen) {
	    throw new Error(
	      "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
	    );
	  }
	}
	function assertNode(node2) {
	  if (!isPlainObject(node2) || typeof node2.type !== "string") {
	    throw new TypeError("Expected node, got `" + node2 + "`");
	  }
	}
	function assertDone(name, asyncName, complete) {
	  if (!complete) {
	    throw new Error(
	      "`" + name + "` finished async. Use `" + asyncName + "` instead"
	    );
	  }
	}
	function vfile(value) {
	  return looksLikeAVFile(value) ? value : new VFile(value);
	}
	function looksLikeAVFile(value) {
	  return Boolean(
	    value && typeof value === "object" && "message" in value && "messages" in value
	  );
	}
	function looksLikeAValue(value) {
	  return typeof value === "string" || isUint8Array2(value);
	}
	function isUint8Array2(value) {
	  return Boolean(
	    value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
	  );
	}

	// dist/utils.js
	var nonNullable = (value) => value != null;
	var camelToKebab = (str) => str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);
	var transformClassName = (node2) => {
	  if (node2.type !== "element" || node2.properties === void 0 || !Array.isArray(node2.properties.className))
	    return;
	  node2.properties.class = node2.properties.className.join(" ");
	  delete node2.properties.className;
	};
	var transformAriaProps = (node2) => {
	  if (node2.type !== "element" || node2.properties === void 0)
	    return;
	  const ariaProps = Object.keys(node2.properties).filter((key) => key.startsWith("aria"));
	  for (const key of ariaProps) {
	    const value = node2.properties[key];
	    delete node2.properties[key];
	    node2.properties[camelToKebab(key)] = value;
	  }
	};
	var transform = (node2) => {
	  transformClassName(node2);
	  transformAriaProps(node2);
	};
	var visit2 = (visitor, node2) => {
	  visitor(node2);
	  node2.children?.forEach((child) => visit2(visitor, child));
	};
	var rehypeReactPropsToSvelteProps = () => {
	  return (node2, _file, done) => {
	    try {
	      visit2(transform, node2);
	      done();
	    } catch (e) {
	      if (e instanceof Error)
	        return done(e);
	      return done(new Error(String(e)));
	    }
	  };
	};
	var createParser = (plugins) => {
	  const processor = unified().use(remarkParse).use(plugins.map((plugin) => plugin.remarkPlugin).filter(nonNullable)).use(remarkRehype, { allowDangerousHtml: true }).use(plugins.map((plugin) => plugin.rehypePlugin).filter(nonNullable)).use(rehypeReactPropsToSvelteProps);
	  return (md) => processor.runSync(processor.parse(md), md);
	};
	var resolveComponent = (map, tagName, circularCheck = []) => {
	  if (circularCheck.includes(tagName)) {
	    circularCheck.push(tagName);
	    throw new Error(`Circular dependency detected: ${circularCheck.join(" -> ")}`);
	  }
	  const component = map[tagName];
	  if (typeof component === "string") {
	    return resolveComponent(map, component, [...circularCheck, tagName]);
	  }
	  if (component === null)
	    return null;
	  if (component === void 0)
	    return tagName;
	  return component;
	};
	var getComponentsFromPlugins = (plugins) => {
	  return plugins.map((plugin) => plugin.renderer).filter(nonNullable).reduce((acc, cur) => ({ ...acc, ...cur }), {});
	};
	var snippetRendererMarker = Symbol.for("snippetRenderer");
	var snippetRenderer = (snippet) => {
	  const renderer = snippet;
	  renderer[snippetRendererMarker] = true;
	  return renderer;
	};

	Renderer_1[FILENAME] = 'node_modules/svelte-exmarkdown/dist/Renderer.svelte';

	const children = wrap_snippet(Renderer_1, function ($$anchor, nodes = noop) {
		validate_snippet_args(...arguments);

		var fragment = comment();
		var node_1 = first_child(fragment);

		add_svelte_meta(
			() => each(node_1, 17, nodes, index$1, ($$anchor, node) => {
				add_svelte_meta(
					() => Renderer_1($$anchor, {
						get astNode() {
							return get(node);
						}
					}),
					'component',
					Renderer_1,
					39,
					2,
					{ componentTag: 'Renderer' }
				);
			}),
			'each',
			Renderer_1,
			38,
			1
		);

		append($$anchor, fragment);
	});

	function Renderer_1($$anchor, $$props) {
		check_target(new.target);
		push$1($$props, true, Renderer_1);

		const components = getComponentsMap();
		const astContext = ref($$props.astNode);

		user_pre_effect(() => {
			astContext.current = $$props.astNode;
		});

		setAstContext(astContext);

		const svgContextKey = 'svg';

		if (strict_equals($$props.astNode.type, 'element') && strict_equals($$props.astNode.tagName, 'svg')) setContext(svgContextKey, true);

		var $$exports = { ...legacy_api() };
		var fragment_2 = comment();
		var node_2 = first_child(fragment_2);

		{
			var consequent = ($$anchor) => {
				add_svelte_meta(() => children($$anchor, () => $$props.astNode.children), 'render', Renderer_1, 44, 1);
			};

			var alternate_8 = ($$anchor) => {
				var fragment_4 = comment();
				var node_3 = first_child(fragment_4);

				{
					var consequent_9 = ($$anchor) => {
						const Component = tag(user_derived(() => resolveComponent(components.current, $$props.astNode.tagName)), 'Component');

						get(Component);

						var fragment_5 = comment();
						var node_4 = first_child(fragment_5);

						{
							var consequent_4 = ($$anchor) => {
								var fragment_6 = comment();
								var node_5 = first_child(fragment_6);

								{
									var consequent_2 = ($$anchor) => {
										const svgElement = tag(user_derived(() => get(Component)), 'svgElement');

										get(svgElement);

										var fragment_7 = comment();
										var node_6 = first_child(fragment_7);

										{
											var consequent_1 = ($$anchor) => {
												var fragment_8 = comment();
												var node_7 = first_child(fragment_8);

												{
													validate_void_dynamic_element(() => get(svgElement));
													validate_dynamic_element_tag(() => get(svgElement));

													element(
														node_7,
														() => get(svgElement),
														true,
														($$element, $$anchor) => {
															attribute_effect($$element, () => ({
																xmlns: 'http://www.w3.org/2000/svg',
																...$$props.astNode.properties
															}));

															add_svelte_meta(() => children($$anchor, () => $$props.astNode.children), 'render', Renderer_1, 56, 5);
														},
														void 0,
														[51, 4]
													);
												}

												append($$anchor, fragment_8);
											};

											var alternate = ($$anchor) => {
												var fragment_10 = comment();
												var node_8 = first_child(fragment_10);

												{
													validate_dynamic_element_tag(() => get(svgElement));

													element(
														node_8,
														() => get(svgElement),
														true,
														($$element_1, $$anchor) => {
															attribute_effect($$element_1, () => ({
																xmlns: 'http://www.w3.org/2000/svg',
																...$$props.astNode.properties
															}));
														},
														void 0,
														[59, 4]
													);
												}

												append($$anchor, fragment_10);
											};

											add_svelte_meta(
												() => if_block(node_6, ($$render) => {
													if (Array.isArray($$props.astNode.children) && strict_equals($$props.astNode.children.length, 0, false)) $$render(consequent_1); else $$render(alternate, false);
												}),
												'if',
												Renderer_1,
												50,
												3
											);
										}

										append($$anchor, fragment_7);
									};

									var alternate_2 = ($$anchor) => {
										var fragment_11 = comment();
										var node_9 = first_child(fragment_11);

										{
											var consequent_3 = ($$anchor) => {
												var fragment_12 = comment();
												var node_10 = first_child(fragment_12);

												{
													validate_void_dynamic_element(() => get(Component));
													validate_dynamic_element_tag(() => get(Component));

													element(
														node_10,
														() => get(Component),
														false,
														($$element_2, $$anchor) => {
															attribute_effect($$element_2, () => ({ ...$$props.astNode.properties }));
															add_svelte_meta(() => children($$anchor, () => $$props.astNode.children), 'render', Renderer_1, 67, 4);
														},
														void 0,
														[66, 3]
													);
												}

												append($$anchor, fragment_12);
											};

											var alternate_1 = ($$anchor) => {
												var fragment_14 = comment();
												var node_11 = first_child(fragment_14);

												{
													validate_dynamic_element_tag(() => get(Component));

													element(
														node_11,
														() => get(Component),
														false,
														($$element_3, $$anchor) => {
															attribute_effect($$element_3, () => ({ ...$$props.astNode.properties }));
														},
														void 0,
														[70, 3]
													);
												}

												append($$anchor, fragment_14);
											};

											add_svelte_meta(
												() => if_block(
													node_9,
													($$render) => {
														if (Array.isArray($$props.astNode.children) && strict_equals($$props.astNode.children.length, 0, false)) $$render(consequent_3); else $$render(alternate_1, false);
													},
													true
												),
												'if',
												Renderer_1,
												65,
												2
											);
										}

										append($$anchor, fragment_11);
									};

									add_svelte_meta(
										() => if_block(node_5, ($$render) => {
											if (getContext(svgContextKey)) $$render(consequent_2); else $$render(alternate_2, false);
										}),
										'if',
										Renderer_1,
										48,
										2
									);
								}

								append($$anchor, fragment_6);
							};

							var alternate_6 = ($$anchor) => {
								var fragment_15 = comment();
								var node_12 = first_child(fragment_15);

								{
									var consequent_8 = ($$anchor) => {
										var fragment_16 = comment();
										var node_13 = first_child(fragment_16);

										{
											var consequent_6 = ($$anchor) => {
												var fragment_17 = comment();
												var node_14 = first_child(fragment_17);

												{
													var consequent_5 = ($$anchor) => {
														var fragment_19 = comment();

														const _children = wrap_snippet(Renderer_1, function ($$anchor) {
															validate_snippet_args(...arguments);
															add_svelte_meta(() => children($$anchor, () => $$props.astNode.children), 'render', Renderer_1, 76, 5);
														});

														var node_15 = first_child(fragment_19);

														{
															let $0 = user_derived(() => ({ ...$$props.astNode.properties, children: _children }));

															add_svelte_meta(() => snippet(node_15, () => get(Component), () => get($0)), 'render', Renderer_1, 78, 4);
														}

														append($$anchor, fragment_19);
													};

													var alternate_3 = ($$anchor) => {
														var fragment_20 = comment();
														var node_16 = first_child(fragment_20);

														add_svelte_meta(() => snippet(node_16, () => get(Component), () => $$props.astNode.properties), 'render', Renderer_1, 80, 4);
														append($$anchor, fragment_20);
													};

													add_svelte_meta(
														() => if_block(node_14, ($$render) => {
															if (Array.isArray($$props.astNode.children) && strict_equals($$props.astNode.children.length, 0, false)) $$render(consequent_5); else $$render(alternate_3, false);
														}),
														'if',
														Renderer_1,
														74,
														3
													);
												}

												append($$anchor, fragment_17);
											};

											var alternate_5 = ($$anchor) => {
												var fragment_21 = comment();
												var node_17 = first_child(fragment_21);

												{
													var consequent_7 = ($$anchor) => {
														var fragment_22 = comment();
														var node_18 = first_child(fragment_22);

														add_svelte_meta(
															() => component(node_18, () => get(Component), ($$anchor, Component_1) => {
																Component_1($$anchor, spread_props(() => $$props.astNode.properties, {
																	children: wrap_snippet(Renderer_1, ($$anchor, $$slotProps) => {
																		add_svelte_meta(() => children($$anchor, () => $$props.astNode.children), 'render', Renderer_1, 84, 4);
																	}),

																	$$slots: { default: true }
																}));
															}),
															'component',
															Renderer_1,
															83,
															3,
															{ componentTag: 'Component' }
														);

														append($$anchor, fragment_22);
													};

													var alternate_4 = ($$anchor) => {
														var fragment_24 = comment();
														var node_19 = first_child(fragment_24);

														add_svelte_meta(
															() => component(node_19, () => get(Component), ($$anchor, Component_2) => {
																Component_2($$anchor, spread_props(() => $$props.astNode.properties));
															}),
															'component',
															Renderer_1,
															87,
															3,
															{ componentTag: 'Component' }
														);

														append($$anchor, fragment_24);
													};

													add_svelte_meta(
														() => if_block(
															node_17,
															($$render) => {
																if (Array.isArray($$props.astNode.children) && strict_equals($$props.astNode.children.length, 0, false)) $$render(consequent_7); else $$render(alternate_4, false);
															},
															true
														),
														'if',
														Renderer_1,
														82,
														2
													);
												}

												append($$anchor, fragment_21);
											};

											add_svelte_meta(
												() => if_block(node_13, ($$render) => {
													if (snippetRendererMarker in get(Component) && get(Component)[snippetRendererMarker]) $$render(consequent_6); else $$render(alternate_5, false);
												}),
												'if',
												Renderer_1,
												73,
												2
											);
										}

										append($$anchor, fragment_16);
									};

									add_svelte_meta(
										() => if_block(
											node_12,
											($$render) => {
												if (strict_equals(get(Component), null, false)) $$render(consequent_8);
											},
											true
										),
										'if',
										Renderer_1,
										72,
										1
									);
								}

								append($$anchor, fragment_15);
							};

							add_svelte_meta(
								() => if_block(node_4, ($$render) => {
									if (strict_equals(typeof get(Component), 'string')) $$render(consequent_4); else $$render(alternate_6, false);
								}),
								'if',
								Renderer_1,
								47,
								1
							);
						}

						append($$anchor, fragment_5);
					};

					var alternate_7 = ($$anchor) => {
						var fragment_25 = comment();
						var node_20 = first_child(fragment_25);

						{
							var consequent_10 = ($$anchor) => {
								var text = text$1();

								template_effect(() => set_text(text, $$props.astNode.value));
								append($$anchor, text);
							};

							add_svelte_meta(
								() => if_block(
									node_20,
									($$render) => {
										if (strict_equals($$props.astNode.type, 'text') || strict_equals($$props.astNode.type, 'raw')) $$render(consequent_10);
									},
									true
								),
								'if',
								Renderer_1,
								90,
								0
							);
						}

						append($$anchor, fragment_25);
					};

					add_svelte_meta(
						() => if_block(
							node_3,
							($$render) => {
								if (strict_equals($$props.astNode.type, 'element')) $$render(consequent_9); else $$render(alternate_7, false);
							},
							true
						),
						'if',
						Renderer_1,
						45,
						0
					);
				}

				append($$anchor, fragment_4);
			};

			add_svelte_meta(
				() => if_block(node_2, ($$render) => {
					if (strict_equals($$props.astNode.type, 'root')) $$render(consequent); else $$render(alternate_8, false);
				}),
				'if',
				Renderer_1,
				43,
				0
			);
		}

		append($$anchor, fragment_2);

		return pop($$exports);
	}

	Markdown[FILENAME] = 'node_modules/svelte-exmarkdown/dist/Markdown.svelte';

	function Markdown($$anchor, $$props) {
		check_target(new.target);
		push$1($$props, true, Markdown);

		let plugins = prop($$props, 'plugins', 19, () => []),
			snippetRenderers = rest_props($$props, ['$$slots', '$$events', '$$legacy', 'md', 'plugins'], 'snippetRenderers');

		let snippetRenderersPlugin = tag(
			user_derived(() => ({
				renderer: Object.fromEntries(Object.entries(snippetRenderers).map(([tag, renderer]) => {
					if (strict_equals(typeof renderer, 'string')) return [tag, renderer];
					if (strict_equals(typeof renderer, 'function', false)) return undefined;

					return [tag, snippetRenderer(renderer)];
				}).filter((tuple) => equals(tuple, null, false)))
			})),
			'snippetRenderersPlugin'
		);

		let parse = tag(user_derived(() => createParser(plugins())), 'parse');

		const componentsContextValue = ref(
			// eslint-disable-next-line svelte/no-unused-svelte-ignore
			// svelte-ignore state_referenced_locally
			getComponentsFromPlugins([...plugins(), get(snippetRenderersPlugin)])
		);

		user_effect(() => {
			componentsContextValue.current = getComponentsFromPlugins([...plugins(), get(snippetRenderersPlugin)]);
		});

		setComponentsContext(componentsContextValue);

		let result = tag(user_derived(() => get(parse)($$props.md)), 'result');
		var $$exports = { ...legacy_api() };

		add_svelte_meta(
			() => Renderer_1($$anchor, {
				get astNode() {
					return get(result);
				}
			}),
			'component',
			Markdown,
			55,
			0,
			{ componentTag: 'Renderer' }
		);

		return pop($$exports);
	}

	ChunkedText[FILENAME] = 'src/components/ChunkedText.svelte';

	var root_1$2 = add_locations(from_html(`<div class="error svelte-1n8s5vr"> </div>`), ChunkedText[FILENAME], [[59, 4]]);
	var root_4 = add_locations(from_html(`<div class="gap-indicator svelte-1n8s5vr"> </div>`), ChunkedText[FILENAME], [[64, 10]]);
	var root_7$1 = add_locations(from_html(`<div class="chunk-tooltip svelte-1n8s5vr"> </div>`), ChunkedText[FILENAME], [[77, 14]]);
	var root_6$1 = add_locations(from_html(`<div class="chunk svelte-1n8s5vr"><span class="chunk-text svelte-1n8s5vr"><!></span> <!></div>`), ChunkedText[FILENAME], [[68, 10, [[75, 12]]]]);
	var root_9 = add_locations(from_html(`<span class="legend-item svelte-1n8s5vr"> </span>`), ChunkedText[FILENAME], [[89, 10]]);
	var root_10 = add_locations(from_html(`<span class="legend-item svelte-1n8s5vr"> </span>`), ChunkedText[FILENAME], [[94, 10]]);
	var root_8 = add_locations(from_html(`<div class="legend svelte-1n8s5vr"><!> <!></div>`), ChunkedText[FILENAME], [[87, 6]]);
	var root_2 = add_locations(from_html(`<div class="text-container svelte-1n8s5vr"></div> <!>`, 1), ChunkedText[FILENAME], [[61, 4]]);
	var root$2 = add_locations(from_html(`<div class="chunked-text svelte-1n8s5vr"><!></div>`), ChunkedText[FILENAME], [[57, 0]]);

	function ChunkedText($$anchor, $$props) {
		check_target(new.target);
		push$1($$props, false, ChunkedText);

		const config = mutable_source();
		const chunks = mutable_source();
		const gaps = mutable_source();
		const text = mutable_source();
		let page = prop($$props, 'page', 8);
		let configName = prop($$props, 'configName', 8);

		// Force segments to recompute when any dependency changes
		let segments = mutable_source([]);

		function renderTextWithChunks() {
			if (!get(chunks) || !get(chunks).length || !get(text)) {
				return [];
			}

			const newSegments = [];
			let lastEnd = 0;

			get(chunks).forEach((chunk, i) => {
				// Check if there's a gap before this chunk
				const gap = get(gaps).find((g) => strict_equals(g.after_chunk, i - 1));

				if (gap && gap.gap_start > lastEnd) {
					// Add skipped indicator
					newSegments.push({
						type: 'gap',
						content: `↓ ... ${gap.gap_size} chars skipped ... ↓`
					});
				}

				// Use chunk.text directly instead of substring
				newSegments.push({
					type: 'chunk',
					id: chunk.id,
					content: chunk.text, // Use the text from chunk directly
					color: getChunkColor(i),
					tokens: chunk.token_count,
					length: chunk.length
				});

				lastEnd = chunk.end_index;
			});

			return newSegments;
		}

		let hoveredChunk = mutable_source(null);

		legacy_pre_effect(() => (deep_read_state(page()), deep_read_state(configName())), () => {
			set(config, page()?.configs?.[configName()]);
		});

		legacy_pre_effect(() => (get(config)), () => {
			set(chunks, get(config)?.chunks || []);
		});

		legacy_pre_effect(() => (get(config)), () => {
			set(gaps, get(config)?.gaps || []);
		});

		legacy_pre_effect(() => (deep_read_state(page())), () => {
			set(text, page()?.linearized_text || '');
		});

		legacy_pre_effect(() => (get(chunks), get(gaps), get(text)), () => {
			(
				get(chunks),
				get(gaps),
				get(text),
				set(segments, renderTextWithChunks())
			);
		});

		legacy_pre_effect_reset();

		var $$exports = { ...legacy_api() };

		init();

		var div = root$2();
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var div_1 = root_1$2();
				var text_1 = child(div_1);
				template_effect(() => set_text(text_1, `Error: ${(get(config), untrack(() => get(config).error)) ?? ''}`));
				append($$anchor, div_1);
			};

			var alternate_1 = ($$anchor) => {
				var fragment = root_2();
				var div_2 = first_child(fragment);

				add_svelte_meta(
					() => each(div_2, 5, () => get(segments), index$1, ($$anchor, segment) => {
						var fragment_1 = comment();
						var node_1 = first_child(fragment_1);

						{
							var consequent_1 = ($$anchor) => {
								var div_3 = root_4();
								var text_2 = child(div_3, true);

								reset(div_3);
								template_effect(() => set_text(text_2, (get(segment), untrack(() => get(segment).content))));
								append($$anchor, div_3);
							};

							var alternate = ($$anchor) => {
								var fragment_2 = comment();
								var node_2 = first_child(fragment_2);

								{
									var consequent_3 = ($$anchor) => {
										var div_4 = root_6$1();
										var span = child(div_4);
										var node_3 = child(span);

										add_svelte_meta(
											() => Markdown(node_3, {
												get md() {
													return (get(segment), untrack(() => get(segment).content));
												}
											}),
											'component',
											ChunkedText,
											75,
											37,
											{ componentTag: 'Markdown' }
										);

										reset(span);

										var node_4 = sibling(span, 2);

										{
											var consequent_2 = ($$anchor) => {
												var div_5 = root_7$1();
												var text_3 = child(div_5);

												reset(div_5);
												template_effect(() => set_text(text_3, `Chunk ${(get(segment), untrack(() => get(segment).id)) ?? ''} • ${(get(segment), untrack(() => get(segment).tokens)) ?? ''} tokens • ${(get(segment), untrack(() => get(segment).length)) ?? ''} chars`));
												append($$anchor, div_5);
											};

											add_svelte_meta(
												() => if_block(node_4, ($$render) => {
													if ((
														get(hoveredChunk),
														get(segment),
														untrack(() => strict_equals(get(hoveredChunk), get(segment).id))
													)) $$render(consequent_2);
												}),
												'if',
												ChunkedText,
												76,
												12
											);
										}

										reset(div_4);
										template_effect(() => set_style(div_4, `--chunk-color: ${(get(segment), untrack(() => get(segment).color)) ?? ''};`));
										event('mouseenter', div_4, () => set(hoveredChunk, get(segment).id));
										event('mouseleave', div_4, () => set(hoveredChunk, null));
										append($$anchor, div_4);
									};

									add_svelte_meta(
										() => if_block(
											node_2,
											($$render) => {
												if ((
													get(segment),
													untrack(() => strict_equals(get(segment).type, 'chunk'))
												)) $$render(consequent_3);
											},
											true
										),
										'if',
										ChunkedText,
										67,
										8
									);
								}

								append($$anchor, fragment_2);
							};

							add_svelte_meta(
								() => if_block(node_1, ($$render) => {
									if ((
										get(segment),
										untrack(() => strict_equals(get(segment).type, 'gap'))
									)) $$render(consequent_1); else $$render(alternate, false);
								}),
								'if',
								ChunkedText,
								63,
								8
							);
						}

						append($$anchor, fragment_1);
					}),
					'each',
					ChunkedText,
					62,
					6
				);

				var node_5 = sibling(div_2, 2);

				{
					var consequent_5 = ($$anchor) => {
						var div_6 = root_8();
						var node_6 = child(div_6);

						add_svelte_meta(
							() => each(node_6, 1, () => (get(chunks), untrack(() => get(chunks).slice(0, 12))), index$1, ($$anchor, chunk, i) => {
								var span_1 = root_9();
								var text_4 = child(span_1);

								reset(span_1);

								template_effect(
									($0) => {
										set_style(span_1, `color: ${$0 ?? ''};`);
										set_text(text_4, `[${(get(chunk), untrack(() => get(chunk).id)) ?? ''}] ${(get(chunk), untrack(() => get(chunk).token_count)) ?? ''}tok`);
									},
									[
										() => (
											deep_read_state(getChunkColor),
											i,
											untrack(() => getChunkColor(i))
										)
									]
								);

								append($$anchor, span_1);
							}),
							'each',
							ChunkedText,
							88,
							8
						);

						var node_7 = sibling(node_6, 2);

						{
							var consequent_4 = ($$anchor) => {
								var span_2 = root_10();
								var text_5 = child(span_2);
								template_effect(() => set_text(text_5, `... +${(get(chunks), untrack(() => get(chunks).length - 12)) ?? ''} more`));
								append($$anchor, span_2);
							};

							add_svelte_meta(
								() => if_block(node_7, ($$render) => {
									if ((get(chunks), untrack(() => get(chunks).length > 12))) $$render(consequent_4);
								}),
								'if',
								ChunkedText,
								93,
								8
							);
						}
						append($$anchor, div_6);
					};

					add_svelte_meta(
						() => if_block(node_5, ($$render) => {
							if ((
								get(chunks),
								untrack(() => get(chunks) && get(chunks).length > 0)
							)) $$render(consequent_5);
						}),
						'if',
						ChunkedText,
						86,
						4
					);
				}

				append($$anchor, fragment);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if ((get(config), untrack(() => get(config)?.error))) $$render(consequent); else $$render(alternate_1, false);
				}),
				'if',
				ChunkedText,
				58,
				2
			);
		}
		append($$anchor, div);

		return pop($$exports);
	}

	ConfigSelector[FILENAME] = 'src/components/ConfigSelector.svelte';

	var root_1$1 = add_locations(from_html(`<button> </button>`), ConfigSelector[FILENAME], [[39, 6]]);
	var root$1 = add_locations(from_html(`<div class="config-bar svelte-wu61o5"><span class="label svelte-wu61o5">Configurations:</span> <div class="config-buttons svelte-wu61o5"></div> <span class="hint svelte-wu61o5">t=threshold, s=skip_window, m=min_chunk_size • Max 3 configs</span></div>`), ConfigSelector[FILENAME], [[35, 0, [[36, 2], [37, 2], [49, 2]]]]);

	function ConfigSelector($$anchor, $$props) {
		check_target(new.target);
		push$1($$props, false, ConfigSelector);

		let configs = prop($$props, 'configs', 24, () => []);
		let selected = prop($$props, 'selected', 28, () => []);

		// Initialize selected with first config if empty
		// Map config names to their display labels with parameters
		const configLabels = {
			'default': 'Default (t=0.6, s=1, m=50)',
			'roam_optimized': 'Roam Optimized (t=0.4, s=1, m=250)',
			'tight': 'Tight (t=0.8, s=1, m=30)',
			'loose': 'Loose (t=0.4, s=1, m=100)',
			'no_skip': 'No Skip (t=0.6, s=0, m=50)',
			'large_skip': 'Large Skip (t=0.6, s=3, m=50)'
		};

		function toggleConfig(config) {
			if (selected().includes(config)) {
				if (selected().length > 1) {
					selected(selected().filter((c) => strict_equals(c, config, false)));
				}
			} else {
				if (selected().length < 3) {
					// Limit to 3 for readability
					selected([...selected(), config]);
				} else {
					alert('Maximum 3 configurations can be compared at once');
				}
			}
		}

		legacy_pre_effect(() => (deep_read_state(selected()), deep_read_state(configs())), () => {
			if (strict_equals(selected().length, 0) && configs().length > 0) {
				selected([configs()[0]]);
			}
		});

		legacy_pre_effect_reset();

		var $$exports = { ...legacy_api() };

		init();

		var div = root$1();
		var div_1 = sibling(child(div), 2);

		add_svelte_meta(
			() => each(
				div_1,
				5,
				// Map config names to their display labels with parameters
				// Limit to 3 for readability
				configs,
				index$1,
				($$anchor, config) => {
					var button = root_1$1();
					let classes;
					var text = child(button, true);

					reset(button);

					template_effect(
						($0) => {
							classes = set_class(button, 1, 'config-btn svelte-wu61o5', null, classes, $0);

							set_attribute(button, 'title', `threshold=${strict_equals(get(config), 'default') || strict_equals(get(config), 'no_skip') || strict_equals(get(config), 'large_skip')
							? '0.6'
							: strict_equals(get(config), 'tight') ? '0.8' : '0.4'}, skip_window=${strict_equals(get(config), 'no_skip')
							? '0'
							: strict_equals(get(config), 'large_skip') ? '3' : '1'}, min_chunk=${strict_equals(get(config), 'tight')
							? '30'
							: strict_equals(get(config), 'loose') ? '100' : '50'}`);

							set_text(text, (
								get(config),
								untrack(() => configLabels[get(config)] || get(config))
							));
						},
						[() => ({ active: selected().includes(get(config)) })]
					);

					event('click', button, () => toggleConfig(get(config)));
					append($$anchor, button);
				}
			),
			'each',
			ConfigSelector,
			38,
			4
		);
		append($$anchor, div);

		return pop($$exports);
	}

	App[FILENAME] = 'src/App.svelte';

	var root_1 = add_locations(from_html(`<div class="loading svelte-1n46o8q">Loading chunk data...</div>`), App[FILENAME], [[51, 6]]);
	var root_3 = add_locations(from_html(`<div class="error svelte-1n46o8q"><p> </p> <label class="upload-btn svelte-1n46o8q">Upload chunk_data.json <input type="file" accept=".json" class="svelte-1n46o8q"/></label></div>`), App[FILENAME], [[53, 6, [[54, 8], [55, 8, [[57, 10]]]]]]);
	var root_7 = add_locations(from_html(`<div class="text-view svelte-1n46o8q" style="flex: 1;"><h3 class="svelte-1n46o8q"> </h3> <!></div>`), App[FILENAME], [[81, 14, [[82, 16]]]]);
	var root_6 = add_locations(from_html(`<div class="text-views svelte-1n46o8q"></div>`), App[FILENAME], [[79, 10]]);
	var root_5 = add_locations(from_html(`<aside class="sidebar svelte-1n46o8q"><!> <label class="upload-btn svelte-1n46o8q">+ Load New Data <input type="file" accept=".json" class="svelte-1n46o8q"/></label></aside> <div class="main-content svelte-1n46o8q"><!> <!></div>`, 1), App[FILENAME], [[61, 6, [[66, 8, [[68, 10]]]]], [72, 6]]);
	var root = add_locations(from_html(`<main class="svelte-1n46o8q"><div class="container svelte-1n46o8q"><!></div></main>`), App[FILENAME], [[48, 0, [[49, 2]]]]);

	function App($$anchor, $$props) {
		check_target(new.target);
		push$1($$props, true, App);

		let chunkData = tag(state(null), 'chunkData');
		let selectedPageIndex = tag(state(0), 'selectedPageIndex');
		let selectedConfigs = tag(state(proxy([])), 'selectedConfigs');
		let loading = tag(state(true), 'loading');
		let error = tag(state(null), 'error');

		// Load JSON data
		onMount(async () => {
			try {
				// In dev, load from local file; in prod, could fetch from server
				const response = (await track_reactivity_loss(fetch('/chunk_data.json')))();

				if (!response.ok) throw new Error('Failed to load chunk data');

				set(chunkData, (await track_reactivity_loss(response.json()))(), true);
				set(loading, false);
			} catch(err) {
				set(error, err.message, true);
				set(loading, false);
			}
		});

		let currentPage = tag(user_derived(() => get(chunkData)?.pages?.[get(selectedPageIndex)]), 'currentPage');
		let availableConfigs = tag(user_derived(() => get(chunkData)?.configs ? Object.keys(get(chunkData).configs) : []), 'availableConfigs');

		function handleFileUpload(event) {
			const file = event.target.files[0];

			if (file) {
				const reader = new FileReader();

				reader.onload = (e) => {
					try {
						set(chunkData, JSON.parse(e.target.result), true);
						set(selectedPageIndex, 0);
						set(error, null);
					} catch(err) {
						set(error, 'Invalid JSON file');
					}
				};

				reader.readAsText(file);
			}
		}

		var $$exports = { ...legacy_api() };
		var main = root();
		var div = child(main);
		var node = child(div);

		{
			var consequent = ($$anchor) => {
				var div_1 = root_1();

				append($$anchor, div_1);
			};

			var alternate_1 = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				{
					var consequent_1 = ($$anchor) => {
						var div_2 = root_3();
						var p = child(div_2);
						var text = child(p);

						var label = sibling(p, 2);
						var input = sibling(child(label));
						template_effect(() => set_text(text, `Error: ${get(error) ?? ''}`));
						event('change', input, handleFileUpload);
						append($$anchor, div_2);
					};

					var alternate = ($$anchor) => {
						var fragment_1 = comment();
						var node_2 = first_child(fragment_1);

						{
							var consequent_3 = ($$anchor) => {
								var fragment_2 = root_5();
								var aside = first_child(fragment_2);
								var node_3 = child(aside);

								add_svelte_meta(
									() => PageSidebar(node_3, {
										get pages() {
											return get(chunkData).pages;
										},

										get selectedIndex() {
											return get(selectedPageIndex);
										},

										set selectedIndex($$value) {
											set(selectedPageIndex, $$value, true);
										}
									}),
									'component',
									App,
									62,
									8,
									{ componentTag: 'PageSidebar' }
								);

								var label_1 = sibling(node_3, 2);
								var input_1 = sibling(child(label_1));

								var div_3 = sibling(aside, 2);
								var node_4 = child(div_3);

								add_svelte_meta(
									() => ConfigSelector(node_4, {
										get configs() {
											return get(availableConfigs);
										},

										get selected() {
											return get(selectedConfigs);
										},

										set selected($$value) {
											set(selectedConfigs, $$value, true);
										}
									}),
									'component',
									App,
									73,
									8,
									{ componentTag: 'ConfigSelector' }
								);

								var node_5 = sibling(node_4, 2);

								{
									var consequent_2 = ($$anchor) => {
										var div_4 = root_6();

										add_svelte_meta(
											() => each(div_4, 21, () => get(selectedConfigs), index$1, ($$anchor, configName) => {
												var div_5 = root_7();
												var h3 = child(div_5);
												var text_1 = child(h3, true);

												reset(h3);

												var node_6 = sibling(h3, 2);

												add_svelte_meta(
													() => ChunkedText(node_6, {
														get page() {
															return get(currentPage);
														},

														get configName() {
															return get(configName);
														}
													}),
													'component',
													App,
													83,
													16,
													{ componentTag: 'ChunkedText' }
												);

												reset(div_5);
												template_effect(() => set_text(text_1, get(configName)));
												append($$anchor, div_5);
											}),
											'each',
											App,
											80,
											12
										);
										append($$anchor, div_4);
									};

									add_svelte_meta(
										() => if_block(node_5, ($$render) => {
											if (get(currentPage)) $$render(consequent_2);
										}),
										'if',
										App,
										78,
										8
									);
								}
								event('change', input_1, handleFileUpload);
								append($$anchor, fragment_2);
							};

							add_svelte_meta(
								() => if_block(
									node_2,
									($$render) => {
										if (get(chunkData)) $$render(consequent_3);
									},
									true
								),
								'if',
								App,
								60,
								4
							);
						}

						append($$anchor, fragment_1);
					};

					add_svelte_meta(
						() => if_block(
							node_1,
							($$render) => {
								if (get(error)) $$render(consequent_1); else $$render(alternate, false);
							},
							true
						),
						'if',
						App,
						52,
						4
					);
				}

				append($$anchor, fragment);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if (get(loading)) $$render(consequent); else $$render(alternate_1, false);
				}),
				'if',
				App,
				50,
				4
			);
		}
		append($$anchor, main);

		return pop($$exports);
	}

	const app = mount(App, {
	  target: document.body,
	});

	return app;

})();
//# sourceMappingURL=bundle.js.map
